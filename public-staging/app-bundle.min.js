(function webpackUniversalModuleDefinition(root, factory) {
	if(typeof exports === 'object' && typeof module === 'object')
		module.exports = factory();
	else if(typeof define === 'function' && define.amd)
		define([], factory);
	else {
		var a = factory();
		for(var i in a) (typeof exports === 'object' ? exports : root)[i] = a[i];
	}
})(this, function() {
return webpackJsonp([0],[
/* 0 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	__webpack_require__(3);

	var _angular = __webpack_require__(17);

	var _angular2 = _interopRequireDefault(_angular);

	var _angularUiRouter = __webpack_require__(19);

	var _angularUiRouter2 = _interopRequireDefault(_angularUiRouter);

	var _angularAnimate = __webpack_require__(20);

	var _angularAnimate2 = _interopRequireDefault(_angularAnimate);

	__webpack_require__(22);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	__webpack_require__(23); /**
	                             * Created by rdollete on 4/1/16.
	                             */

	__webpack_require__(25);
	__webpack_require__(27);

	_angular2.default.module('phenoCom', [_angularUiRouter2.default, _angularAnimate2.default, 'ngCookies', 'ngMessages']);

	__webpack_require__(28);
	__webpack_require__(126);
	__webpack_require__(127);
	__webpack_require__(128);

/***/ },
/* 1 */,
/* 2 */,
/* 3 */,
/* 4 */,
/* 5 */,
/* 6 */,
/* 7 */,
/* 8 */,
/* 9 */,
/* 10 */,
/* 11 */,
/* 12 */,
/* 13 */,
/* 14 */,
/* 15 */,
/* 16 */,
/* 17 */,
/* 18 */,
/* 19 */,
/* 20 */
/***/ function(module, exports, __webpack_require__) {

	__webpack_require__(21);
	module.exports = 'ngAnimate';


/***/ },
/* 21 */
/***/ function(module, exports) {

	/**
	 * @license AngularJS v1.5.3
	 * (c) 2010-2016 Google, Inc. http://angularjs.org
	 * License: MIT
	 */
	(function(window, angular, undefined) {'use strict';

	/* jshint ignore:start */
	var noop        = angular.noop;
	var copy        = angular.copy;
	var extend      = angular.extend;
	var jqLite      = angular.element;
	var forEach     = angular.forEach;
	var isArray     = angular.isArray;
	var isString    = angular.isString;
	var isObject    = angular.isObject;
	var isUndefined = angular.isUndefined;
	var isDefined   = angular.isDefined;
	var isFunction  = angular.isFunction;
	var isElement   = angular.isElement;

	var ELEMENT_NODE = 1;
	var COMMENT_NODE = 8;

	var ADD_CLASS_SUFFIX = '-add';
	var REMOVE_CLASS_SUFFIX = '-remove';
	var EVENT_CLASS_PREFIX = 'ng-';
	var ACTIVE_CLASS_SUFFIX = '-active';
	var PREPARE_CLASS_SUFFIX = '-prepare';

	var NG_ANIMATE_CLASSNAME = 'ng-animate';
	var NG_ANIMATE_CHILDREN_DATA = '$$ngAnimateChildren';

	// Detect proper transitionend/animationend event names.
	var CSS_PREFIX = '', TRANSITION_PROP, TRANSITIONEND_EVENT, ANIMATION_PROP, ANIMATIONEND_EVENT;

	// If unprefixed events are not supported but webkit-prefixed are, use the latter.
	// Otherwise, just use W3C names, browsers not supporting them at all will just ignore them.
	// Note: Chrome implements `window.onwebkitanimationend` and doesn't implement `window.onanimationend`
	// but at the same time dispatches the `animationend` event and not `webkitAnimationEnd`.
	// Register both events in case `window.onanimationend` is not supported because of that,
	// do the same for `transitionend` as Safari is likely to exhibit similar behavior.
	// Also, the only modern browser that uses vendor prefixes for transitions/keyframes is webkit
	// therefore there is no reason to test anymore for other vendor prefixes:
	// http://caniuse.com/#search=transition
	if (isUndefined(window.ontransitionend) && isDefined(window.onwebkittransitionend)) {
	  CSS_PREFIX = '-webkit-';
	  TRANSITION_PROP = 'WebkitTransition';
	  TRANSITIONEND_EVENT = 'webkitTransitionEnd transitionend';
	} else {
	  TRANSITION_PROP = 'transition';
	  TRANSITIONEND_EVENT = 'transitionend';
	}

	if (isUndefined(window.onanimationend) && isDefined(window.onwebkitanimationend)) {
	  CSS_PREFIX = '-webkit-';
	  ANIMATION_PROP = 'WebkitAnimation';
	  ANIMATIONEND_EVENT = 'webkitAnimationEnd animationend';
	} else {
	  ANIMATION_PROP = 'animation';
	  ANIMATIONEND_EVENT = 'animationend';
	}

	var DURATION_KEY = 'Duration';
	var PROPERTY_KEY = 'Property';
	var DELAY_KEY = 'Delay';
	var TIMING_KEY = 'TimingFunction';
	var ANIMATION_ITERATION_COUNT_KEY = 'IterationCount';
	var ANIMATION_PLAYSTATE_KEY = 'PlayState';
	var SAFE_FAST_FORWARD_DURATION_VALUE = 9999;

	var ANIMATION_DELAY_PROP = ANIMATION_PROP + DELAY_KEY;
	var ANIMATION_DURATION_PROP = ANIMATION_PROP + DURATION_KEY;
	var TRANSITION_DELAY_PROP = TRANSITION_PROP + DELAY_KEY;
	var TRANSITION_DURATION_PROP = TRANSITION_PROP + DURATION_KEY;

	var isPromiseLike = function(p) {
	  return p && p.then ? true : false;
	};

	var ngMinErr = angular.$$minErr('ng');
	function assertArg(arg, name, reason) {
	  if (!arg) {
	    throw ngMinErr('areq', "Argument '{0}' is {1}", (name || '?'), (reason || "required"));
	  }
	  return arg;
	}

	function mergeClasses(a,b) {
	  if (!a && !b) return '';
	  if (!a) return b;
	  if (!b) return a;
	  if (isArray(a)) a = a.join(' ');
	  if (isArray(b)) b = b.join(' ');
	  return a + ' ' + b;
	}

	function packageStyles(options) {
	  var styles = {};
	  if (options && (options.to || options.from)) {
	    styles.to = options.to;
	    styles.from = options.from;
	  }
	  return styles;
	}

	function pendClasses(classes, fix, isPrefix) {
	  var className = '';
	  classes = isArray(classes)
	      ? classes
	      : classes && isString(classes) && classes.length
	          ? classes.split(/\s+/)
	          : [];
	  forEach(classes, function(klass, i) {
	    if (klass && klass.length > 0) {
	      className += (i > 0) ? ' ' : '';
	      className += isPrefix ? fix + klass
	                            : klass + fix;
	    }
	  });
	  return className;
	}

	function removeFromArray(arr, val) {
	  var index = arr.indexOf(val);
	  if (val >= 0) {
	    arr.splice(index, 1);
	  }
	}

	function stripCommentsFromElement(element) {
	  if (element instanceof jqLite) {
	    switch (element.length) {
	      case 0:
	        return [];
	        break;

	      case 1:
	        // there is no point of stripping anything if the element
	        // is the only element within the jqLite wrapper.
	        // (it's important that we retain the element instance.)
	        if (element[0].nodeType === ELEMENT_NODE) {
	          return element;
	        }
	        break;

	      default:
	        return jqLite(extractElementNode(element));
	        break;
	    }
	  }

	  if (element.nodeType === ELEMENT_NODE) {
	    return jqLite(element);
	  }
	}

	function extractElementNode(element) {
	  if (!element[0]) return element;
	  for (var i = 0; i < element.length; i++) {
	    var elm = element[i];
	    if (elm.nodeType == ELEMENT_NODE) {
	      return elm;
	    }
	  }
	}

	function $$addClass($$jqLite, element, className) {
	  forEach(element, function(elm) {
	    $$jqLite.addClass(elm, className);
	  });
	}

	function $$removeClass($$jqLite, element, className) {
	  forEach(element, function(elm) {
	    $$jqLite.removeClass(elm, className);
	  });
	}

	function applyAnimationClassesFactory($$jqLite) {
	  return function(element, options) {
	    if (options.addClass) {
	      $$addClass($$jqLite, element, options.addClass);
	      options.addClass = null;
	    }
	    if (options.removeClass) {
	      $$removeClass($$jqLite, element, options.removeClass);
	      options.removeClass = null;
	    }
	  }
	}

	function prepareAnimationOptions(options) {
	  options = options || {};
	  if (!options.$$prepared) {
	    var domOperation = options.domOperation || noop;
	    options.domOperation = function() {
	      options.$$domOperationFired = true;
	      domOperation();
	      domOperation = noop;
	    };
	    options.$$prepared = true;
	  }
	  return options;
	}

	function applyAnimationStyles(element, options) {
	  applyAnimationFromStyles(element, options);
	  applyAnimationToStyles(element, options);
	}

	function applyAnimationFromStyles(element, options) {
	  if (options.from) {
	    element.css(options.from);
	    options.from = null;
	  }
	}

	function applyAnimationToStyles(element, options) {
	  if (options.to) {
	    element.css(options.to);
	    options.to = null;
	  }
	}

	function mergeAnimationDetails(element, oldAnimation, newAnimation) {
	  var target = oldAnimation.options || {};
	  var newOptions = newAnimation.options || {};

	  var toAdd = (target.addClass || '') + ' ' + (newOptions.addClass || '');
	  var toRemove = (target.removeClass || '') + ' ' + (newOptions.removeClass || '');
	  var classes = resolveElementClasses(element.attr('class'), toAdd, toRemove);

	  if (newOptions.preparationClasses) {
	    target.preparationClasses = concatWithSpace(newOptions.preparationClasses, target.preparationClasses);
	    delete newOptions.preparationClasses;
	  }

	  // noop is basically when there is no callback; otherwise something has been set
	  var realDomOperation = target.domOperation !== noop ? target.domOperation : null;

	  extend(target, newOptions);

	  // TODO(matsko or sreeramu): proper fix is to maintain all animation callback in array and call at last,but now only leave has the callback so no issue with this.
	  if (realDomOperation) {
	    target.domOperation = realDomOperation;
	  }

	  if (classes.addClass) {
	    target.addClass = classes.addClass;
	  } else {
	    target.addClass = null;
	  }

	  if (classes.removeClass) {
	    target.removeClass = classes.removeClass;
	  } else {
	    target.removeClass = null;
	  }

	  oldAnimation.addClass = target.addClass;
	  oldAnimation.removeClass = target.removeClass;

	  return target;
	}

	function resolveElementClasses(existing, toAdd, toRemove) {
	  var ADD_CLASS = 1;
	  var REMOVE_CLASS = -1;

	  var flags = {};
	  existing = splitClassesToLookup(existing);

	  toAdd = splitClassesToLookup(toAdd);
	  forEach(toAdd, function(value, key) {
	    flags[key] = ADD_CLASS;
	  });

	  toRemove = splitClassesToLookup(toRemove);
	  forEach(toRemove, function(value, key) {
	    flags[key] = flags[key] === ADD_CLASS ? null : REMOVE_CLASS;
	  });

	  var classes = {
	    addClass: '',
	    removeClass: ''
	  };

	  forEach(flags, function(val, klass) {
	    var prop, allow;
	    if (val === ADD_CLASS) {
	      prop = 'addClass';
	      allow = !existing[klass];
	    } else if (val === REMOVE_CLASS) {
	      prop = 'removeClass';
	      allow = existing[klass];
	    }
	    if (allow) {
	      if (classes[prop].length) {
	        classes[prop] += ' ';
	      }
	      classes[prop] += klass;
	    }
	  });

	  function splitClassesToLookup(classes) {
	    if (isString(classes)) {
	      classes = classes.split(' ');
	    }

	    var obj = {};
	    forEach(classes, function(klass) {
	      // sometimes the split leaves empty string values
	      // incase extra spaces were applied to the options
	      if (klass.length) {
	        obj[klass] = true;
	      }
	    });
	    return obj;
	  }

	  return classes;
	}

	function getDomNode(element) {
	  return (element instanceof angular.element) ? element[0] : element;
	}

	function applyGeneratedPreparationClasses(element, event, options) {
	  var classes = '';
	  if (event) {
	    classes = pendClasses(event, EVENT_CLASS_PREFIX, true);
	  }
	  if (options.addClass) {
	    classes = concatWithSpace(classes, pendClasses(options.addClass, ADD_CLASS_SUFFIX));
	  }
	  if (options.removeClass) {
	    classes = concatWithSpace(classes, pendClasses(options.removeClass, REMOVE_CLASS_SUFFIX));
	  }
	  if (classes.length) {
	    options.preparationClasses = classes;
	    element.addClass(classes);
	  }
	}

	function clearGeneratedClasses(element, options) {
	  if (options.preparationClasses) {
	    element.removeClass(options.preparationClasses);
	    options.preparationClasses = null;
	  }
	  if (options.activeClasses) {
	    element.removeClass(options.activeClasses);
	    options.activeClasses = null;
	  }
	}

	function blockTransitions(node, duration) {
	  // we use a negative delay value since it performs blocking
	  // yet it doesn't kill any existing transitions running on the
	  // same element which makes this safe for class-based animations
	  var value = duration ? '-' + duration + 's' : '';
	  applyInlineStyle(node, [TRANSITION_DELAY_PROP, value]);
	  return [TRANSITION_DELAY_PROP, value];
	}

	function blockKeyframeAnimations(node, applyBlock) {
	  var value = applyBlock ? 'paused' : '';
	  var key = ANIMATION_PROP + ANIMATION_PLAYSTATE_KEY;
	  applyInlineStyle(node, [key, value]);
	  return [key, value];
	}

	function applyInlineStyle(node, styleTuple) {
	  var prop = styleTuple[0];
	  var value = styleTuple[1];
	  node.style[prop] = value;
	}

	function concatWithSpace(a,b) {
	  if (!a) return b;
	  if (!b) return a;
	  return a + ' ' + b;
	}

	var $$rAFSchedulerFactory = ['$$rAF', function($$rAF) {
	  var queue, cancelFn;

	  function scheduler(tasks) {
	    // we make a copy since RAFScheduler mutates the state
	    // of the passed in array variable and this would be difficult
	    // to track down on the outside code
	    queue = queue.concat(tasks);
	    nextTick();
	  }

	  queue = scheduler.queue = [];

	  /* waitUntilQuiet does two things:
	   * 1. It will run the FINAL `fn` value only when an uncanceled RAF has passed through
	   * 2. It will delay the next wave of tasks from running until the quiet `fn` has run.
	   *
	   * The motivation here is that animation code can request more time from the scheduler
	   * before the next wave runs. This allows for certain DOM properties such as classes to
	   * be resolved in time for the next animation to run.
	   */
	  scheduler.waitUntilQuiet = function(fn) {
	    if (cancelFn) cancelFn();

	    cancelFn = $$rAF(function() {
	      cancelFn = null;
	      fn();
	      nextTick();
	    });
	  };

	  return scheduler;

	  function nextTick() {
	    if (!queue.length) return;

	    var items = queue.shift();
	    for (var i = 0; i < items.length; i++) {
	      items[i]();
	    }

	    if (!cancelFn) {
	      $$rAF(function() {
	        if (!cancelFn) nextTick();
	      });
	    }
	  }
	}];

	/**
	 * @ngdoc directive
	 * @name ngAnimateChildren
	 * @restrict AE
	 * @element ANY
	 *
	 * @description
	 *
	 * ngAnimateChildren allows you to specify that children of this element should animate even if any
	 * of the children's parents are currently animating. By default, when an element has an active `enter`, `leave`, or `move`
	 * (structural) animation, child elements that also have an active structural animation are not animated.
	 *
	 * Note that even if `ngAnimteChildren` is set, no child animations will run when the parent element is removed from the DOM (`leave` animation).
	 *
	 *
	 * @param {string} ngAnimateChildren If the value is empty, `true` or `on`,
	 *     then child animations are allowed. If the value is `false`, child animations are not allowed.
	 *
	 * @example
	 * <example module="ngAnimateChildren" name="ngAnimateChildren" deps="angular-animate.js" animations="true">
	     <file name="index.html">
	       <div ng-controller="mainController as main">
	         <label>Show container? <input type="checkbox" ng-model="main.enterElement" /></label>
	         <label>Animate children? <input type="checkbox" ng-model="main.animateChildren" /></label>
	         <hr>
	         <div ng-animate-children="{{main.animateChildren}}">
	           <div ng-if="main.enterElement" class="container">
	             List of items:
	             <div ng-repeat="item in [0, 1, 2, 3]" class="item">Item {{item}}</div>
	           </div>
	         </div>
	       </div>
	     </file>
	     <file name="animations.css">

	      .container.ng-enter,
	      .container.ng-leave {
	        transition: all ease 1.5s;
	      }

	      .container.ng-enter,
	      .container.ng-leave-active {
	        opacity: 0;
	      }

	      .container.ng-leave,
	      .container.ng-enter-active {
	        opacity: 1;
	      }

	      .item {
	        background: firebrick;
	        color: #FFF;
	        margin-bottom: 10px;
	      }

	      .item.ng-enter,
	      .item.ng-leave {
	        transition: transform 1.5s ease;
	      }

	      .item.ng-enter {
	        transform: translateX(50px);
	      }

	      .item.ng-enter-active {
	        transform: translateX(0);
	      }
	    </file>
	    <file name="script.js">
	      angular.module('ngAnimateChildren', ['ngAnimate'])
	        .controller('mainController', function() {
	          this.animateChildren = false;
	          this.enterElement = false;
	        });
	    </file>
	  </example>
	 */
	var $$AnimateChildrenDirective = ['$interpolate', function($interpolate) {
	  return {
	    link: function(scope, element, attrs) {
	      var val = attrs.ngAnimateChildren;
	      if (angular.isString(val) && val.length === 0) { //empty attribute
	        element.data(NG_ANIMATE_CHILDREN_DATA, true);
	      } else {
	        // Interpolate and set the value, so that it is available to
	        // animations that run right after compilation
	        setData($interpolate(val)(scope));
	        attrs.$observe('ngAnimateChildren', setData);
	      }

	      function setData(value) {
	        value = value === 'on' || value === 'true';
	        element.data(NG_ANIMATE_CHILDREN_DATA, value);
	      }
	    }
	  };
	}];

	var ANIMATE_TIMER_KEY = '$$animateCss';

	/**
	 * @ngdoc service
	 * @name $animateCss
	 * @kind object
	 *
	 * @description
	 * The `$animateCss` service is a useful utility to trigger customized CSS-based transitions/keyframes
	 * from a JavaScript-based animation or directly from a directive. The purpose of `$animateCss` is NOT
	 * to side-step how `$animate` and ngAnimate work, but the goal is to allow pre-existing animations or
	 * directives to create more complex animations that can be purely driven using CSS code.
	 *
	 * Note that only browsers that support CSS transitions and/or keyframe animations are capable of
	 * rendering animations triggered via `$animateCss` (bad news for IE9 and lower).
	 *
	 * ## Usage
	 * Once again, `$animateCss` is designed to be used inside of a registered JavaScript animation that
	 * is powered by ngAnimate. It is possible to use `$animateCss` directly inside of a directive, however,
	 * any automatic control over cancelling animations and/or preventing animations from being run on
	 * child elements will not be handled by Angular. For this to work as expected, please use `$animate` to
	 * trigger the animation and then setup a JavaScript animation that injects `$animateCss` to trigger
	 * the CSS animation.
	 *
	 * The example below shows how we can create a folding animation on an element using `ng-if`:
	 *
	 * ```html
	 * <!-- notice the `fold-animation` CSS class -->
	 * <div ng-if="onOff" class="fold-animation">
	 *   This element will go BOOM
	 * </div>
	 * <button ng-click="onOff=true">Fold In</button>
	 * ```
	 *
	 * Now we create the **JavaScript animation** that will trigger the CSS transition:
	 *
	 * ```js
	 * ngModule.animation('.fold-animation', ['$animateCss', function($animateCss) {
	 *   return {
	 *     enter: function(element, doneFn) {
	 *       var height = element[0].offsetHeight;
	 *       return $animateCss(element, {
	 *         from: { height:'0px' },
	 *         to: { height:height + 'px' },
	 *         duration: 1 // one second
	 *       });
	 *     }
	 *   }
	 * }]);
	 * ```
	 *
	 * ## More Advanced Uses
	 *
	 * `$animateCss` is the underlying code that ngAnimate uses to power **CSS-based animations** behind the scenes. Therefore CSS hooks
	 * like `.ng-EVENT`, `.ng-EVENT-active`, `.ng-EVENT-stagger` are all features that can be triggered using `$animateCss` via JavaScript code.
	 *
	 * This also means that just about any combination of adding classes, removing classes, setting styles, dynamically setting a keyframe animation,
	 * applying a hardcoded duration or delay value, changing the animation easing or applying a stagger animation are all options that work with
	 * `$animateCss`. The service itself is smart enough to figure out the combination of options and examine the element styling properties in order
	 * to provide a working animation that will run in CSS.
	 *
	 * The example below showcases a more advanced version of the `.fold-animation` from the example above:
	 *
	 * ```js
	 * ngModule.animation('.fold-animation', ['$animateCss', function($animateCss) {
	 *   return {
	 *     enter: function(element, doneFn) {
	 *       var height = element[0].offsetHeight;
	 *       return $animateCss(element, {
	 *         addClass: 'red large-text pulse-twice',
	 *         easing: 'ease-out',
	 *         from: { height:'0px' },
	 *         to: { height:height + 'px' },
	 *         duration: 1 // one second
	 *       });
	 *     }
	 *   }
	 * }]);
	 * ```
	 *
	 * Since we're adding/removing CSS classes then the CSS transition will also pick those up:
	 *
	 * ```css
	 * /&#42; since a hardcoded duration value of 1 was provided in the JavaScript animation code,
	 * the CSS classes below will be transitioned despite them being defined as regular CSS classes &#42;/
	 * .red { background:red; }
	 * .large-text { font-size:20px; }
	 *
	 * /&#42; we can also use a keyframe animation and $animateCss will make it work alongside the transition &#42;/
	 * .pulse-twice {
	 *   animation: 0.5s pulse linear 2;
	 *   -webkit-animation: 0.5s pulse linear 2;
	 * }
	 *
	 * @keyframes pulse {
	 *   from { transform: scale(0.5); }
	 *   to { transform: scale(1.5); }
	 * }
	 *
	 * @-webkit-keyframes pulse {
	 *   from { -webkit-transform: scale(0.5); }
	 *   to { -webkit-transform: scale(1.5); }
	 * }
	 * ```
	 *
	 * Given this complex combination of CSS classes, styles and options, `$animateCss` will figure everything out and make the animation happen.
	 *
	 * ## How the Options are handled
	 *
	 * `$animateCss` is very versatile and intelligent when it comes to figuring out what configurations to apply to the element to ensure the animation
	 * works with the options provided. Say for example we were adding a class that contained a keyframe value and we wanted to also animate some inline
	 * styles using the `from` and `to` properties.
	 *
	 * ```js
	 * var animator = $animateCss(element, {
	 *   from: { background:'red' },
	 *   to: { background:'blue' }
	 * });
	 * animator.start();
	 * ```
	 *
	 * ```css
	 * .rotating-animation {
	 *   animation:0.5s rotate linear;
	 *   -webkit-animation:0.5s rotate linear;
	 * }
	 *
	 * @keyframes rotate {
	 *   from { transform: rotate(0deg); }
	 *   to { transform: rotate(360deg); }
	 * }
	 *
	 * @-webkit-keyframes rotate {
	 *   from { -webkit-transform: rotate(0deg); }
	 *   to { -webkit-transform: rotate(360deg); }
	 * }
	 * ```
	 *
	 * The missing pieces here are that we do not have a transition set (within the CSS code nor within the `$animateCss` options) and the duration of the animation is
	 * going to be detected from what the keyframe styles on the CSS class are. In this event, `$animateCss` will automatically create an inline transition
	 * style matching the duration detected from the keyframe style (which is present in the CSS class that is being added) and then prepare both the transition
	 * and keyframe animations to run in parallel on the element. Then when the animation is underway the provided `from` and `to` CSS styles will be applied
	 * and spread across the transition and keyframe animation.
	 *
	 * ## What is returned
	 *
	 * `$animateCss` works in two stages: a preparation phase and an animation phase. Therefore when `$animateCss` is first called it will NOT actually
	 * start the animation. All that is going on here is that the element is being prepared for the animation (which means that the generated CSS classes are
	 * added and removed on the element). Once `$animateCss` is called it will return an object with the following properties:
	 *
	 * ```js
	 * var animator = $animateCss(element, { ... });
	 * ```
	 *
	 * Now what do the contents of our `animator` variable look like:
	 *
	 * ```js
	 * {
	 *   // starts the animation
	 *   start: Function,
	 *
	 *   // ends (aborts) the animation
	 *   end: Function
	 * }
	 * ```
	 *
	 * To actually start the animation we need to run `animation.start()` which will then return a promise that we can hook into to detect when the animation ends.
	 * If we choose not to run the animation then we MUST run `animation.end()` to perform a cleanup on the element (since some CSS classes and styles may have been
	 * applied to the element during the preparation phase). Note that all other properties such as duration, delay, transitions and keyframes are just properties
	 * and that changing them will not reconfigure the parameters of the animation.
	 *
	 * ### runner.done() vs runner.then()
	 * It is documented that `animation.start()` will return a promise object and this is true, however, there is also an additional method available on the
	 * runner called `.done(callbackFn)`. The done method works the same as `.finally(callbackFn)`, however, it does **not trigger a digest to occur**.
	 * Therefore, for performance reasons, it's always best to use `runner.done(callback)` instead of `runner.then()`, `runner.catch()` or `runner.finally()`
	 * unless you really need a digest to kick off afterwards.
	 *
	 * Keep in mind that, to make this easier, ngAnimate has tweaked the JS animations API to recognize when a runner instance is returned from $animateCss
	 * (so there is no need to call `runner.done(doneFn)` inside of your JavaScript animation code).
	 * Check the {@link ngAnimate.$animateCss#usage animation code above} to see how this works.
	 *
	 * @param {DOMElement} element the element that will be animated
	 * @param {object} options the animation-related options that will be applied during the animation
	 *
	 * * `event` - The DOM event (e.g. enter, leave, move). When used, a generated CSS class of `ng-EVENT` and `ng-EVENT-active` will be applied
	 * to the element during the animation. Multiple events can be provided when spaces are used as a separator. (Note that this will not perform any DOM operation.)
	 * * `structural` - Indicates that the `ng-` prefix will be added to the event class. Setting to `false` or omitting will turn `ng-EVENT` and
	 * `ng-EVENT-active` in `EVENT` and `EVENT-active`. Unused if `event` is omitted.
	 * * `easing` - The CSS easing value that will be applied to the transition or keyframe animation (or both).
	 * * `transitionStyle` - The raw CSS transition style that will be used (e.g. `1s linear all`).
	 * * `keyframeStyle` - The raw CSS keyframe animation style that will be used (e.g. `1s my_animation linear`).
	 * * `from` - The starting CSS styles (a key/value object) that will be applied at the start of the animation.
	 * * `to` - The ending CSS styles (a key/value object) that will be applied across the animation via a CSS transition.
	 * * `addClass` - A space separated list of CSS classes that will be added to the element and spread across the animation.
	 * * `removeClass` - A space separated list of CSS classes that will be removed from the element and spread across the animation.
	 * * `duration` - A number value representing the total duration of the transition and/or keyframe (note that a value of 1 is 1000ms). If a value of `0`
	 * is provided then the animation will be skipped entirely.
	 * * `delay` - A number value representing the total delay of the transition and/or keyframe (note that a value of 1 is 1000ms). If a value of `true` is
	 * used then whatever delay value is detected from the CSS classes will be mirrored on the elements styles (e.g. by setting delay true then the style value
	 * of the element will be `transition-delay: DETECTED_VALUE`). Using `true` is useful when you want the CSS classes and inline styles to all share the same
	 * CSS delay value.
	 * * `stagger` - A numeric time value representing the delay between successively animated elements
	 * ({@link ngAnimate#css-staggering-animations Click here to learn how CSS-based staggering works in ngAnimate.})
	 * * `staggerIndex` - The numeric index representing the stagger item (e.g. a value of 5 is equal to the sixth item in the stagger; therefore when a
	 *   `stagger` option value of `0.1` is used then there will be a stagger delay of `600ms`)
	 * * `applyClassesEarly` - Whether or not the classes being added or removed will be used when detecting the animation. This is set by `$animate` when enter/leave/move animations are fired to ensure that the CSS classes are resolved in time. (Note that this will prevent any transitions from occurring on the classes being added and removed.)
	 * * `cleanupStyles` - Whether or not the provided `from` and `to` styles will be removed once
	 *    the animation is closed. This is useful for when the styles are used purely for the sake of
	 *    the animation and do not have a lasting visual effect on the element (e.g. a collapse and open animation).
	 *    By default this value is set to `false`.
	 *
	 * @return {object} an object with start and end methods and details about the animation.
	 *
	 * * `start` - The method to start the animation. This will return a `Promise` when called.
	 * * `end` - This method will cancel the animation and remove all applied CSS classes and styles.
	 */
	var ONE_SECOND = 1000;
	var BASE_TEN = 10;

	var ELAPSED_TIME_MAX_DECIMAL_PLACES = 3;
	var CLOSING_TIME_BUFFER = 1.5;

	var DETECT_CSS_PROPERTIES = {
	  transitionDuration:      TRANSITION_DURATION_PROP,
	  transitionDelay:         TRANSITION_DELAY_PROP,
	  transitionProperty:      TRANSITION_PROP + PROPERTY_KEY,
	  animationDuration:       ANIMATION_DURATION_PROP,
	  animationDelay:          ANIMATION_DELAY_PROP,
	  animationIterationCount: ANIMATION_PROP + ANIMATION_ITERATION_COUNT_KEY
	};

	var DETECT_STAGGER_CSS_PROPERTIES = {
	  transitionDuration:      TRANSITION_DURATION_PROP,
	  transitionDelay:         TRANSITION_DELAY_PROP,
	  animationDuration:       ANIMATION_DURATION_PROP,
	  animationDelay:          ANIMATION_DELAY_PROP
	};

	function getCssKeyframeDurationStyle(duration) {
	  return [ANIMATION_DURATION_PROP, duration + 's'];
	}

	function getCssDelayStyle(delay, isKeyframeAnimation) {
	  var prop = isKeyframeAnimation ? ANIMATION_DELAY_PROP : TRANSITION_DELAY_PROP;
	  return [prop, delay + 's'];
	}

	function computeCssStyles($window, element, properties) {
	  var styles = Object.create(null);
	  var detectedStyles = $window.getComputedStyle(element) || {};
	  forEach(properties, function(formalStyleName, actualStyleName) {
	    var val = detectedStyles[formalStyleName];
	    if (val) {
	      var c = val.charAt(0);

	      // only numerical-based values have a negative sign or digit as the first value
	      if (c === '-' || c === '+' || c >= 0) {
	        val = parseMaxTime(val);
	      }

	      // by setting this to null in the event that the delay is not set or is set directly as 0
	      // then we can still allow for negative values to be used later on and not mistake this
	      // value for being greater than any other negative value.
	      if (val === 0) {
	        val = null;
	      }
	      styles[actualStyleName] = val;
	    }
	  });

	  return styles;
	}

	function parseMaxTime(str) {
	  var maxValue = 0;
	  var values = str.split(/\s*,\s*/);
	  forEach(values, function(value) {
	    // it's always safe to consider only second values and omit `ms` values since
	    // getComputedStyle will always handle the conversion for us
	    if (value.charAt(value.length - 1) == 's') {
	      value = value.substring(0, value.length - 1);
	    }
	    value = parseFloat(value) || 0;
	    maxValue = maxValue ? Math.max(value, maxValue) : value;
	  });
	  return maxValue;
	}

	function truthyTimingValue(val) {
	  return val === 0 || val != null;
	}

	function getCssTransitionDurationStyle(duration, applyOnlyDuration) {
	  var style = TRANSITION_PROP;
	  var value = duration + 's';
	  if (applyOnlyDuration) {
	    style += DURATION_KEY;
	  } else {
	    value += ' linear all';
	  }
	  return [style, value];
	}

	function createLocalCacheLookup() {
	  var cache = Object.create(null);
	  return {
	    flush: function() {
	      cache = Object.create(null);
	    },

	    count: function(key) {
	      var entry = cache[key];
	      return entry ? entry.total : 0;
	    },

	    get: function(key) {
	      var entry = cache[key];
	      return entry && entry.value;
	    },

	    put: function(key, value) {
	      if (!cache[key]) {
	        cache[key] = { total: 1, value: value };
	      } else {
	        cache[key].total++;
	      }
	    }
	  };
	}

	// we do not reassign an already present style value since
	// if we detect the style property value again we may be
	// detecting styles that were added via the `from` styles.
	// We make use of `isDefined` here since an empty string
	// or null value (which is what getPropertyValue will return
	// for a non-existing style) will still be marked as a valid
	// value for the style (a falsy value implies that the style
	// is to be removed at the end of the animation). If we had a simple
	// "OR" statement then it would not be enough to catch that.
	function registerRestorableStyles(backup, node, properties) {
	  forEach(properties, function(prop) {
	    backup[prop] = isDefined(backup[prop])
	        ? backup[prop]
	        : node.style.getPropertyValue(prop);
	  });
	}

	var $AnimateCssProvider = ['$animateProvider', function($animateProvider) {
	  var gcsLookup = createLocalCacheLookup();
	  var gcsStaggerLookup = createLocalCacheLookup();

	  this.$get = ['$window', '$$jqLite', '$$AnimateRunner', '$timeout',
	               '$$forceReflow', '$sniffer', '$$rAFScheduler', '$$animateQueue',
	       function($window,   $$jqLite,   $$AnimateRunner,   $timeout,
	                $$forceReflow,   $sniffer,   $$rAFScheduler, $$animateQueue) {

	    var applyAnimationClasses = applyAnimationClassesFactory($$jqLite);

	    var parentCounter = 0;
	    function gcsHashFn(node, extraClasses) {
	      var KEY = "$$ngAnimateParentKey";
	      var parentNode = node.parentNode;
	      var parentID = parentNode[KEY] || (parentNode[KEY] = ++parentCounter);
	      return parentID + '-' + node.getAttribute('class') + '-' + extraClasses;
	    }

	    function computeCachedCssStyles(node, className, cacheKey, properties) {
	      var timings = gcsLookup.get(cacheKey);

	      if (!timings) {
	        timings = computeCssStyles($window, node, properties);
	        if (timings.animationIterationCount === 'infinite') {
	          timings.animationIterationCount = 1;
	        }
	      }

	      // we keep putting this in multiple times even though the value and the cacheKey are the same
	      // because we're keeping an internal tally of how many duplicate animations are detected.
	      gcsLookup.put(cacheKey, timings);
	      return timings;
	    }

	    function computeCachedCssStaggerStyles(node, className, cacheKey, properties) {
	      var stagger;

	      // if we have one or more existing matches of matching elements
	      // containing the same parent + CSS styles (which is how cacheKey works)
	      // then staggering is possible
	      if (gcsLookup.count(cacheKey) > 0) {
	        stagger = gcsStaggerLookup.get(cacheKey);

	        if (!stagger) {
	          var staggerClassName = pendClasses(className, '-stagger');

	          $$jqLite.addClass(node, staggerClassName);

	          stagger = computeCssStyles($window, node, properties);

	          // force the conversion of a null value to zero incase not set
	          stagger.animationDuration = Math.max(stagger.animationDuration, 0);
	          stagger.transitionDuration = Math.max(stagger.transitionDuration, 0);

	          $$jqLite.removeClass(node, staggerClassName);

	          gcsStaggerLookup.put(cacheKey, stagger);
	        }
	      }

	      return stagger || {};
	    }

	    var cancelLastRAFRequest;
	    var rafWaitQueue = [];
	    function waitUntilQuiet(callback) {
	      rafWaitQueue.push(callback);
	      $$rAFScheduler.waitUntilQuiet(function() {
	        gcsLookup.flush();
	        gcsStaggerLookup.flush();

	        // DO NOT REMOVE THIS LINE OR REFACTOR OUT THE `pageWidth` variable.
	        // PLEASE EXAMINE THE `$$forceReflow` service to understand why.
	        var pageWidth = $$forceReflow();

	        // we use a for loop to ensure that if the queue is changed
	        // during this looping then it will consider new requests
	        for (var i = 0; i < rafWaitQueue.length; i++) {
	          rafWaitQueue[i](pageWidth);
	        }
	        rafWaitQueue.length = 0;
	      });
	    }

	    function computeTimings(node, className, cacheKey) {
	      var timings = computeCachedCssStyles(node, className, cacheKey, DETECT_CSS_PROPERTIES);
	      var aD = timings.animationDelay;
	      var tD = timings.transitionDelay;
	      timings.maxDelay = aD && tD
	          ? Math.max(aD, tD)
	          : (aD || tD);
	      timings.maxDuration = Math.max(
	          timings.animationDuration * timings.animationIterationCount,
	          timings.transitionDuration);

	      return timings;
	    }

	    return function init(element, initialOptions) {
	      // all of the animation functions should create
	      // a copy of the options data, however, if a
	      // parent service has already created a copy then
	      // we should stick to using that
	      var options = initialOptions || {};
	      if (!options.$$prepared) {
	        options = prepareAnimationOptions(copy(options));
	      }

	      var restoreStyles = {};
	      var node = getDomNode(element);
	      if (!node
	          || !node.parentNode
	          || !$$animateQueue.enabled()) {
	        return closeAndReturnNoopAnimator();
	      }

	      var temporaryStyles = [];
	      var classes = element.attr('class');
	      var styles = packageStyles(options);
	      var animationClosed;
	      var animationPaused;
	      var animationCompleted;
	      var runner;
	      var runnerHost;
	      var maxDelay;
	      var maxDelayTime;
	      var maxDuration;
	      var maxDurationTime;
	      var startTime;
	      var events = [];

	      if (options.duration === 0 || (!$sniffer.animations && !$sniffer.transitions)) {
	        return closeAndReturnNoopAnimator();
	      }

	      var method = options.event && isArray(options.event)
	            ? options.event.join(' ')
	            : options.event;

	      var isStructural = method && options.structural;
	      var structuralClassName = '';
	      var addRemoveClassName = '';

	      if (isStructural) {
	        structuralClassName = pendClasses(method, EVENT_CLASS_PREFIX, true);
	      } else if (method) {
	        structuralClassName = method;
	      }

	      if (options.addClass) {
	        addRemoveClassName += pendClasses(options.addClass, ADD_CLASS_SUFFIX);
	      }

	      if (options.removeClass) {
	        if (addRemoveClassName.length) {
	          addRemoveClassName += ' ';
	        }
	        addRemoveClassName += pendClasses(options.removeClass, REMOVE_CLASS_SUFFIX);
	      }

	      // there may be a situation where a structural animation is combined together
	      // with CSS classes that need to resolve before the animation is computed.
	      // However this means that there is no explicit CSS code to block the animation
	      // from happening (by setting 0s none in the class name). If this is the case
	      // we need to apply the classes before the first rAF so we know to continue if
	      // there actually is a detected transition or keyframe animation
	      if (options.applyClassesEarly && addRemoveClassName.length) {
	        applyAnimationClasses(element, options);
	      }

	      var preparationClasses = [structuralClassName, addRemoveClassName].join(' ').trim();
	      var fullClassName = classes + ' ' + preparationClasses;
	      var activeClasses = pendClasses(preparationClasses, ACTIVE_CLASS_SUFFIX);
	      var hasToStyles = styles.to && Object.keys(styles.to).length > 0;
	      var containsKeyframeAnimation = (options.keyframeStyle || '').length > 0;

	      // there is no way we can trigger an animation if no styles and
	      // no classes are being applied which would then trigger a transition,
	      // unless there a is raw keyframe value that is applied to the element.
	      if (!containsKeyframeAnimation
	           && !hasToStyles
	           && !preparationClasses) {
	        return closeAndReturnNoopAnimator();
	      }

	      var cacheKey, stagger;
	      if (options.stagger > 0) {
	        var staggerVal = parseFloat(options.stagger);
	        stagger = {
	          transitionDelay: staggerVal,
	          animationDelay: staggerVal,
	          transitionDuration: 0,
	          animationDuration: 0
	        };
	      } else {
	        cacheKey = gcsHashFn(node, fullClassName);
	        stagger = computeCachedCssStaggerStyles(node, preparationClasses, cacheKey, DETECT_STAGGER_CSS_PROPERTIES);
	      }

	      if (!options.$$skipPreparationClasses) {
	        $$jqLite.addClass(element, preparationClasses);
	      }

	      var applyOnlyDuration;

	      if (options.transitionStyle) {
	        var transitionStyle = [TRANSITION_PROP, options.transitionStyle];
	        applyInlineStyle(node, transitionStyle);
	        temporaryStyles.push(transitionStyle);
	      }

	      if (options.duration >= 0) {
	        applyOnlyDuration = node.style[TRANSITION_PROP].length > 0;
	        var durationStyle = getCssTransitionDurationStyle(options.duration, applyOnlyDuration);

	        // we set the duration so that it will be picked up by getComputedStyle later
	        applyInlineStyle(node, durationStyle);
	        temporaryStyles.push(durationStyle);
	      }

	      if (options.keyframeStyle) {
	        var keyframeStyle = [ANIMATION_PROP, options.keyframeStyle];
	        applyInlineStyle(node, keyframeStyle);
	        temporaryStyles.push(keyframeStyle);
	      }

	      var itemIndex = stagger
	          ? options.staggerIndex >= 0
	              ? options.staggerIndex
	              : gcsLookup.count(cacheKey)
	          : 0;

	      var isFirst = itemIndex === 0;

	      // this is a pre-emptive way of forcing the setup classes to be added and applied INSTANTLY
	      // without causing any combination of transitions to kick in. By adding a negative delay value
	      // it forces the setup class' transition to end immediately. We later then remove the negative
	      // transition delay to allow for the transition to naturally do it's thing. The beauty here is
	      // that if there is no transition defined then nothing will happen and this will also allow
	      // other transitions to be stacked on top of each other without any chopping them out.
	      if (isFirst && !options.skipBlocking) {
	        blockTransitions(node, SAFE_FAST_FORWARD_DURATION_VALUE);
	      }

	      var timings = computeTimings(node, fullClassName, cacheKey);
	      var relativeDelay = timings.maxDelay;
	      maxDelay = Math.max(relativeDelay, 0);
	      maxDuration = timings.maxDuration;

	      var flags = {};
	      flags.hasTransitions          = timings.transitionDuration > 0;
	      flags.hasAnimations           = timings.animationDuration > 0;
	      flags.hasTransitionAll        = flags.hasTransitions && timings.transitionProperty == 'all';
	      flags.applyTransitionDuration = hasToStyles && (
	                                        (flags.hasTransitions && !flags.hasTransitionAll)
	                                         || (flags.hasAnimations && !flags.hasTransitions));
	      flags.applyAnimationDuration  = options.duration && flags.hasAnimations;
	      flags.applyTransitionDelay    = truthyTimingValue(options.delay) && (flags.applyTransitionDuration || flags.hasTransitions);
	      flags.applyAnimationDelay     = truthyTimingValue(options.delay) && flags.hasAnimations;
	      flags.recalculateTimingStyles = addRemoveClassName.length > 0;

	      if (flags.applyTransitionDuration || flags.applyAnimationDuration) {
	        maxDuration = options.duration ? parseFloat(options.duration) : maxDuration;

	        if (flags.applyTransitionDuration) {
	          flags.hasTransitions = true;
	          timings.transitionDuration = maxDuration;
	          applyOnlyDuration = node.style[TRANSITION_PROP + PROPERTY_KEY].length > 0;
	          temporaryStyles.push(getCssTransitionDurationStyle(maxDuration, applyOnlyDuration));
	        }

	        if (flags.applyAnimationDuration) {
	          flags.hasAnimations = true;
	          timings.animationDuration = maxDuration;
	          temporaryStyles.push(getCssKeyframeDurationStyle(maxDuration));
	        }
	      }

	      if (maxDuration === 0 && !flags.recalculateTimingStyles) {
	        return closeAndReturnNoopAnimator();
	      }

	      if (options.delay != null) {
	        var delayStyle;
	        if (typeof options.delay !== "boolean") {
	          delayStyle = parseFloat(options.delay);
	          // number in options.delay means we have to recalculate the delay for the closing timeout
	          maxDelay = Math.max(delayStyle, 0);
	        }

	        if (flags.applyTransitionDelay) {
	          temporaryStyles.push(getCssDelayStyle(delayStyle));
	        }

	        if (flags.applyAnimationDelay) {
	          temporaryStyles.push(getCssDelayStyle(delayStyle, true));
	        }
	      }

	      // we need to recalculate the delay value since we used a pre-emptive negative
	      // delay value and the delay value is required for the final event checking. This
	      // property will ensure that this will happen after the RAF phase has passed.
	      if (options.duration == null && timings.transitionDuration > 0) {
	        flags.recalculateTimingStyles = flags.recalculateTimingStyles || isFirst;
	      }

	      maxDelayTime = maxDelay * ONE_SECOND;
	      maxDurationTime = maxDuration * ONE_SECOND;
	      if (!options.skipBlocking) {
	        flags.blockTransition = timings.transitionDuration > 0;
	        flags.blockKeyframeAnimation = timings.animationDuration > 0 &&
	                                       stagger.animationDelay > 0 &&
	                                       stagger.animationDuration === 0;
	      }

	      if (options.from) {
	        if (options.cleanupStyles) {
	          registerRestorableStyles(restoreStyles, node, Object.keys(options.from));
	        }
	        applyAnimationFromStyles(element, options);
	      }

	      if (flags.blockTransition || flags.blockKeyframeAnimation) {
	        applyBlocking(maxDuration);
	      } else if (!options.skipBlocking) {
	        blockTransitions(node, false);
	      }

	      // TODO(matsko): for 1.5 change this code to have an animator object for better debugging
	      return {
	        $$willAnimate: true,
	        end: endFn,
	        start: function() {
	          if (animationClosed) return;

	          runnerHost = {
	            end: endFn,
	            cancel: cancelFn,
	            resume: null, //this will be set during the start() phase
	            pause: null
	          };

	          runner = new $$AnimateRunner(runnerHost);

	          waitUntilQuiet(start);

	          // we don't have access to pause/resume the animation
	          // since it hasn't run yet. AnimateRunner will therefore
	          // set noop functions for resume and pause and they will
	          // later be overridden once the animation is triggered
	          return runner;
	        }
	      };

	      function endFn() {
	        close();
	      }

	      function cancelFn() {
	        close(true);
	      }

	      function close(rejected) { // jshint ignore:line
	        // if the promise has been called already then we shouldn't close
	        // the animation again
	        if (animationClosed || (animationCompleted && animationPaused)) return;
	        animationClosed = true;
	        animationPaused = false;

	        if (!options.$$skipPreparationClasses) {
	          $$jqLite.removeClass(element, preparationClasses);
	        }
	        $$jqLite.removeClass(element, activeClasses);

	        blockKeyframeAnimations(node, false);
	        blockTransitions(node, false);

	        forEach(temporaryStyles, function(entry) {
	          // There is only one way to remove inline style properties entirely from elements.
	          // By using `removeProperty` this works, but we need to convert camel-cased CSS
	          // styles down to hyphenated values.
	          node.style[entry[0]] = '';
	        });

	        applyAnimationClasses(element, options);
	        applyAnimationStyles(element, options);

	        if (Object.keys(restoreStyles).length) {
	          forEach(restoreStyles, function(value, prop) {
	            value ? node.style.setProperty(prop, value)
	                  : node.style.removeProperty(prop);
	          });
	        }

	        // the reason why we have this option is to allow a synchronous closing callback
	        // that is fired as SOON as the animation ends (when the CSS is removed) or if
	        // the animation never takes off at all. A good example is a leave animation since
	        // the element must be removed just after the animation is over or else the element
	        // will appear on screen for one animation frame causing an overbearing flicker.
	        if (options.onDone) {
	          options.onDone();
	        }

	        if (events && events.length) {
	          // Remove the transitionend / animationend listener(s)
	          element.off(events.join(' '), onAnimationProgress);
	        }

	        //Cancel the fallback closing timeout and remove the timer data
	        var animationTimerData = element.data(ANIMATE_TIMER_KEY);
	        if (animationTimerData) {
	          $timeout.cancel(animationTimerData[0].timer);
	          element.removeData(ANIMATE_TIMER_KEY);
	        }

	        // if the preparation function fails then the promise is not setup
	        if (runner) {
	          runner.complete(!rejected);
	        }
	      }

	      function applyBlocking(duration) {
	        if (flags.blockTransition) {
	          blockTransitions(node, duration);
	        }

	        if (flags.blockKeyframeAnimation) {
	          blockKeyframeAnimations(node, !!duration);
	        }
	      }

	      function closeAndReturnNoopAnimator() {
	        runner = new $$AnimateRunner({
	          end: endFn,
	          cancel: cancelFn
	        });

	        // should flush the cache animation
	        waitUntilQuiet(noop);
	        close();

	        return {
	          $$willAnimate: false,
	          start: function() {
	            return runner;
	          },
	          end: endFn
	        };
	      }

	      function onAnimationProgress(event) {
	        event.stopPropagation();
	        var ev = event.originalEvent || event;

	        // we now always use `Date.now()` due to the recent changes with
	        // event.timeStamp in Firefox, Webkit and Chrome (see #13494 for more info)
	        var timeStamp = ev.$manualTimeStamp || Date.now();

	        /* Firefox (or possibly just Gecko) likes to not round values up
	         * when a ms measurement is used for the animation */
	        var elapsedTime = parseFloat(ev.elapsedTime.toFixed(ELAPSED_TIME_MAX_DECIMAL_PLACES));

	        /* $manualTimeStamp is a mocked timeStamp value which is set
	         * within browserTrigger(). This is only here so that tests can
	         * mock animations properly. Real events fallback to event.timeStamp,
	         * or, if they don't, then a timeStamp is automatically created for them.
	         * We're checking to see if the timeStamp surpasses the expected delay,
	         * but we're using elapsedTime instead of the timeStamp on the 2nd
	         * pre-condition since animationPauseds sometimes close off early */
	        if (Math.max(timeStamp - startTime, 0) >= maxDelayTime && elapsedTime >= maxDuration) {
	          // we set this flag to ensure that if the transition is paused then, when resumed,
	          // the animation will automatically close itself since transitions cannot be paused.
	          animationCompleted = true;
	          close();
	        }
	      }

	      function start() {
	        if (animationClosed) return;
	        if (!node.parentNode) {
	          close();
	          return;
	        }

	        // even though we only pause keyframe animations here the pause flag
	        // will still happen when transitions are used. Only the transition will
	        // not be paused since that is not possible. If the animation ends when
	        // paused then it will not complete until unpaused or cancelled.
	        var playPause = function(playAnimation) {
	          if (!animationCompleted) {
	            animationPaused = !playAnimation;
	            if (timings.animationDuration) {
	              var value = blockKeyframeAnimations(node, animationPaused);
	              animationPaused
	                  ? temporaryStyles.push(value)
	                  : removeFromArray(temporaryStyles, value);
	            }
	          } else if (animationPaused && playAnimation) {
	            animationPaused = false;
	            close();
	          }
	        };

	        // checking the stagger duration prevents an accidentally cascade of the CSS delay style
	        // being inherited from the parent. If the transition duration is zero then we can safely
	        // rely that the delay value is an intentional stagger delay style.
	        var maxStagger = itemIndex > 0
	                         && ((timings.transitionDuration && stagger.transitionDuration === 0) ||
	                            (timings.animationDuration && stagger.animationDuration === 0))
	                         && Math.max(stagger.animationDelay, stagger.transitionDelay);
	        if (maxStagger) {
	          $timeout(triggerAnimationStart,
	                   Math.floor(maxStagger * itemIndex * ONE_SECOND),
	                   false);
	        } else {
	          triggerAnimationStart();
	        }

	        // this will decorate the existing promise runner with pause/resume methods
	        runnerHost.resume = function() {
	          playPause(true);
	        };

	        runnerHost.pause = function() {
	          playPause(false);
	        };

	        function triggerAnimationStart() {
	          // just incase a stagger animation kicks in when the animation
	          // itself was cancelled entirely
	          if (animationClosed) return;

	          applyBlocking(false);

	          forEach(temporaryStyles, function(entry) {
	            var key = entry[0];
	            var value = entry[1];
	            node.style[key] = value;
	          });

	          applyAnimationClasses(element, options);
	          $$jqLite.addClass(element, activeClasses);

	          if (flags.recalculateTimingStyles) {
	            fullClassName = node.className + ' ' + preparationClasses;
	            cacheKey = gcsHashFn(node, fullClassName);

	            timings = computeTimings(node, fullClassName, cacheKey);
	            relativeDelay = timings.maxDelay;
	            maxDelay = Math.max(relativeDelay, 0);
	            maxDuration = timings.maxDuration;

	            if (maxDuration === 0) {
	              close();
	              return;
	            }

	            flags.hasTransitions = timings.transitionDuration > 0;
	            flags.hasAnimations = timings.animationDuration > 0;
	          }

	          if (flags.applyAnimationDelay) {
	            relativeDelay = typeof options.delay !== "boolean" && truthyTimingValue(options.delay)
	                  ? parseFloat(options.delay)
	                  : relativeDelay;

	            maxDelay = Math.max(relativeDelay, 0);
	            timings.animationDelay = relativeDelay;
	            delayStyle = getCssDelayStyle(relativeDelay, true);
	            temporaryStyles.push(delayStyle);
	            node.style[delayStyle[0]] = delayStyle[1];
	          }

	          maxDelayTime = maxDelay * ONE_SECOND;
	          maxDurationTime = maxDuration * ONE_SECOND;

	          if (options.easing) {
	            var easeProp, easeVal = options.easing;
	            if (flags.hasTransitions) {
	              easeProp = TRANSITION_PROP + TIMING_KEY;
	              temporaryStyles.push([easeProp, easeVal]);
	              node.style[easeProp] = easeVal;
	            }
	            if (flags.hasAnimations) {
	              easeProp = ANIMATION_PROP + TIMING_KEY;
	              temporaryStyles.push([easeProp, easeVal]);
	              node.style[easeProp] = easeVal;
	            }
	          }

	          if (timings.transitionDuration) {
	            events.push(TRANSITIONEND_EVENT);
	          }

	          if (timings.animationDuration) {
	            events.push(ANIMATIONEND_EVENT);
	          }

	          startTime = Date.now();
	          var timerTime = maxDelayTime + CLOSING_TIME_BUFFER * maxDurationTime;
	          var endTime = startTime + timerTime;

	          var animationsData = element.data(ANIMATE_TIMER_KEY) || [];
	          var setupFallbackTimer = true;
	          if (animationsData.length) {
	            var currentTimerData = animationsData[0];
	            setupFallbackTimer = endTime > currentTimerData.expectedEndTime;
	            if (setupFallbackTimer) {
	              $timeout.cancel(currentTimerData.timer);
	            } else {
	              animationsData.push(close);
	            }
	          }

	          if (setupFallbackTimer) {
	            var timer = $timeout(onAnimationExpired, timerTime, false);
	            animationsData[0] = {
	              timer: timer,
	              expectedEndTime: endTime
	            };
	            animationsData.push(close);
	            element.data(ANIMATE_TIMER_KEY, animationsData);
	          }

	          if (events.length) {
	            element.on(events.join(' '), onAnimationProgress);
	          }

	          if (options.to) {
	            if (options.cleanupStyles) {
	              registerRestorableStyles(restoreStyles, node, Object.keys(options.to));
	            }
	            applyAnimationToStyles(element, options);
	          }
	        }

	        function onAnimationExpired() {
	          var animationsData = element.data(ANIMATE_TIMER_KEY);

	          // this will be false in the event that the element was
	          // removed from the DOM (via a leave animation or something
	          // similar)
	          if (animationsData) {
	            for (var i = 1; i < animationsData.length; i++) {
	              animationsData[i]();
	            }
	            element.removeData(ANIMATE_TIMER_KEY);
	          }
	        }
	      }
	    };
	  }];
	}];

	var $$AnimateCssDriverProvider = ['$$animationProvider', function($$animationProvider) {
	  $$animationProvider.drivers.push('$$animateCssDriver');

	  var NG_ANIMATE_SHIM_CLASS_NAME = 'ng-animate-shim';
	  var NG_ANIMATE_ANCHOR_CLASS_NAME = 'ng-anchor';

	  var NG_OUT_ANCHOR_CLASS_NAME = 'ng-anchor-out';
	  var NG_IN_ANCHOR_CLASS_NAME = 'ng-anchor-in';

	  function isDocumentFragment(node) {
	    return node.parentNode && node.parentNode.nodeType === 11;
	  }

	  this.$get = ['$animateCss', '$rootScope', '$$AnimateRunner', '$rootElement', '$sniffer', '$$jqLite', '$document',
	       function($animateCss,   $rootScope,   $$AnimateRunner,   $rootElement,   $sniffer,   $$jqLite,   $document) {

	    // only browsers that support these properties can render animations
	    if (!$sniffer.animations && !$sniffer.transitions) return noop;

	    var bodyNode = $document[0].body;
	    var rootNode = getDomNode($rootElement);

	    var rootBodyElement = jqLite(
	      // this is to avoid using something that exists outside of the body
	      // we also special case the doc fragment case because our unit test code
	      // appends the $rootElement to the body after the app has been bootstrapped
	      isDocumentFragment(rootNode) || bodyNode.contains(rootNode) ? rootNode : bodyNode
	    );

	    var applyAnimationClasses = applyAnimationClassesFactory($$jqLite);

	    return function initDriverFn(animationDetails) {
	      return animationDetails.from && animationDetails.to
	          ? prepareFromToAnchorAnimation(animationDetails.from,
	                                         animationDetails.to,
	                                         animationDetails.classes,
	                                         animationDetails.anchors)
	          : prepareRegularAnimation(animationDetails);
	    };

	    function filterCssClasses(classes) {
	      //remove all the `ng-` stuff
	      return classes.replace(/\bng-\S+\b/g, '');
	    }

	    function getUniqueValues(a, b) {
	      if (isString(a)) a = a.split(' ');
	      if (isString(b)) b = b.split(' ');
	      return a.filter(function(val) {
	        return b.indexOf(val) === -1;
	      }).join(' ');
	    }

	    function prepareAnchoredAnimation(classes, outAnchor, inAnchor) {
	      var clone = jqLite(getDomNode(outAnchor).cloneNode(true));
	      var startingClasses = filterCssClasses(getClassVal(clone));

	      outAnchor.addClass(NG_ANIMATE_SHIM_CLASS_NAME);
	      inAnchor.addClass(NG_ANIMATE_SHIM_CLASS_NAME);

	      clone.addClass(NG_ANIMATE_ANCHOR_CLASS_NAME);

	      rootBodyElement.append(clone);

	      var animatorIn, animatorOut = prepareOutAnimation();

	      // the user may not end up using the `out` animation and
	      // only making use of the `in` animation or vice-versa.
	      // In either case we should allow this and not assume the
	      // animation is over unless both animations are not used.
	      if (!animatorOut) {
	        animatorIn = prepareInAnimation();
	        if (!animatorIn) {
	          return end();
	        }
	      }

	      var startingAnimator = animatorOut || animatorIn;

	      return {
	        start: function() {
	          var runner;

	          var currentAnimation = startingAnimator.start();
	          currentAnimation.done(function() {
	            currentAnimation = null;
	            if (!animatorIn) {
	              animatorIn = prepareInAnimation();
	              if (animatorIn) {
	                currentAnimation = animatorIn.start();
	                currentAnimation.done(function() {
	                  currentAnimation = null;
	                  end();
	                  runner.complete();
	                });
	                return currentAnimation;
	              }
	            }
	            // in the event that there is no `in` animation
	            end();
	            runner.complete();
	          });

	          runner = new $$AnimateRunner({
	            end: endFn,
	            cancel: endFn
	          });

	          return runner;

	          function endFn() {
	            if (currentAnimation) {
	              currentAnimation.end();
	            }
	          }
	        }
	      };

	      function calculateAnchorStyles(anchor) {
	        var styles = {};

	        var coords = getDomNode(anchor).getBoundingClientRect();

	        // we iterate directly since safari messes up and doesn't return
	        // all the keys for the coords object when iterated
	        forEach(['width','height','top','left'], function(key) {
	          var value = coords[key];
	          switch (key) {
	            case 'top':
	              value += bodyNode.scrollTop;
	              break;
	            case 'left':
	              value += bodyNode.scrollLeft;
	              break;
	          }
	          styles[key] = Math.floor(value) + 'px';
	        });
	        return styles;
	      }

	      function prepareOutAnimation() {
	        var animator = $animateCss(clone, {
	          addClass: NG_OUT_ANCHOR_CLASS_NAME,
	          delay: true,
	          from: calculateAnchorStyles(outAnchor)
	        });

	        // read the comment within `prepareRegularAnimation` to understand
	        // why this check is necessary
	        return animator.$$willAnimate ? animator : null;
	      }

	      function getClassVal(element) {
	        return element.attr('class') || '';
	      }

	      function prepareInAnimation() {
	        var endingClasses = filterCssClasses(getClassVal(inAnchor));
	        var toAdd = getUniqueValues(endingClasses, startingClasses);
	        var toRemove = getUniqueValues(startingClasses, endingClasses);

	        var animator = $animateCss(clone, {
	          to: calculateAnchorStyles(inAnchor),
	          addClass: NG_IN_ANCHOR_CLASS_NAME + ' ' + toAdd,
	          removeClass: NG_OUT_ANCHOR_CLASS_NAME + ' ' + toRemove,
	          delay: true
	        });

	        // read the comment within `prepareRegularAnimation` to understand
	        // why this check is necessary
	        return animator.$$willAnimate ? animator : null;
	      }

	      function end() {
	        clone.remove();
	        outAnchor.removeClass(NG_ANIMATE_SHIM_CLASS_NAME);
	        inAnchor.removeClass(NG_ANIMATE_SHIM_CLASS_NAME);
	      }
	    }

	    function prepareFromToAnchorAnimation(from, to, classes, anchors) {
	      var fromAnimation = prepareRegularAnimation(from, noop);
	      var toAnimation = prepareRegularAnimation(to, noop);

	      var anchorAnimations = [];
	      forEach(anchors, function(anchor) {
	        var outElement = anchor['out'];
	        var inElement = anchor['in'];
	        var animator = prepareAnchoredAnimation(classes, outElement, inElement);
	        if (animator) {
	          anchorAnimations.push(animator);
	        }
	      });

	      // no point in doing anything when there are no elements to animate
	      if (!fromAnimation && !toAnimation && anchorAnimations.length === 0) return;

	      return {
	        start: function() {
	          var animationRunners = [];

	          if (fromAnimation) {
	            animationRunners.push(fromAnimation.start());
	          }

	          if (toAnimation) {
	            animationRunners.push(toAnimation.start());
	          }

	          forEach(anchorAnimations, function(animation) {
	            animationRunners.push(animation.start());
	          });

	          var runner = new $$AnimateRunner({
	            end: endFn,
	            cancel: endFn // CSS-driven animations cannot be cancelled, only ended
	          });

	          $$AnimateRunner.all(animationRunners, function(status) {
	            runner.complete(status);
	          });

	          return runner;

	          function endFn() {
	            forEach(animationRunners, function(runner) {
	              runner.end();
	            });
	          }
	        }
	      };
	    }

	    function prepareRegularAnimation(animationDetails) {
	      var element = animationDetails.element;
	      var options = animationDetails.options || {};

	      if (animationDetails.structural) {
	        options.event = animationDetails.event;
	        options.structural = true;
	        options.applyClassesEarly = true;

	        // we special case the leave animation since we want to ensure that
	        // the element is removed as soon as the animation is over. Otherwise
	        // a flicker might appear or the element may not be removed at all
	        if (animationDetails.event === 'leave') {
	          options.onDone = options.domOperation;
	        }
	      }

	      // We assign the preparationClasses as the actual animation event since
	      // the internals of $animateCss will just suffix the event token values
	      // with `-active` to trigger the animation.
	      if (options.preparationClasses) {
	        options.event = concatWithSpace(options.event, options.preparationClasses);
	      }

	      var animator = $animateCss(element, options);

	      // the driver lookup code inside of $$animation attempts to spawn a
	      // driver one by one until a driver returns a.$$willAnimate animator object.
	      // $animateCss will always return an object, however, it will pass in
	      // a flag as a hint as to whether an animation was detected or not
	      return animator.$$willAnimate ? animator : null;
	    }
	  }];
	}];

	// TODO(matsko): use caching here to speed things up for detection
	// TODO(matsko): add documentation
	//  by the time...

	var $$AnimateJsProvider = ['$animateProvider', function($animateProvider) {
	  this.$get = ['$injector', '$$AnimateRunner', '$$jqLite',
	       function($injector,   $$AnimateRunner,   $$jqLite) {

	    var applyAnimationClasses = applyAnimationClassesFactory($$jqLite);
	         // $animateJs(element, 'enter');
	    return function(element, event, classes, options) {
	      var animationClosed = false;

	      // the `classes` argument is optional and if it is not used
	      // then the classes will be resolved from the element's className
	      // property as well as options.addClass/options.removeClass.
	      if (arguments.length === 3 && isObject(classes)) {
	        options = classes;
	        classes = null;
	      }

	      options = prepareAnimationOptions(options);
	      if (!classes) {
	        classes = element.attr('class') || '';
	        if (options.addClass) {
	          classes += ' ' + options.addClass;
	        }
	        if (options.removeClass) {
	          classes += ' ' + options.removeClass;
	        }
	      }

	      var classesToAdd = options.addClass;
	      var classesToRemove = options.removeClass;

	      // the lookupAnimations function returns a series of animation objects that are
	      // matched up with one or more of the CSS classes. These animation objects are
	      // defined via the module.animation factory function. If nothing is detected then
	      // we don't return anything which then makes $animation query the next driver.
	      var animations = lookupAnimations(classes);
	      var before, after;
	      if (animations.length) {
	        var afterFn, beforeFn;
	        if (event == 'leave') {
	          beforeFn = 'leave';
	          afterFn = 'afterLeave'; // TODO(matsko): get rid of this
	        } else {
	          beforeFn = 'before' + event.charAt(0).toUpperCase() + event.substr(1);
	          afterFn = event;
	        }

	        if (event !== 'enter' && event !== 'move') {
	          before = packageAnimations(element, event, options, animations, beforeFn);
	        }
	        after  = packageAnimations(element, event, options, animations, afterFn);
	      }

	      // no matching animations
	      if (!before && !after) return;

	      function applyOptions() {
	        options.domOperation();
	        applyAnimationClasses(element, options);
	      }

	      function close() {
	        animationClosed = true;
	        applyOptions();
	        applyAnimationStyles(element, options);
	      }

	      var runner;

	      return {
	        $$willAnimate: true,
	        end: function() {
	          if (runner) {
	            runner.end();
	          } else {
	            close();
	            runner = new $$AnimateRunner();
	            runner.complete(true);
	          }
	          return runner;
	        },
	        start: function() {
	          if (runner) {
	            return runner;
	          }

	          runner = new $$AnimateRunner();
	          var closeActiveAnimations;
	          var chain = [];

	          if (before) {
	            chain.push(function(fn) {
	              closeActiveAnimations = before(fn);
	            });
	          }

	          if (chain.length) {
	            chain.push(function(fn) {
	              applyOptions();
	              fn(true);
	            });
	          } else {
	            applyOptions();
	          }

	          if (after) {
	            chain.push(function(fn) {
	              closeActiveAnimations = after(fn);
	            });
	          }

	          runner.setHost({
	            end: function() {
	              endAnimations();
	            },
	            cancel: function() {
	              endAnimations(true);
	            }
	          });

	          $$AnimateRunner.chain(chain, onComplete);
	          return runner;

	          function onComplete(success) {
	            close(success);
	            runner.complete(success);
	          }

	          function endAnimations(cancelled) {
	            if (!animationClosed) {
	              (closeActiveAnimations || noop)(cancelled);
	              onComplete(cancelled);
	            }
	          }
	        }
	      };

	      function executeAnimationFn(fn, element, event, options, onDone) {
	        var args;
	        switch (event) {
	          case 'animate':
	            args = [element, options.from, options.to, onDone];
	            break;

	          case 'setClass':
	            args = [element, classesToAdd, classesToRemove, onDone];
	            break;

	          case 'addClass':
	            args = [element, classesToAdd, onDone];
	            break;

	          case 'removeClass':
	            args = [element, classesToRemove, onDone];
	            break;

	          default:
	            args = [element, onDone];
	            break;
	        }

	        args.push(options);

	        var value = fn.apply(fn, args);
	        if (value) {
	          if (isFunction(value.start)) {
	            value = value.start();
	          }

	          if (value instanceof $$AnimateRunner) {
	            value.done(onDone);
	          } else if (isFunction(value)) {
	            // optional onEnd / onCancel callback
	            return value;
	          }
	        }

	        return noop;
	      }

	      function groupEventedAnimations(element, event, options, animations, fnName) {
	        var operations = [];
	        forEach(animations, function(ani) {
	          var animation = ani[fnName];
	          if (!animation) return;

	          // note that all of these animations will run in parallel
	          operations.push(function() {
	            var runner;
	            var endProgressCb;

	            var resolved = false;
	            var onAnimationComplete = function(rejected) {
	              if (!resolved) {
	                resolved = true;
	                (endProgressCb || noop)(rejected);
	                runner.complete(!rejected);
	              }
	            };

	            runner = new $$AnimateRunner({
	              end: function() {
	                onAnimationComplete();
	              },
	              cancel: function() {
	                onAnimationComplete(true);
	              }
	            });

	            endProgressCb = executeAnimationFn(animation, element, event, options, function(result) {
	              var cancelled = result === false;
	              onAnimationComplete(cancelled);
	            });

	            return runner;
	          });
	        });

	        return operations;
	      }

	      function packageAnimations(element, event, options, animations, fnName) {
	        var operations = groupEventedAnimations(element, event, options, animations, fnName);
	        if (operations.length === 0) {
	          var a,b;
	          if (fnName === 'beforeSetClass') {
	            a = groupEventedAnimations(element, 'removeClass', options, animations, 'beforeRemoveClass');
	            b = groupEventedAnimations(element, 'addClass', options, animations, 'beforeAddClass');
	          } else if (fnName === 'setClass') {
	            a = groupEventedAnimations(element, 'removeClass', options, animations, 'removeClass');
	            b = groupEventedAnimations(element, 'addClass', options, animations, 'addClass');
	          }

	          if (a) {
	            operations = operations.concat(a);
	          }
	          if (b) {
	            operations = operations.concat(b);
	          }
	        }

	        if (operations.length === 0) return;

	        // TODO(matsko): add documentation
	        return function startAnimation(callback) {
	          var runners = [];
	          if (operations.length) {
	            forEach(operations, function(animateFn) {
	              runners.push(animateFn());
	            });
	          }

	          runners.length ? $$AnimateRunner.all(runners, callback) : callback();

	          return function endFn(reject) {
	            forEach(runners, function(runner) {
	              reject ? runner.cancel() : runner.end();
	            });
	          };
	        };
	      }
	    };

	    function lookupAnimations(classes) {
	      classes = isArray(classes) ? classes : classes.split(' ');
	      var matches = [], flagMap = {};
	      for (var i=0; i < classes.length; i++) {
	        var klass = classes[i],
	            animationFactory = $animateProvider.$$registeredAnimations[klass];
	        if (animationFactory && !flagMap[klass]) {
	          matches.push($injector.get(animationFactory));
	          flagMap[klass] = true;
	        }
	      }
	      return matches;
	    }
	  }];
	}];

	var $$AnimateJsDriverProvider = ['$$animationProvider', function($$animationProvider) {
	  $$animationProvider.drivers.push('$$animateJsDriver');
	  this.$get = ['$$animateJs', '$$AnimateRunner', function($$animateJs, $$AnimateRunner) {
	    return function initDriverFn(animationDetails) {
	      if (animationDetails.from && animationDetails.to) {
	        var fromAnimation = prepareAnimation(animationDetails.from);
	        var toAnimation = prepareAnimation(animationDetails.to);
	        if (!fromAnimation && !toAnimation) return;

	        return {
	          start: function() {
	            var animationRunners = [];

	            if (fromAnimation) {
	              animationRunners.push(fromAnimation.start());
	            }

	            if (toAnimation) {
	              animationRunners.push(toAnimation.start());
	            }

	            $$AnimateRunner.all(animationRunners, done);

	            var runner = new $$AnimateRunner({
	              end: endFnFactory(),
	              cancel: endFnFactory()
	            });

	            return runner;

	            function endFnFactory() {
	              return function() {
	                forEach(animationRunners, function(runner) {
	                  // at this point we cannot cancel animations for groups just yet. 1.5+
	                  runner.end();
	                });
	              };
	            }

	            function done(status) {
	              runner.complete(status);
	            }
	          }
	        };
	      } else {
	        return prepareAnimation(animationDetails);
	      }
	    };

	    function prepareAnimation(animationDetails) {
	      // TODO(matsko): make sure to check for grouped animations and delegate down to normal animations
	      var element = animationDetails.element;
	      var event = animationDetails.event;
	      var options = animationDetails.options;
	      var classes = animationDetails.classes;
	      return $$animateJs(element, event, classes, options);
	    }
	  }];
	}];

	var NG_ANIMATE_ATTR_NAME = 'data-ng-animate';
	var NG_ANIMATE_PIN_DATA = '$ngAnimatePin';
	var $$AnimateQueueProvider = ['$animateProvider', function($animateProvider) {
	  var PRE_DIGEST_STATE = 1;
	  var RUNNING_STATE = 2;
	  var ONE_SPACE = ' ';

	  var rules = this.rules = {
	    skip: [],
	    cancel: [],
	    join: []
	  };

	  function makeTruthyCssClassMap(classString) {
	    if (!classString) {
	      return null;
	    }

	    var keys = classString.split(ONE_SPACE);
	    var map = Object.create(null);

	    forEach(keys, function(key) {
	      map[key] = true;
	    });
	    return map;
	  }

	  function hasMatchingClasses(newClassString, currentClassString) {
	    if (newClassString && currentClassString) {
	      var currentClassMap = makeTruthyCssClassMap(currentClassString);
	      return newClassString.split(ONE_SPACE).some(function(className) {
	        return currentClassMap[className];
	      });
	    }
	  }

	  function isAllowed(ruleType, element, currentAnimation, previousAnimation) {
	    return rules[ruleType].some(function(fn) {
	      return fn(element, currentAnimation, previousAnimation);
	    });
	  }

	  function hasAnimationClasses(animation, and) {
	    var a = (animation.addClass || '').length > 0;
	    var b = (animation.removeClass || '').length > 0;
	    return and ? a && b : a || b;
	  }

	  rules.join.push(function(element, newAnimation, currentAnimation) {
	    // if the new animation is class-based then we can just tack that on
	    return !newAnimation.structural && hasAnimationClasses(newAnimation);
	  });

	  rules.skip.push(function(element, newAnimation, currentAnimation) {
	    // there is no need to animate anything if no classes are being added and
	    // there is no structural animation that will be triggered
	    return !newAnimation.structural && !hasAnimationClasses(newAnimation);
	  });

	  rules.skip.push(function(element, newAnimation, currentAnimation) {
	    // why should we trigger a new structural animation if the element will
	    // be removed from the DOM anyway?
	    return currentAnimation.event == 'leave' && newAnimation.structural;
	  });

	  rules.skip.push(function(element, newAnimation, currentAnimation) {
	    // if there is an ongoing current animation then don't even bother running the class-based animation
	    return currentAnimation.structural && currentAnimation.state === RUNNING_STATE && !newAnimation.structural;
	  });

	  rules.cancel.push(function(element, newAnimation, currentAnimation) {
	    // there can never be two structural animations running at the same time
	    return currentAnimation.structural && newAnimation.structural;
	  });

	  rules.cancel.push(function(element, newAnimation, currentAnimation) {
	    // if the previous animation is already running, but the new animation will
	    // be triggered, but the new animation is structural
	    return currentAnimation.state === RUNNING_STATE && newAnimation.structural;
	  });

	  rules.cancel.push(function(element, newAnimation, currentAnimation) {
	    // cancel the animation if classes added / removed in both animation cancel each other out,
	    // but only if the current animation isn't structural

	    if (currentAnimation.structural) return false;

	    var nA = newAnimation.addClass;
	    var nR = newAnimation.removeClass;
	    var cA = currentAnimation.addClass;
	    var cR = currentAnimation.removeClass;

	    // early detection to save the global CPU shortage :)
	    if ((isUndefined(nA) && isUndefined(nR)) || (isUndefined(cA) && isUndefined(cR))) {
	      return false;
	    }

	    return hasMatchingClasses(nA, cR) || hasMatchingClasses(nR, cA);
	  });

	  this.$get = ['$$rAF', '$rootScope', '$rootElement', '$document', '$$HashMap',
	               '$$animation', '$$AnimateRunner', '$templateRequest', '$$jqLite', '$$forceReflow',
	       function($$rAF,   $rootScope,   $rootElement,   $document,   $$HashMap,
	                $$animation,   $$AnimateRunner,   $templateRequest,   $$jqLite,   $$forceReflow) {

	    var activeAnimationsLookup = new $$HashMap();
	    var disabledElementsLookup = new $$HashMap();
	    var animationsEnabled = null;

	    function postDigestTaskFactory() {
	      var postDigestCalled = false;
	      return function(fn) {
	        // we only issue a call to postDigest before
	        // it has first passed. This prevents any callbacks
	        // from not firing once the animation has completed
	        // since it will be out of the digest cycle.
	        if (postDigestCalled) {
	          fn();
	        } else {
	          $rootScope.$$postDigest(function() {
	            postDigestCalled = true;
	            fn();
	          });
	        }
	      };
	    }

	    // Wait until all directive and route-related templates are downloaded and
	    // compiled. The $templateRequest.totalPendingRequests variable keeps track of
	    // all of the remote templates being currently downloaded. If there are no
	    // templates currently downloading then the watcher will still fire anyway.
	    var deregisterWatch = $rootScope.$watch(
	      function() { return $templateRequest.totalPendingRequests === 0; },
	      function(isEmpty) {
	        if (!isEmpty) return;
	        deregisterWatch();

	        // Now that all templates have been downloaded, $animate will wait until
	        // the post digest queue is empty before enabling animations. By having two
	        // calls to $postDigest calls we can ensure that the flag is enabled at the
	        // very end of the post digest queue. Since all of the animations in $animate
	        // use $postDigest, it's important that the code below executes at the end.
	        // This basically means that the page is fully downloaded and compiled before
	        // any animations are triggered.
	        $rootScope.$$postDigest(function() {
	          $rootScope.$$postDigest(function() {
	            // we check for null directly in the event that the application already called
	            // .enabled() with whatever arguments that it provided it with
	            if (animationsEnabled === null) {
	              animationsEnabled = true;
	            }
	          });
	        });
	      }
	    );

	    var callbackRegistry = {};

	    // remember that the classNameFilter is set during the provider/config
	    // stage therefore we can optimize here and setup a helper function
	    var classNameFilter = $animateProvider.classNameFilter();
	    var isAnimatableClassName = !classNameFilter
	              ? function() { return true; }
	              : function(className) {
	                return classNameFilter.test(className);
	              };

	    var applyAnimationClasses = applyAnimationClassesFactory($$jqLite);

	    function normalizeAnimationDetails(element, animation) {
	      return mergeAnimationDetails(element, animation, {});
	    }

	    // IE9-11 has no method "contains" in SVG element and in Node.prototype. Bug #10259.
	    var contains = Node.prototype.contains || function(arg) {
	      // jshint bitwise: false
	      return this === arg || !!(this.compareDocumentPosition(arg) & 16);
	      // jshint bitwise: true
	    };

	    function findCallbacks(parent, element, event) {
	      var targetNode = getDomNode(element);
	      var targetParentNode = getDomNode(parent);

	      var matches = [];
	      var entries = callbackRegistry[event];
	      if (entries) {
	        forEach(entries, function(entry) {
	          if (contains.call(entry.node, targetNode)) {
	            matches.push(entry.callback);
	          } else if (event === 'leave' && contains.call(entry.node, targetParentNode)) {
	            matches.push(entry.callback);
	          }
	        });
	      }

	      return matches;
	    }

	    var $animate = {
	      on: function(event, container, callback) {
	        var node = extractElementNode(container);
	        callbackRegistry[event] = callbackRegistry[event] || [];
	        callbackRegistry[event].push({
	          node: node,
	          callback: callback
	        });

	        // Remove the callback when the element is removed from the DOM
	        jqLite(container).on('$destroy', function() {
	          $animate.off(event, container, callback);
	        });
	      },

	      off: function(event, container, callback) {
	        var entries = callbackRegistry[event];
	        if (!entries) return;

	        callbackRegistry[event] = arguments.length === 1
	            ? null
	            : filterFromRegistry(entries, container, callback);

	        function filterFromRegistry(list, matchContainer, matchCallback) {
	          var containerNode = extractElementNode(matchContainer);
	          return list.filter(function(entry) {
	            var isMatch = entry.node === containerNode &&
	                            (!matchCallback || entry.callback === matchCallback);
	            return !isMatch;
	          });
	        }
	      },

	      pin: function(element, parentElement) {
	        assertArg(isElement(element), 'element', 'not an element');
	        assertArg(isElement(parentElement), 'parentElement', 'not an element');
	        element.data(NG_ANIMATE_PIN_DATA, parentElement);
	      },

	      push: function(element, event, options, domOperation) {
	        options = options || {};
	        options.domOperation = domOperation;
	        return queueAnimation(element, event, options);
	      },

	      // this method has four signatures:
	      //  () - global getter
	      //  (bool) - global setter
	      //  (element) - element getter
	      //  (element, bool) - element setter<F37>
	      enabled: function(element, bool) {
	        var argCount = arguments.length;

	        if (argCount === 0) {
	          // () - Global getter
	          bool = !!animationsEnabled;
	        } else {
	          var hasElement = isElement(element);

	          if (!hasElement) {
	            // (bool) - Global setter
	            bool = animationsEnabled = !!element;
	          } else {
	            var node = getDomNode(element);
	            var recordExists = disabledElementsLookup.get(node);

	            if (argCount === 1) {
	              // (element) - Element getter
	              bool = !recordExists;
	            } else {
	              // (element, bool) - Element setter
	              disabledElementsLookup.put(node, !bool);
	            }
	          }
	        }

	        return bool;
	      }
	    };

	    return $animate;

	    function queueAnimation(element, event, initialOptions) {
	      // we always make a copy of the options since
	      // there should never be any side effects on
	      // the input data when running `$animateCss`.
	      var options = copy(initialOptions);

	      var node, parent;
	      element = stripCommentsFromElement(element);
	      if (element) {
	        node = getDomNode(element);
	        parent = element.parent();
	      }

	      options = prepareAnimationOptions(options);

	      // we create a fake runner with a working promise.
	      // These methods will become available after the digest has passed
	      var runner = new $$AnimateRunner();

	      // this is used to trigger callbacks in postDigest mode
	      var runInNextPostDigestOrNow = postDigestTaskFactory();

	      if (isArray(options.addClass)) {
	        options.addClass = options.addClass.join(' ');
	      }

	      if (options.addClass && !isString(options.addClass)) {
	        options.addClass = null;
	      }

	      if (isArray(options.removeClass)) {
	        options.removeClass = options.removeClass.join(' ');
	      }

	      if (options.removeClass && !isString(options.removeClass)) {
	        options.removeClass = null;
	      }

	      if (options.from && !isObject(options.from)) {
	        options.from = null;
	      }

	      if (options.to && !isObject(options.to)) {
	        options.to = null;
	      }

	      // there are situations where a directive issues an animation for
	      // a jqLite wrapper that contains only comment nodes... If this
	      // happens then there is no way we can perform an animation
	      if (!node) {
	        close();
	        return runner;
	      }

	      var className = [node.className, options.addClass, options.removeClass].join(' ');
	      if (!isAnimatableClassName(className)) {
	        close();
	        return runner;
	      }

	      var isStructural = ['enter', 'move', 'leave'].indexOf(event) >= 0;

	      // this is a hard disable of all animations for the application or on
	      // the element itself, therefore  there is no need to continue further
	      // past this point if not enabled
	      // Animations are also disabled if the document is currently hidden (page is not visible
	      // to the user), because browsers slow down or do not flush calls to requestAnimationFrame
	      var skipAnimations = !animationsEnabled || $document[0].hidden || disabledElementsLookup.get(node);
	      var existingAnimation = (!skipAnimations && activeAnimationsLookup.get(node)) || {};
	      var hasExistingAnimation = !!existingAnimation.state;

	      // there is no point in traversing the same collection of parent ancestors if a followup
	      // animation will be run on the same element that already did all that checking work
	      if (!skipAnimations && (!hasExistingAnimation || existingAnimation.state != PRE_DIGEST_STATE)) {
	        skipAnimations = !areAnimationsAllowed(element, parent, event);
	      }

	      if (skipAnimations) {
	        close();
	        return runner;
	      }

	      if (isStructural) {
	        closeChildAnimations(element);
	      }

	      var newAnimation = {
	        structural: isStructural,
	        element: element,
	        event: event,
	        addClass: options.addClass,
	        removeClass: options.removeClass,
	        close: close,
	        options: options,
	        runner: runner
	      };

	      if (hasExistingAnimation) {
	        var skipAnimationFlag = isAllowed('skip', element, newAnimation, existingAnimation);
	        if (skipAnimationFlag) {
	          if (existingAnimation.state === RUNNING_STATE) {
	            close();
	            return runner;
	          } else {
	            mergeAnimationDetails(element, existingAnimation, newAnimation);
	            return existingAnimation.runner;
	          }
	        }
	        var cancelAnimationFlag = isAllowed('cancel', element, newAnimation, existingAnimation);
	        if (cancelAnimationFlag) {
	          if (existingAnimation.state === RUNNING_STATE) {
	            // this will end the animation right away and it is safe
	            // to do so since the animation is already running and the
	            // runner callback code will run in async
	            existingAnimation.runner.end();
	          } else if (existingAnimation.structural) {
	            // this means that the animation is queued into a digest, but
	            // hasn't started yet. Therefore it is safe to run the close
	            // method which will call the runner methods in async.
	            existingAnimation.close();
	          } else {
	            // this will merge the new animation options into existing animation options
	            mergeAnimationDetails(element, existingAnimation, newAnimation);

	            return existingAnimation.runner;
	          }
	        } else {
	          // a joined animation means that this animation will take over the existing one
	          // so an example would involve a leave animation taking over an enter. Then when
	          // the postDigest kicks in the enter will be ignored.
	          var joinAnimationFlag = isAllowed('join', element, newAnimation, existingAnimation);
	          if (joinAnimationFlag) {
	            if (existingAnimation.state === RUNNING_STATE) {
	              normalizeAnimationDetails(element, newAnimation);
	            } else {
	              applyGeneratedPreparationClasses(element, isStructural ? event : null, options);

	              event = newAnimation.event = existingAnimation.event;
	              options = mergeAnimationDetails(element, existingAnimation, newAnimation);

	              //we return the same runner since only the option values of this animation will
	              //be fed into the `existingAnimation`.
	              return existingAnimation.runner;
	            }
	          }
	        }
	      } else {
	        // normalization in this case means that it removes redundant CSS classes that
	        // already exist (addClass) or do not exist (removeClass) on the element
	        normalizeAnimationDetails(element, newAnimation);
	      }

	      // when the options are merged and cleaned up we may end up not having to do
	      // an animation at all, therefore we should check this before issuing a post
	      // digest callback. Structural animations will always run no matter what.
	      var isValidAnimation = newAnimation.structural;
	      if (!isValidAnimation) {
	        // animate (from/to) can be quickly checked first, otherwise we check if any classes are present
	        isValidAnimation = (newAnimation.event === 'animate' && Object.keys(newAnimation.options.to || {}).length > 0)
	                            || hasAnimationClasses(newAnimation);
	      }

	      if (!isValidAnimation) {
	        close();
	        clearElementAnimationState(element);
	        return runner;
	      }

	      // the counter keeps track of cancelled animations
	      var counter = (existingAnimation.counter || 0) + 1;
	      newAnimation.counter = counter;

	      markElementAnimationState(element, PRE_DIGEST_STATE, newAnimation);

	      $rootScope.$$postDigest(function() {
	        var animationDetails = activeAnimationsLookup.get(node);
	        var animationCancelled = !animationDetails;
	        animationDetails = animationDetails || {};

	        // if addClass/removeClass is called before something like enter then the
	        // registered parent element may not be present. The code below will ensure
	        // that a final value for parent element is obtained
	        var parentElement = element.parent() || [];

	        // animate/structural/class-based animations all have requirements. Otherwise there
	        // is no point in performing an animation. The parent node must also be set.
	        var isValidAnimation = parentElement.length > 0
	                                && (animationDetails.event === 'animate'
	                                    || animationDetails.structural
	                                    || hasAnimationClasses(animationDetails));

	        // this means that the previous animation was cancelled
	        // even if the follow-up animation is the same event
	        if (animationCancelled || animationDetails.counter !== counter || !isValidAnimation) {
	          // if another animation did not take over then we need
	          // to make sure that the domOperation and options are
	          // handled accordingly
	          if (animationCancelled) {
	            applyAnimationClasses(element, options);
	            applyAnimationStyles(element, options);
	          }

	          // if the event changed from something like enter to leave then we do
	          // it, otherwise if it's the same then the end result will be the same too
	          if (animationCancelled || (isStructural && animationDetails.event !== event)) {
	            options.domOperation();
	            runner.end();
	          }

	          // in the event that the element animation was not cancelled or a follow-up animation
	          // isn't allowed to animate from here then we need to clear the state of the element
	          // so that any future animations won't read the expired animation data.
	          if (!isValidAnimation) {
	            clearElementAnimationState(element);
	          }

	          return;
	        }

	        // this combined multiple class to addClass / removeClass into a setClass event
	        // so long as a structural event did not take over the animation
	        event = !animationDetails.structural && hasAnimationClasses(animationDetails, true)
	            ? 'setClass'
	            : animationDetails.event;

	        markElementAnimationState(element, RUNNING_STATE);
	        var realRunner = $$animation(element, event, animationDetails.options);

	        realRunner.done(function(status) {
	          close(!status);
	          var animationDetails = activeAnimationsLookup.get(node);
	          if (animationDetails && animationDetails.counter === counter) {
	            clearElementAnimationState(getDomNode(element));
	          }
	          notifyProgress(runner, event, 'close', {});
	        });

	        // this will update the runner's flow-control events based on
	        // the `realRunner` object.
	        runner.setHost(realRunner);
	        notifyProgress(runner, event, 'start', {});
	      });

	      return runner;

	      function notifyProgress(runner, event, phase, data) {
	        runInNextPostDigestOrNow(function() {
	          var callbacks = findCallbacks(parent, element, event);
	          if (callbacks.length) {
	            // do not optimize this call here to RAF because
	            // we don't know how heavy the callback code here will
	            // be and if this code is buffered then this can
	            // lead to a performance regression.
	            $$rAF(function() {
	              forEach(callbacks, function(callback) {
	                callback(element, phase, data);
	              });
	            });
	          }
	        });
	        runner.progress(event, phase, data);
	      }

	      function close(reject) { // jshint ignore:line
	        clearGeneratedClasses(element, options);
	        applyAnimationClasses(element, options);
	        applyAnimationStyles(element, options);
	        options.domOperation();
	        runner.complete(!reject);
	      }
	    }

	    function closeChildAnimations(element) {
	      var node = getDomNode(element);
	      var children = node.querySelectorAll('[' + NG_ANIMATE_ATTR_NAME + ']');
	      forEach(children, function(child) {
	        var state = parseInt(child.getAttribute(NG_ANIMATE_ATTR_NAME));
	        var animationDetails = activeAnimationsLookup.get(child);
	        if (animationDetails) {
	          switch (state) {
	            case RUNNING_STATE:
	              animationDetails.runner.end();
	              /* falls through */
	            case PRE_DIGEST_STATE:
	              activeAnimationsLookup.remove(child);
	              break;
	          }
	        }
	      });
	    }

	    function clearElementAnimationState(element) {
	      var node = getDomNode(element);
	      node.removeAttribute(NG_ANIMATE_ATTR_NAME);
	      activeAnimationsLookup.remove(node);
	    }

	    function isMatchingElement(nodeOrElmA, nodeOrElmB) {
	      return getDomNode(nodeOrElmA) === getDomNode(nodeOrElmB);
	    }

	    /**
	     * This fn returns false if any of the following is true:
	     * a) animations on any parent element are disabled, and animations on the element aren't explicitly allowed
	     * b) a parent element has an ongoing structural animation, and animateChildren is false
	     * c) the element is not a child of the body
	     * d) the element is not a child of the $rootElement
	     */
	    function areAnimationsAllowed(element, parentElement, event) {
	      var bodyElement = jqLite($document[0].body);
	      var bodyElementDetected = isMatchingElement(element, bodyElement) || element[0].nodeName === 'HTML';
	      var rootElementDetected = isMatchingElement(element, $rootElement);
	      var parentAnimationDetected = false;
	      var animateChildren;
	      var elementDisabled = disabledElementsLookup.get(getDomNode(element));

	      var parentHost = jqLite.data(element[0], NG_ANIMATE_PIN_DATA);
	      if (parentHost) {
	        parentElement = parentHost;
	      }

	      parentElement = getDomNode(parentElement);

	      while (parentElement) {
	        if (!rootElementDetected) {
	          // angular doesn't want to attempt to animate elements outside of the application
	          // therefore we need to ensure that the rootElement is an ancestor of the current element
	          rootElementDetected = isMatchingElement(parentElement, $rootElement);
	        }

	        if (parentElement.nodeType !== ELEMENT_NODE) {
	          // no point in inspecting the #document element
	          break;
	        }

	        var details = activeAnimationsLookup.get(parentElement) || {};
	        // either an enter, leave or move animation will commence
	        // therefore we can't allow any animations to take place
	        // but if a parent animation is class-based then that's ok
	        if (!parentAnimationDetected) {
	          var parentElementDisabled = disabledElementsLookup.get(parentElement);

	          if (parentElementDisabled === true && elementDisabled !== false) {
	            // disable animations if the user hasn't explicitly enabled animations on the
	            // current element
	            elementDisabled = true;
	            // element is disabled via parent element, no need to check anything else
	            break;
	          } else if (parentElementDisabled === false) {
	            elementDisabled = false;
	          }
	          parentAnimationDetected = details.structural;
	        }

	        if (isUndefined(animateChildren) || animateChildren === true) {
	          var value = jqLite.data(parentElement, NG_ANIMATE_CHILDREN_DATA);
	          if (isDefined(value)) {
	            animateChildren = value;
	          }
	        }

	        // there is no need to continue traversing at this point
	        if (parentAnimationDetected && animateChildren === false) break;

	        if (!bodyElementDetected) {
	          // we also need to ensure that the element is or will be a part of the body element
	          // otherwise it is pointless to even issue an animation to be rendered
	          bodyElementDetected = isMatchingElement(parentElement, bodyElement);
	        }

	        if (bodyElementDetected && rootElementDetected) {
	          // If both body and root have been found, any other checks are pointless,
	          // as no animation data should live outside the application
	          break;
	        }

	        if (!rootElementDetected) {
	          // If no rootElement is detected, check if the parentElement is pinned to another element
	          parentHost = jqLite.data(parentElement, NG_ANIMATE_PIN_DATA);
	          if (parentHost) {
	            // The pin target element becomes the next parent element
	            parentElement = getDomNode(parentHost);
	            continue;
	          }
	        }

	        parentElement = parentElement.parentNode;
	      }

	      var allowAnimation = (!parentAnimationDetected || animateChildren) && elementDisabled !== true;
	      return allowAnimation && rootElementDetected && bodyElementDetected;
	    }

	    function markElementAnimationState(element, state, details) {
	      details = details || {};
	      details.state = state;

	      var node = getDomNode(element);
	      node.setAttribute(NG_ANIMATE_ATTR_NAME, state);

	      var oldValue = activeAnimationsLookup.get(node);
	      var newValue = oldValue
	          ? extend(oldValue, details)
	          : details;
	      activeAnimationsLookup.put(node, newValue);
	    }
	  }];
	}];

	var $$AnimationProvider = ['$animateProvider', function($animateProvider) {
	  var NG_ANIMATE_REF_ATTR = 'ng-animate-ref';

	  var drivers = this.drivers = [];

	  var RUNNER_STORAGE_KEY = '$$animationRunner';

	  function setRunner(element, runner) {
	    element.data(RUNNER_STORAGE_KEY, runner);
	  }

	  function removeRunner(element) {
	    element.removeData(RUNNER_STORAGE_KEY);
	  }

	  function getRunner(element) {
	    return element.data(RUNNER_STORAGE_KEY);
	  }

	  this.$get = ['$$jqLite', '$rootScope', '$injector', '$$AnimateRunner', '$$HashMap', '$$rAFScheduler',
	       function($$jqLite,   $rootScope,   $injector,   $$AnimateRunner,   $$HashMap,   $$rAFScheduler) {

	    var animationQueue = [];
	    var applyAnimationClasses = applyAnimationClassesFactory($$jqLite);

	    function sortAnimations(animations) {
	      var tree = { children: [] };
	      var i, lookup = new $$HashMap();

	      // this is done first beforehand so that the hashmap
	      // is filled with a list of the elements that will be animated
	      for (i = 0; i < animations.length; i++) {
	        var animation = animations[i];
	        lookup.put(animation.domNode, animations[i] = {
	          domNode: animation.domNode,
	          fn: animation.fn,
	          children: []
	        });
	      }

	      for (i = 0; i < animations.length; i++) {
	        processNode(animations[i]);
	      }

	      return flatten(tree);

	      function processNode(entry) {
	        if (entry.processed) return entry;
	        entry.processed = true;

	        var elementNode = entry.domNode;
	        var parentNode = elementNode.parentNode;
	        lookup.put(elementNode, entry);

	        var parentEntry;
	        while (parentNode) {
	          parentEntry = lookup.get(parentNode);
	          if (parentEntry) {
	            if (!parentEntry.processed) {
	              parentEntry = processNode(parentEntry);
	            }
	            break;
	          }
	          parentNode = parentNode.parentNode;
	        }

	        (parentEntry || tree).children.push(entry);
	        return entry;
	      }

	      function flatten(tree) {
	        var result = [];
	        var queue = [];
	        var i;

	        for (i = 0; i < tree.children.length; i++) {
	          queue.push(tree.children[i]);
	        }

	        var remainingLevelEntries = queue.length;
	        var nextLevelEntries = 0;
	        var row = [];

	        for (i = 0; i < queue.length; i++) {
	          var entry = queue[i];
	          if (remainingLevelEntries <= 0) {
	            remainingLevelEntries = nextLevelEntries;
	            nextLevelEntries = 0;
	            result.push(row);
	            row = [];
	          }
	          row.push(entry.fn);
	          entry.children.forEach(function(childEntry) {
	            nextLevelEntries++;
	            queue.push(childEntry);
	          });
	          remainingLevelEntries--;
	        }

	        if (row.length) {
	          result.push(row);
	        }

	        return result;
	      }
	    }

	    // TODO(matsko): document the signature in a better way
	    return function(element, event, options) {
	      options = prepareAnimationOptions(options);
	      var isStructural = ['enter', 'move', 'leave'].indexOf(event) >= 0;

	      // there is no animation at the current moment, however
	      // these runner methods will get later updated with the
	      // methods leading into the driver's end/cancel methods
	      // for now they just stop the animation from starting
	      var runner = new $$AnimateRunner({
	        end: function() { close(); },
	        cancel: function() { close(true); }
	      });

	      if (!drivers.length) {
	        close();
	        return runner;
	      }

	      setRunner(element, runner);

	      var classes = mergeClasses(element.attr('class'), mergeClasses(options.addClass, options.removeClass));
	      var tempClasses = options.tempClasses;
	      if (tempClasses) {
	        classes += ' ' + tempClasses;
	        options.tempClasses = null;
	      }

	      var prepareClassName;
	      if (isStructural) {
	        prepareClassName = 'ng-' + event + PREPARE_CLASS_SUFFIX;
	        $$jqLite.addClass(element, prepareClassName);
	      }

	      animationQueue.push({
	        // this data is used by the postDigest code and passed into
	        // the driver step function
	        element: element,
	        classes: classes,
	        event: event,
	        structural: isStructural,
	        options: options,
	        beforeStart: beforeStart,
	        close: close
	      });

	      element.on('$destroy', handleDestroyedElement);

	      // we only want there to be one function called within the post digest
	      // block. This way we can group animations for all the animations that
	      // were apart of the same postDigest flush call.
	      if (animationQueue.length > 1) return runner;

	      $rootScope.$$postDigest(function() {
	        var animations = [];
	        forEach(animationQueue, function(entry) {
	          // the element was destroyed early on which removed the runner
	          // form its storage. This means we can't animate this element
	          // at all and it already has been closed due to destruction.
	          if (getRunner(entry.element)) {
	            animations.push(entry);
	          } else {
	            entry.close();
	          }
	        });

	        // now any future animations will be in another postDigest
	        animationQueue.length = 0;

	        var groupedAnimations = groupAnimations(animations);
	        var toBeSortedAnimations = [];

	        forEach(groupedAnimations, function(animationEntry) {
	          toBeSortedAnimations.push({
	            domNode: getDomNode(animationEntry.from ? animationEntry.from.element : animationEntry.element),
	            fn: function triggerAnimationStart() {
	              // it's important that we apply the `ng-animate` CSS class and the
	              // temporary classes before we do any driver invoking since these
	              // CSS classes may be required for proper CSS detection.
	              animationEntry.beforeStart();

	              var startAnimationFn, closeFn = animationEntry.close;

	              // in the event that the element was removed before the digest runs or
	              // during the RAF sequencing then we should not trigger the animation.
	              var targetElement = animationEntry.anchors
	                  ? (animationEntry.from.element || animationEntry.to.element)
	                  : animationEntry.element;

	              if (getRunner(targetElement)) {
	                var operation = invokeFirstDriver(animationEntry);
	                if (operation) {
	                  startAnimationFn = operation.start;
	                }
	              }

	              if (!startAnimationFn) {
	                closeFn();
	              } else {
	                var animationRunner = startAnimationFn();
	                animationRunner.done(function(status) {
	                  closeFn(!status);
	                });
	                updateAnimationRunners(animationEntry, animationRunner);
	              }
	            }
	          });
	        });

	        // we need to sort each of the animations in order of parent to child
	        // relationships. This ensures that the child classes are applied at the
	        // right time.
	        $$rAFScheduler(sortAnimations(toBeSortedAnimations));
	      });

	      return runner;

	      // TODO(matsko): change to reference nodes
	      function getAnchorNodes(node) {
	        var SELECTOR = '[' + NG_ANIMATE_REF_ATTR + ']';
	        var items = node.hasAttribute(NG_ANIMATE_REF_ATTR)
	              ? [node]
	              : node.querySelectorAll(SELECTOR);
	        var anchors = [];
	        forEach(items, function(node) {
	          var attr = node.getAttribute(NG_ANIMATE_REF_ATTR);
	          if (attr && attr.length) {
	            anchors.push(node);
	          }
	        });
	        return anchors;
	      }

	      function groupAnimations(animations) {
	        var preparedAnimations = [];
	        var refLookup = {};
	        forEach(animations, function(animation, index) {
	          var element = animation.element;
	          var node = getDomNode(element);
	          var event = animation.event;
	          var enterOrMove = ['enter', 'move'].indexOf(event) >= 0;
	          var anchorNodes = animation.structural ? getAnchorNodes(node) : [];

	          if (anchorNodes.length) {
	            var direction = enterOrMove ? 'to' : 'from';

	            forEach(anchorNodes, function(anchor) {
	              var key = anchor.getAttribute(NG_ANIMATE_REF_ATTR);
	              refLookup[key] = refLookup[key] || {};
	              refLookup[key][direction] = {
	                animationID: index,
	                element: jqLite(anchor)
	              };
	            });
	          } else {
	            preparedAnimations.push(animation);
	          }
	        });

	        var usedIndicesLookup = {};
	        var anchorGroups = {};
	        forEach(refLookup, function(operations, key) {
	          var from = operations.from;
	          var to = operations.to;

	          if (!from || !to) {
	            // only one of these is set therefore we can't have an
	            // anchor animation since all three pieces are required
	            var index = from ? from.animationID : to.animationID;
	            var indexKey = index.toString();
	            if (!usedIndicesLookup[indexKey]) {
	              usedIndicesLookup[indexKey] = true;
	              preparedAnimations.push(animations[index]);
	            }
	            return;
	          }

	          var fromAnimation = animations[from.animationID];
	          var toAnimation = animations[to.animationID];
	          var lookupKey = from.animationID.toString();
	          if (!anchorGroups[lookupKey]) {
	            var group = anchorGroups[lookupKey] = {
	              structural: true,
	              beforeStart: function() {
	                fromAnimation.beforeStart();
	                toAnimation.beforeStart();
	              },
	              close: function() {
	                fromAnimation.close();
	                toAnimation.close();
	              },
	              classes: cssClassesIntersection(fromAnimation.classes, toAnimation.classes),
	              from: fromAnimation,
	              to: toAnimation,
	              anchors: [] // TODO(matsko): change to reference nodes
	            };

	            // the anchor animations require that the from and to elements both have at least
	            // one shared CSS class which effectively marries the two elements together to use
	            // the same animation driver and to properly sequence the anchor animation.
	            if (group.classes.length) {
	              preparedAnimations.push(group);
	            } else {
	              preparedAnimations.push(fromAnimation);
	              preparedAnimations.push(toAnimation);
	            }
	          }

	          anchorGroups[lookupKey].anchors.push({
	            'out': from.element, 'in': to.element
	          });
	        });

	        return preparedAnimations;
	      }

	      function cssClassesIntersection(a,b) {
	        a = a.split(' ');
	        b = b.split(' ');
	        var matches = [];

	        for (var i = 0; i < a.length; i++) {
	          var aa = a[i];
	          if (aa.substring(0,3) === 'ng-') continue;

	          for (var j = 0; j < b.length; j++) {
	            if (aa === b[j]) {
	              matches.push(aa);
	              break;
	            }
	          }
	        }

	        return matches.join(' ');
	      }

	      function invokeFirstDriver(animationDetails) {
	        // we loop in reverse order since the more general drivers (like CSS and JS)
	        // may attempt more elements, but custom drivers are more particular
	        for (var i = drivers.length - 1; i >= 0; i--) {
	          var driverName = drivers[i];
	          if (!$injector.has(driverName)) continue; // TODO(matsko): remove this check

	          var factory = $injector.get(driverName);
	          var driver = factory(animationDetails);
	          if (driver) {
	            return driver;
	          }
	        }
	      }

	      function beforeStart() {
	        element.addClass(NG_ANIMATE_CLASSNAME);
	        if (tempClasses) {
	          $$jqLite.addClass(element, tempClasses);
	        }
	        if (prepareClassName) {
	          $$jqLite.removeClass(element, prepareClassName);
	          prepareClassName = null;
	        }
	      }

	      function updateAnimationRunners(animation, newRunner) {
	        if (animation.from && animation.to) {
	          update(animation.from.element);
	          update(animation.to.element);
	        } else {
	          update(animation.element);
	        }

	        function update(element) {
	          getRunner(element).setHost(newRunner);
	        }
	      }

	      function handleDestroyedElement() {
	        var runner = getRunner(element);
	        if (runner && (event !== 'leave' || !options.$$domOperationFired)) {
	          runner.end();
	        }
	      }

	      function close(rejected) { // jshint ignore:line
	        element.off('$destroy', handleDestroyedElement);
	        removeRunner(element);

	        applyAnimationClasses(element, options);
	        applyAnimationStyles(element, options);
	        options.domOperation();

	        if (tempClasses) {
	          $$jqLite.removeClass(element, tempClasses);
	        }

	        element.removeClass(NG_ANIMATE_CLASSNAME);
	        runner.complete(!rejected);
	      }
	    };
	  }];
	}];

	/**
	 * @ngdoc directive
	 * @name ngAnimateSwap
	 * @restrict A
	 * @scope
	 *
	 * @description
	 *
	 * ngAnimateSwap is a animation-oriented directive that allows for the container to
	 * be removed and entered in whenever the associated expression changes. A
	 * common usecase for this directive is a rotating banner or slider component which
	 * contains one image being present at a time. When the active image changes
	 * then the old image will perform a `leave` animation and the new element
	 * will be inserted via an `enter` animation.
	 *
	 * @animations
	 * | Animation                        | Occurs                               |
	 * |----------------------------------|--------------------------------------|
	 * | {@link ng.$animate#enter enter}  | when the new element is inserted to the DOM  |
	 * | {@link ng.$animate#leave leave}  | when the old element is removed from the DOM |
	 *
	 * @example
	 * <example name="ngAnimateSwap-directive" module="ngAnimateSwapExample"
	 *          deps="angular-animate.js"
	 *          animations="true" fixBase="true">
	 *   <file name="index.html">
	 *     <div class="container" ng-controller="AppCtrl">
	 *       <div ng-animate-swap="number" class="cell swap-animation" ng-class="colorClass(number)">
	 *         {{ number }}
	 *       </div>
	 *     </div>
	 *   </file>
	 *   <file name="script.js">
	 *     angular.module('ngAnimateSwapExample', ['ngAnimate'])
	 *       .controller('AppCtrl', ['$scope', '$interval', function($scope, $interval) {
	 *         $scope.number = 0;
	 *         $interval(function() {
	 *           $scope.number++;
	 *         }, 1000);
	 *
	 *         var colors = ['red','blue','green','yellow','orange'];
	 *         $scope.colorClass = function(number) {
	 *           return colors[number % colors.length];
	 *         };
	 *       }]);
	 *   </file>
	 *  <file name="animations.css">
	 *  .container {
	 *    height:250px;
	 *    width:250px;
	 *    position:relative;
	 *    overflow:hidden;
	 *    border:2px solid black;
	 *  }
	 *  .container .cell {
	 *    font-size:150px;
	 *    text-align:center;
	 *    line-height:250px;
	 *    position:absolute;
	 *    top:0;
	 *    left:0;
	 *    right:0;
	 *    border-bottom:2px solid black;
	 *  }
	 *  .swap-animation.ng-enter, .swap-animation.ng-leave {
	 *    transition:0.5s linear all;
	 *  }
	 *  .swap-animation.ng-enter {
	 *    top:-250px;
	 *  }
	 *  .swap-animation.ng-enter-active {
	 *    top:0px;
	 *  }
	 *  .swap-animation.ng-leave {
	 *    top:0px;
	 *  }
	 *  .swap-animation.ng-leave-active {
	 *    top:250px;
	 *  }
	 *  .red { background:red; }
	 *  .green { background:green; }
	 *  .blue { background:blue; }
	 *  .yellow { background:yellow; }
	 *  .orange { background:orange; }
	 *  </file>
	 * </example>
	 */
	var ngAnimateSwapDirective = ['$animate', '$rootScope', function($animate, $rootScope) {
	  return {
	    restrict: 'A',
	    transclude: 'element',
	    terminal: true,
	    priority: 600, // we use 600 here to ensure that the directive is caught before others
	    link: function(scope, $element, attrs, ctrl, $transclude) {
	      var previousElement, previousScope;
	      scope.$watchCollection(attrs.ngAnimateSwap || attrs['for'], function(value) {
	        if (previousElement) {
	          $animate.leave(previousElement);
	        }
	        if (previousScope) {
	          previousScope.$destroy();
	          previousScope = null;
	        }
	        if (value || value === 0) {
	          previousScope = scope.$new();
	          $transclude(previousScope, function(element) {
	            previousElement = element;
	            $animate.enter(element, null, $element);
	          });
	        }
	      });
	    }
	  };
	}];

	/* global angularAnimateModule: true,

	   ngAnimateSwapDirective,
	   $$AnimateAsyncRunFactory,
	   $$rAFSchedulerFactory,
	   $$AnimateChildrenDirective,
	   $$AnimateQueueProvider,
	   $$AnimationProvider,
	   $AnimateCssProvider,
	   $$AnimateCssDriverProvider,
	   $$AnimateJsProvider,
	   $$AnimateJsDriverProvider,
	*/

	/**
	 * @ngdoc module
	 * @name ngAnimate
	 * @description
	 *
	 * The `ngAnimate` module provides support for CSS-based animations (keyframes and transitions) as well as JavaScript-based animations via
	 * callback hooks. Animations are not enabled by default, however, by including `ngAnimate` the animation hooks are enabled for an Angular app.
	 *
	 * <div doc-module-components="ngAnimate"></div>
	 *
	 * # Usage
	 * Simply put, there are two ways to make use of animations when ngAnimate is used: by using **CSS** and **JavaScript**. The former works purely based
	 * using CSS (by using matching CSS selectors/styles) and the latter triggers animations that are registered via `module.animation()`. For
	 * both CSS and JS animations the sole requirement is to have a matching `CSS class` that exists both in the registered animation and within
	 * the HTML element that the animation will be triggered on.
	 *
	 * ## Directive Support
	 * The following directives are "animation aware":
	 *
	 * | Directive                                                                                                | Supported Animations                                                     |
	 * |----------------------------------------------------------------------------------------------------------|--------------------------------------------------------------------------|
	 * | {@link ng.directive:ngRepeat#animations ngRepeat}                                                        | enter, leave and move                                                    |
	 * | {@link ngRoute.directive:ngView#animations ngView}                                                       | enter and leave                                                          |
	 * | {@link ng.directive:ngInclude#animations ngInclude}                                                      | enter and leave                                                          |
	 * | {@link ng.directive:ngSwitch#animations ngSwitch}                                                        | enter and leave                                                          |
	 * | {@link ng.directive:ngIf#animations ngIf}                                                                | enter and leave                                                          |
	 * | {@link ng.directive:ngClass#animations ngClass}                                                          | add and remove (the CSS class(es) present)                               |
	 * | {@link ng.directive:ngShow#animations ngShow} & {@link ng.directive:ngHide#animations ngHide}            | add and remove (the ng-hide class value)                                 |
	 * | {@link ng.directive:form#animation-hooks form} & {@link ng.directive:ngModel#animation-hooks ngModel}    | add and remove (dirty, pristine, valid, invalid & all other validations) |
	 * | {@link module:ngMessages#animations ngMessages}                                                          | add and remove (ng-active & ng-inactive)                                 |
	 * | {@link module:ngMessages#animations ngMessage}                                                           | enter and leave                                                          |
	 *
	 * (More information can be found by visiting each the documentation associated with each directive.)
	 *
	 * ## CSS-based Animations
	 *
	 * CSS-based animations with ngAnimate are unique since they require no JavaScript code at all. By using a CSS class that we reference between our HTML
	 * and CSS code we can create an animation that will be picked up by Angular when an the underlying directive performs an operation.
	 *
	 * The example below shows how an `enter` animation can be made possible on an element using `ng-if`:
	 *
	 * ```html
	 * <div ng-if="bool" class="fade">
	 *    Fade me in out
	 * </div>
	 * <button ng-click="bool=true">Fade In!</button>
	 * <button ng-click="bool=false">Fade Out!</button>
	 * ```
	 *
	 * Notice the CSS class **fade**? We can now create the CSS transition code that references this class:
	 *
	 * ```css
	 * /&#42; The starting CSS styles for the enter animation &#42;/
	 * .fade.ng-enter {
	 *   transition:0.5s linear all;
	 *   opacity:0;
	 * }
	 *
	 * /&#42; The finishing CSS styles for the enter animation &#42;/
	 * .fade.ng-enter.ng-enter-active {
	 *   opacity:1;
	 * }
	 * ```
	 *
	 * The key thing to remember here is that, depending on the animation event (which each of the directives above trigger depending on what's going on) two
	 * generated CSS classes will be applied to the element; in the example above we have `.ng-enter` and `.ng-enter-active`. For CSS transitions, the transition
	 * code **must** be defined within the starting CSS class (in this case `.ng-enter`). The destination class is what the transition will animate towards.
	 *
	 * If for example we wanted to create animations for `leave` and `move` (ngRepeat triggers move) then we can do so using the same CSS naming conventions:
	 *
	 * ```css
	 * /&#42; now the element will fade out before it is removed from the DOM &#42;/
	 * .fade.ng-leave {
	 *   transition:0.5s linear all;
	 *   opacity:1;
	 * }
	 * .fade.ng-leave.ng-leave-active {
	 *   opacity:0;
	 * }
	 * ```
	 *
	 * We can also make use of **CSS Keyframes** by referencing the keyframe animation within the starting CSS class:
	 *
	 * ```css
	 * /&#42; there is no need to define anything inside of the destination
	 * CSS class since the keyframe will take charge of the animation &#42;/
	 * .fade.ng-leave {
	 *   animation: my_fade_animation 0.5s linear;
	 *   -webkit-animation: my_fade_animation 0.5s linear;
	 * }
	 *
	 * @keyframes my_fade_animation {
	 *   from { opacity:1; }
	 *   to { opacity:0; }
	 * }
	 *
	 * @-webkit-keyframes my_fade_animation {
	 *   from { opacity:1; }
	 *   to { opacity:0; }
	 * }
	 * ```
	 *
	 * Feel free also mix transitions and keyframes together as well as any other CSS classes on the same element.
	 *
	 * ### CSS Class-based Animations
	 *
	 * Class-based animations (animations that are triggered via `ngClass`, `ngShow`, `ngHide` and some other directives) have a slightly different
	 * naming convention. Class-based animations are basic enough that a standard transition or keyframe can be referenced on the class being added
	 * and removed.
	 *
	 * For example if we wanted to do a CSS animation for `ngHide` then we place an animation on the `.ng-hide` CSS class:
	 *
	 * ```html
	 * <div ng-show="bool" class="fade">
	 *   Show and hide me
	 * </div>
	 * <button ng-click="bool=true">Toggle</button>
	 *
	 * <style>
	 * .fade.ng-hide {
	 *   transition:0.5s linear all;
	 *   opacity:0;
	 * }
	 * </style>
	 * ```
	 *
	 * All that is going on here with ngShow/ngHide behind the scenes is the `.ng-hide` class is added/removed (when the hidden state is valid). Since
	 * ngShow and ngHide are animation aware then we can match up a transition and ngAnimate handles the rest.
	 *
	 * In addition the addition and removal of the CSS class, ngAnimate also provides two helper methods that we can use to further decorate the animation
	 * with CSS styles.
	 *
	 * ```html
	 * <div ng-class="{on:onOff}" class="highlight">
	 *   Highlight this box
	 * </div>
	 * <button ng-click="onOff=!onOff">Toggle</button>
	 *
	 * <style>
	 * .highlight {
	 *   transition:0.5s linear all;
	 * }
	 * .highlight.on-add {
	 *   background:white;
	 * }
	 * .highlight.on {
	 *   background:yellow;
	 * }
	 * .highlight.on-remove {
	 *   background:black;
	 * }
	 * </style>
	 * ```
	 *
	 * We can also make use of CSS keyframes by placing them within the CSS classes.
	 *
	 *
	 * ### CSS Staggering Animations
	 * A Staggering animation is a collection of animations that are issued with a slight delay in between each successive operation resulting in a
	 * curtain-like effect. The ngAnimate module (versions >=1.2) supports staggering animations and the stagger effect can be
	 * performed by creating a **ng-EVENT-stagger** CSS class and attaching that class to the base CSS class used for
	 * the animation. The style property expected within the stagger class can either be a **transition-delay** or an
	 * **animation-delay** property (or both if your animation contains both transitions and keyframe animations).
	 *
	 * ```css
	 * .my-animation.ng-enter {
	 *   /&#42; standard transition code &#42;/
	 *   transition: 1s linear all;
	 *   opacity:0;
	 * }
	 * .my-animation.ng-enter-stagger {
	 *   /&#42; this will have a 100ms delay between each successive leave animation &#42;/
	 *   transition-delay: 0.1s;
	 *
	 *   /&#42; As of 1.4.4, this must always be set: it signals ngAnimate
	 *     to not accidentally inherit a delay property from another CSS class &#42;/
	 *   transition-duration: 0s;
	 * }
	 * .my-animation.ng-enter.ng-enter-active {
	 *   /&#42; standard transition styles &#42;/
	 *   opacity:1;
	 * }
	 * ```
	 *
	 * Staggering animations work by default in ngRepeat (so long as the CSS class is defined). Outside of ngRepeat, to use staggering animations
	 * on your own, they can be triggered by firing multiple calls to the same event on $animate. However, the restrictions surrounding this
	 * are that each of the elements must have the same CSS className value as well as the same parent element. A stagger operation
	 * will also be reset if one or more animation frames have passed since the multiple calls to `$animate` were fired.
	 *
	 * The following code will issue the **ng-leave-stagger** event on the element provided:
	 *
	 * ```js
	 * var kids = parent.children();
	 *
	 * $animate.leave(kids[0]); //stagger index=0
	 * $animate.leave(kids[1]); //stagger index=1
	 * $animate.leave(kids[2]); //stagger index=2
	 * $animate.leave(kids[3]); //stagger index=3
	 * $animate.leave(kids[4]); //stagger index=4
	 *
	 * window.requestAnimationFrame(function() {
	 *   //stagger has reset itself
	 *   $animate.leave(kids[5]); //stagger index=0
	 *   $animate.leave(kids[6]); //stagger index=1
	 *
	 *   $scope.$digest();
	 * });
	 * ```
	 *
	 * Stagger animations are currently only supported within CSS-defined animations.
	 *
	 * ### The `ng-animate` CSS class
	 *
	 * When ngAnimate is animating an element it will apply the `ng-animate` CSS class to the element for the duration of the animation.
	 * This is a temporary CSS class and it will be removed once the animation is over (for both JavaScript and CSS-based animations).
	 *
	 * Therefore, animations can be applied to an element using this temporary class directly via CSS.
	 *
	 * ```css
	 * .zipper.ng-animate {
	 *   transition:0.5s linear all;
	 * }
	 * .zipper.ng-enter {
	 *   opacity:0;
	 * }
	 * .zipper.ng-enter.ng-enter-active {
	 *   opacity:1;
	 * }
	 * .zipper.ng-leave {
	 *   opacity:1;
	 * }
	 * .zipper.ng-leave.ng-leave-active {
	 *   opacity:0;
	 * }
	 * ```
	 *
	 * (Note that the `ng-animate` CSS class is reserved and it cannot be applied on an element directly since ngAnimate will always remove
	 * the CSS class once an animation has completed.)
	 *
	 *
	 * ### The `ng-[event]-prepare` class
	 *
	 * This is a special class that can be used to prevent unwanted flickering / flash of content before
	 * the actual animation starts. The class is added as soon as an animation is initialized, but removed
	 * before the actual animation starts (after waiting for a $digest).
	 * It is also only added for *structural* animations (`enter`, `move`, and `leave`).
	 *
	 * In practice, flickering can appear when nesting elements with structural animations such as `ngIf`
	 * into elements that have class-based animations such as `ngClass`.
	 *
	 * ```html
	 * <div ng-class="{red: myProp}">
	 *   <div ng-class="{blue: myProp}">
	 *     <div class="message" ng-if="myProp"></div>
	 *   </div>
	 * </div>
	 * ```
	 *
	 * It is possible that during the `enter` animation, the `.message` div will be briefly visible before it starts animating.
	 * In that case, you can add styles to the CSS that make sure the element stays hidden before the animation starts:
	 *
	 * ```css
	 * .message.ng-enter-prepare {
	 *   opacity: 0;
	 * }
	 *
	 * ```
	 *
	 * ## JavaScript-based Animations
	 *
	 * ngAnimate also allows for animations to be consumed by JavaScript code. The approach is similar to CSS-based animations (where there is a shared
	 * CSS class that is referenced in our HTML code) but in addition we need to register the JavaScript animation on the module. By making use of the
	 * `module.animation()` module function we can register the animation.
	 *
	 * Let's see an example of a enter/leave animation using `ngRepeat`:
	 *
	 * ```html
	 * <div ng-repeat="item in items" class="slide">
	 *   {{ item }}
	 * </div>
	 * ```
	 *
	 * See the **slide** CSS class? Let's use that class to define an animation that we'll structure in our module code by using `module.animation`:
	 *
	 * ```js
	 * myModule.animation('.slide', [function() {
	 *   return {
	 *     // make note that other events (like addClass/removeClass)
	 *     // have different function input parameters
	 *     enter: function(element, doneFn) {
	 *       jQuery(element).fadeIn(1000, doneFn);
	 *
	 *       // remember to call doneFn so that angular
	 *       // knows that the animation has concluded
	 *     },
	 *
	 *     move: function(element, doneFn) {
	 *       jQuery(element).fadeIn(1000, doneFn);
	 *     },
	 *
	 *     leave: function(element, doneFn) {
	 *       jQuery(element).fadeOut(1000, doneFn);
	 *     }
	 *   }
	 * }]);
	 * ```
	 *
	 * The nice thing about JS-based animations is that we can inject other services and make use of advanced animation libraries such as
	 * greensock.js and velocity.js.
	 *
	 * If our animation code class-based (meaning that something like `ngClass`, `ngHide` and `ngShow` triggers it) then we can still define
	 * our animations inside of the same registered animation, however, the function input arguments are a bit different:
	 *
	 * ```html
	 * <div ng-class="color" class="colorful">
	 *   this box is moody
	 * </div>
	 * <button ng-click="color='red'">Change to red</button>
	 * <button ng-click="color='blue'">Change to blue</button>
	 * <button ng-click="color='green'">Change to green</button>
	 * ```
	 *
	 * ```js
	 * myModule.animation('.colorful', [function() {
	 *   return {
	 *     addClass: function(element, className, doneFn) {
	 *       // do some cool animation and call the doneFn
	 *     },
	 *     removeClass: function(element, className, doneFn) {
	 *       // do some cool animation and call the doneFn
	 *     },
	 *     setClass: function(element, addedClass, removedClass, doneFn) {
	 *       // do some cool animation and call the doneFn
	 *     }
	 *   }
	 * }]);
	 * ```
	 *
	 * ## CSS + JS Animations Together
	 *
	 * AngularJS 1.4 and higher has taken steps to make the amalgamation of CSS and JS animations more flexible. However, unlike earlier versions of Angular,
	 * defining CSS and JS animations to work off of the same CSS class will not work anymore. Therefore the example below will only result in **JS animations taking
	 * charge of the animation**:
	 *
	 * ```html
	 * <div ng-if="bool" class="slide">
	 *   Slide in and out
	 * </div>
	 * ```
	 *
	 * ```js
	 * myModule.animation('.slide', [function() {
	 *   return {
	 *     enter: function(element, doneFn) {
	 *       jQuery(element).slideIn(1000, doneFn);
	 *     }
	 *   }
	 * }]);
	 * ```
	 *
	 * ```css
	 * .slide.ng-enter {
	 *   transition:0.5s linear all;
	 *   transform:translateY(-100px);
	 * }
	 * .slide.ng-enter.ng-enter-active {
	 *   transform:translateY(0);
	 * }
	 * ```
	 *
	 * Does this mean that CSS and JS animations cannot be used together? Do JS-based animations always have higher priority? We can make up for the
	 * lack of CSS animations by using the `$animateCss` service to trigger our own tweaked-out, CSS-based animations directly from
	 * our own JS-based animation code:
	 *
	 * ```js
	 * myModule.animation('.slide', ['$animateCss', function($animateCss) {
	 *   return {
	 *     enter: function(element) {
	*        // this will trigger `.slide.ng-enter` and `.slide.ng-enter-active`.
	 *       return $animateCss(element, {
	 *         event: 'enter',
	 *         structural: true
	 *       });
	 *     }
	 *   }
	 * }]);
	 * ```
	 *
	 * The nice thing here is that we can save bandwidth by sticking to our CSS-based animation code and we don't need to rely on a 3rd-party animation framework.
	 *
	 * The `$animateCss` service is very powerful since we can feed in all kinds of extra properties that will be evaluated and fed into a CSS transition or
	 * keyframe animation. For example if we wanted to animate the height of an element while adding and removing classes then we can do so by providing that
	 * data into `$animateCss` directly:
	 *
	 * ```js
	 * myModule.animation('.slide', ['$animateCss', function($animateCss) {
	 *   return {
	 *     enter: function(element) {
	 *       return $animateCss(element, {
	 *         event: 'enter',
	 *         structural: true,
	 *         addClass: 'maroon-setting',
	 *         from: { height:0 },
	 *         to: { height: 200 }
	 *       });
	 *     }
	 *   }
	 * }]);
	 * ```
	 *
	 * Now we can fill in the rest via our transition CSS code:
	 *
	 * ```css
	 * /&#42; the transition tells ngAnimate to make the animation happen &#42;/
	 * .slide.ng-enter { transition:0.5s linear all; }
	 *
	 * /&#42; this extra CSS class will be absorbed into the transition
	 * since the $animateCss code is adding the class &#42;/
	 * .maroon-setting { background:red; }
	 * ```
	 *
	 * And `$animateCss` will figure out the rest. Just make sure to have the `done()` callback fire the `doneFn` function to signal when the animation is over.
	 *
	 * To learn more about what's possible be sure to visit the {@link ngAnimate.$animateCss $animateCss service}.
	 *
	 * ## Animation Anchoring (via `ng-animate-ref`)
	 *
	 * ngAnimate in AngularJS 1.4 comes packed with the ability to cross-animate elements between
	 * structural areas of an application (like views) by pairing up elements using an attribute
	 * called `ng-animate-ref`.
	 *
	 * Let's say for example we have two views that are managed by `ng-view` and we want to show
	 * that there is a relationship between two components situated in within these views. By using the
	 * `ng-animate-ref` attribute we can identify that the two components are paired together and we
	 * can then attach an animation, which is triggered when the view changes.
	 *
	 * Say for example we have the following template code:
	 *
	 * ```html
	 * <!-- index.html -->
	 * <div ng-view class="view-animation">
	 * </div>
	 *
	 * <!-- home.html -->
	 * <a href="#/banner-page">
	 *   <img src="./banner.jpg" class="banner" ng-animate-ref="banner">
	 * </a>
	 *
	 * <!-- banner-page.html -->
	 * <img src="./banner.jpg" class="banner" ng-animate-ref="banner">
	 * ```
	 *
	 * Now, when the view changes (once the link is clicked), ngAnimate will examine the
	 * HTML contents to see if there is a match reference between any components in the view
	 * that is leaving and the view that is entering. It will scan both the view which is being
	 * removed (leave) and inserted (enter) to see if there are any paired DOM elements that
	 * contain a matching ref value.
	 *
	 * The two images match since they share the same ref value. ngAnimate will now create a
	 * transport element (which is a clone of the first image element) and it will then attempt
	 * to animate to the position of the second image element in the next view. For the animation to
	 * work a special CSS class called `ng-anchor` will be added to the transported element.
	 *
	 * We can now attach a transition onto the `.banner.ng-anchor` CSS class and then
	 * ngAnimate will handle the entire transition for us as well as the addition and removal of
	 * any changes of CSS classes between the elements:
	 *
	 * ```css
	 * .banner.ng-anchor {
	 *   /&#42; this animation will last for 1 second since there are
	 *          two phases to the animation (an `in` and an `out` phase) &#42;/
	 *   transition:0.5s linear all;
	 * }
	 * ```
	 *
	 * We also **must** include animations for the views that are being entered and removed
	 * (otherwise anchoring wouldn't be possible since the new view would be inserted right away).
	 *
	 * ```css
	 * .view-animation.ng-enter, .view-animation.ng-leave {
	 *   transition:0.5s linear all;
	 *   position:fixed;
	 *   left:0;
	 *   top:0;
	 *   width:100%;
	 * }
	 * .view-animation.ng-enter {
	 *   transform:translateX(100%);
	 * }
	 * .view-animation.ng-leave,
	 * .view-animation.ng-enter.ng-enter-active {
	 *   transform:translateX(0%);
	 * }
	 * .view-animation.ng-leave.ng-leave-active {
	 *   transform:translateX(-100%);
	 * }
	 * ```
	 *
	 * Now we can jump back to the anchor animation. When the animation happens, there are two stages that occur:
	 * an `out` and an `in` stage. The `out` stage happens first and that is when the element is animated away
	 * from its origin. Once that animation is over then the `in` stage occurs which animates the
	 * element to its destination. The reason why there are two animations is to give enough time
	 * for the enter animation on the new element to be ready.
	 *
	 * The example above sets up a transition for both the in and out phases, but we can also target the out or
	 * in phases directly via `ng-anchor-out` and `ng-anchor-in`.
	 *
	 * ```css
	 * .banner.ng-anchor-out {
	 *   transition: 0.5s linear all;
	 *
	 *   /&#42; the scale will be applied during the out animation,
	 *          but will be animated away when the in animation runs &#42;/
	 *   transform: scale(1.2);
	 * }
	 *
	 * .banner.ng-anchor-in {
	 *   transition: 1s linear all;
	 * }
	 * ```
	 *
	 *
	 *
	 *
	 * ### Anchoring Demo
	 *
	  <example module="anchoringExample"
	           name="anchoringExample"
	           id="anchoringExample"
	           deps="angular-animate.js;angular-route.js"
	           animations="true">
	    <file name="index.html">
	      <a href="#/">Home</a>
	      <hr />
	      <div class="view-container">
	        <div ng-view class="view"></div>
	      </div>
	    </file>
	    <file name="script.js">
	      angular.module('anchoringExample', ['ngAnimate', 'ngRoute'])
	        .config(['$routeProvider', function($routeProvider) {
	          $routeProvider.when('/', {
	            templateUrl: 'home.html',
	            controller: 'HomeController as home'
	          });
	          $routeProvider.when('/profile/:id', {
	            templateUrl: 'profile.html',
	            controller: 'ProfileController as profile'
	          });
	        }])
	        .run(['$rootScope', function($rootScope) {
	          $rootScope.records = [
	            { id:1, title: "Miss Beulah Roob" },
	            { id:2, title: "Trent Morissette" },
	            { id:3, title: "Miss Ava Pouros" },
	            { id:4, title: "Rod Pouros" },
	            { id:5, title: "Abdul Rice" },
	            { id:6, title: "Laurie Rutherford Sr." },
	            { id:7, title: "Nakia McLaughlin" },
	            { id:8, title: "Jordon Blanda DVM" },
	            { id:9, title: "Rhoda Hand" },
	            { id:10, title: "Alexandrea Sauer" }
	          ];
	        }])
	        .controller('HomeController', [function() {
	          //empty
	        }])
	        .controller('ProfileController', ['$rootScope', '$routeParams', function($rootScope, $routeParams) {
	          var index = parseInt($routeParams.id, 10);
	          var record = $rootScope.records[index - 1];

	          this.title = record.title;
	          this.id = record.id;
	        }]);
	    </file>
	    <file name="home.html">
	      <h2>Welcome to the home page</h1>
	      <p>Please click on an element</p>
	      <a class="record"
	         ng-href="#/profile/{{ record.id }}"
	         ng-animate-ref="{{ record.id }}"
	         ng-repeat="record in records">
	        {{ record.title }}
	      </a>
	    </file>
	    <file name="profile.html">
	      <div class="profile record" ng-animate-ref="{{ profile.id }}">
	        {{ profile.title }}
	      </div>
	    </file>
	    <file name="animations.css">
	      .record {
	        display:block;
	        font-size:20px;
	      }
	      .profile {
	        background:black;
	        color:white;
	        font-size:100px;
	      }
	      .view-container {
	        position:relative;
	      }
	      .view-container > .view.ng-animate {
	        position:absolute;
	        top:0;
	        left:0;
	        width:100%;
	        min-height:500px;
	      }
	      .view.ng-enter, .view.ng-leave,
	      .record.ng-anchor {
	        transition:0.5s linear all;
	      }
	      .view.ng-enter {
	        transform:translateX(100%);
	      }
	      .view.ng-enter.ng-enter-active, .view.ng-leave {
	        transform:translateX(0%);
	      }
	      .view.ng-leave.ng-leave-active {
	        transform:translateX(-100%);
	      }
	      .record.ng-anchor-out {
	        background:red;
	      }
	    </file>
	  </example>
	 *
	 * ### How is the element transported?
	 *
	 * When an anchor animation occurs, ngAnimate will clone the starting element and position it exactly where the starting
	 * element is located on screen via absolute positioning. The cloned element will be placed inside of the root element
	 * of the application (where ng-app was defined) and all of the CSS classes of the starting element will be applied. The
	 * element will then animate into the `out` and `in` animations and will eventually reach the coordinates and match
	 * the dimensions of the destination element. During the entire animation a CSS class of `.ng-animate-shim` will be applied
	 * to both the starting and destination elements in order to hide them from being visible (the CSS styling for the class
	 * is: `visibility:hidden`). Once the anchor reaches its destination then it will be removed and the destination element
	 * will become visible since the shim class will be removed.
	 *
	 * ### How is the morphing handled?
	 *
	 * CSS Anchoring relies on transitions and keyframes and the internal code is intelligent enough to figure out
	 * what CSS classes differ between the starting element and the destination element. These different CSS classes
	 * will be added/removed on the anchor element and a transition will be applied (the transition that is provided
	 * in the anchor class). Long story short, ngAnimate will figure out what classes to add and remove which will
	 * make the transition of the element as smooth and automatic as possible. Be sure to use simple CSS classes that
	 * do not rely on DOM nesting structure so that the anchor element appears the same as the starting element (since
	 * the cloned element is placed inside of root element which is likely close to the body element).
	 *
	 * Note that if the root element is on the `<html>` element then the cloned node will be placed inside of body.
	 *
	 *
	 * ## Using $animate in your directive code
	 *
	 * So far we've explored how to feed in animations into an Angular application, but how do we trigger animations within our own directives in our application?
	 * By injecting the `$animate` service into our directive code, we can trigger structural and class-based hooks which can then be consumed by animations. Let's
	 * imagine we have a greeting box that shows and hides itself when the data changes
	 *
	 * ```html
	 * <greeting-box active="onOrOff">Hi there</greeting-box>
	 * ```
	 *
	 * ```js
	 * ngModule.directive('greetingBox', ['$animate', function($animate) {
	 *   return function(scope, element, attrs) {
	 *     attrs.$observe('active', function(value) {
	 *       value ? $animate.addClass(element, 'on') : $animate.removeClass(element, 'on');
	 *     });
	 *   });
	 * }]);
	 * ```
	 *
	 * Now the `on` CSS class is added and removed on the greeting box component. Now if we add a CSS class on top of the greeting box element
	 * in our HTML code then we can trigger a CSS or JS animation to happen.
	 *
	 * ```css
	 * /&#42; normally we would create a CSS class to reference on the element &#42;/
	 * greeting-box.on { transition:0.5s linear all; background:green; color:white; }
	 * ```
	 *
	 * The `$animate` service contains a variety of other methods like `enter`, `leave`, `animate` and `setClass`. To learn more about what's
	 * possible be sure to visit the {@link ng.$animate $animate service API page}.
	 *
	 *
	 * ## Callbacks and Promises
	 *
	 * When `$animate` is called it returns a promise that can be used to capture when the animation has ended. Therefore if we were to trigger
	 * an animation (within our directive code) then we can continue performing directive and scope related activities after the animation has
	 * ended by chaining onto the returned promise that animation method returns.
	 *
	 * ```js
	 * // somewhere within the depths of the directive
	 * $animate.enter(element, parent).then(function() {
	 *   //the animation has completed
	 * });
	 * ```
	 *
	 * (Note that earlier versions of Angular prior to v1.4 required the promise code to be wrapped using `$scope.$apply(...)`. This is not the case
	 * anymore.)
	 *
	 * In addition to the animation promise, we can also make use of animation-related callbacks within our directives and controller code by registering
	 * an event listener using the `$animate` service. Let's say for example that an animation was triggered on our view
	 * routing controller to hook into that:
	 *
	 * ```js
	 * ngModule.controller('HomePageController', ['$animate', function($animate) {
	 *   $animate.on('enter', ngViewElement, function(element) {
	 *     // the animation for this route has completed
	 *   }]);
	 * }])
	 * ```
	 *
	 * (Note that you will need to trigger a digest within the callback to get angular to notice any scope-related changes.)
	 */

	/**
	 * @ngdoc service
	 * @name $animate
	 * @kind object
	 *
	 * @description
	 * The ngAnimate `$animate` service documentation is the same for the core `$animate` service.
	 *
	 * Click here {@link ng.$animate to learn more about animations with `$animate`}.
	 */
	angular.module('ngAnimate', [])
	  .directive('ngAnimateSwap', ngAnimateSwapDirective)

	  .directive('ngAnimateChildren', $$AnimateChildrenDirective)
	  .factory('$$rAFScheduler', $$rAFSchedulerFactory)

	  .provider('$$animateQueue', $$AnimateQueueProvider)
	  .provider('$$animation', $$AnimationProvider)

	  .provider('$animateCss', $AnimateCssProvider)
	  .provider('$$animateCssDriver', $$AnimateCssDriverProvider)

	  .provider('$$animateJs', $$AnimateJsProvider)
	  .provider('$$animateJsDriver', $$AnimateJsDriverProvider);


	})(window, window.angular);


/***/ },
/* 22 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(jQuery) {'use strict';

	/*
	 * ScrollToFixed
	 * https://github.com/bigspotteddog/ScrollToFixed
	 *
	 * Copyright (c) 2011 Joseph Cava-Lynch
	 * MIT license
	 */
	(function ($) {
	    $.isScrollToFixed = function (el) {
	        return !!$(el).data('ScrollToFixed');
	    };

	    $.ScrollToFixed = function (el, options) {
	        // To avoid scope issues, use 'base' instead of 'this' to reference this
	        // class from internal events and functions.
	        var base = this;

	        // Access to jQuery and DOM versions of element.
	        base.$el = $(el);
	        base.el = el;

	        // Add a reverse reference to the DOM object.
	        base.$el.data('ScrollToFixed', base);

	        // A flag so we know if the scroll has been reset.
	        var isReset = false;

	        // The element that was given to us to fix if scrolled above the top of
	        // the page.
	        var target = base.$el;

	        var position;
	        var originalPosition;
	        var originalFloat;
	        var originalOffsetTop;
	        var originalZIndex;

	        // The offset top of the element when resetScroll was called. This is
	        // used to determine if we have scrolled past the top of the element.
	        var offsetTop = 0;

	        // The offset left of the element when resetScroll was called. This is
	        // used to move the element left or right relative to the horizontal
	        // scroll.
	        var offsetLeft = 0;
	        var originalOffsetLeft = -1;

	        // This last offset used to move the element horizontally. This is used
	        // to determine if we need to move the element because we would not want
	        // to do that for no reason.
	        var lastOffsetLeft = -1;

	        // This is the element used to fill the void left by the target element
	        // when it goes fixed; otherwise, everything below it moves up the page.
	        var spacer = null;

	        var spacerClass;

	        var className;

	        // Capture the original offsets for the target element. This needs to be
	        // called whenever the page size changes or when the page is first
	        // scrolled. For some reason, calling this before the page is first
	        // scrolled causes the element to become fixed too late.
	        function resetScroll() {
	            // Set the element to it original positioning.
	            target.trigger('preUnfixed.ScrollToFixed');
	            setUnfixed();
	            target.trigger('unfixed.ScrollToFixed');

	            // Reset the last offset used to determine if the page has moved
	            // horizontally.
	            lastOffsetLeft = -1;

	            // Capture the offset top of the target element.
	            offsetTop = target.offset().top;

	            // Capture the offset left of the target element.
	            offsetLeft = target.offset().left;

	            // If the offsets option is on, alter the left offset.
	            if (base.options.offsets) {
	                offsetLeft += target.offset().left - target.position().left;
	            }

	            if (originalOffsetLeft == -1) {
	                originalOffsetLeft = offsetLeft;
	            }

	            position = target.css('position');

	            // Set that this has been called at least once.
	            isReset = true;

	            if (base.options.bottom != -1) {
	                target.trigger('preFixed.ScrollToFixed');
	                setFixed();
	                target.trigger('fixed.ScrollToFixed');
	            }
	        }

	        function getLimit() {
	            var limit = base.options.limit;
	            if (!limit) return 0;

	            if (typeof limit === 'function') {
	                return limit.apply(target);
	            }
	            return limit;
	        }

	        // Returns whether the target element is fixed or not.
	        function isFixed() {
	            return position === 'fixed';
	        }

	        // Returns whether the target element is absolute or not.
	        function isAbsolute() {
	            return position === 'absolute';
	        }

	        function isUnfixed() {
	            return !(isFixed() || isAbsolute());
	        }

	        // Sets the target element to fixed. Also, sets the spacer to fill the
	        // void left by the target element.
	        function setFixed() {
	            // Only fix the target element and the spacer if we need to.
	            if (!isFixed()) {
	                //get REAL dimensions (decimal fix)
	                //Ref. http://stackoverflow.com/questions/3603065/how-to-make-jquery-to-not-round-value-returned-by-width
	                var dimensions = target[0].getBoundingClientRect();
	                // Set the spacer to fill the height and width of the target
	                // element, then display it.
	                spacer.css({
	                    'display': target.css('display'),
	                    'width': dimensions.width,
	                    'height': dimensions.height,
	                    'float': target.css('float')
	                });

	                // Set the target element to fixed and set its width so it does
	                // not fill the rest of the page horizontally. Also, set its top
	                // to the margin top specified in the options.

	                cssOptions = {
	                    'z-index': base.options.zIndex,
	                    'position': 'fixed',
	                    'top': base.options.bottom == -1 ? getMarginTop() : '',
	                    'bottom': base.options.bottom == -1 ? '' : base.options.bottom,
	                    'margin-left': '0px'
	                };
	                if (!base.options.dontSetWidth) {
	                    cssOptions['width'] = target.css('width');
	                };

	                target.css(cssOptions);

	                target.addClass(base.options.baseClassName);

	                if (base.options.className) {
	                    target.addClass(base.options.className);
	                }

	                position = 'fixed';
	            }
	        }

	        function setAbsolute() {

	            var top = getLimit();
	            var left = offsetLeft;

	            if (base.options.removeOffsets) {
	                left = '';
	                top = top - offsetTop;
	            }

	            cssOptions = {
	                'position': 'absolute',
	                'top': top,
	                'left': left,
	                'margin-left': '0px',
	                'bottom': ''
	            };
	            if (!base.options.dontSetWidth) {
	                cssOptions['width'] = target.css('width');
	            };

	            target.css(cssOptions);

	            position = 'absolute';
	        }

	        // Sets the target element back to unfixed. Also, hides the spacer.
	        function setUnfixed() {
	            // Only unfix the target element and the spacer if we need to.
	            if (!isUnfixed()) {
	                lastOffsetLeft = -1;

	                // Hide the spacer now that the target element will fill the
	                // space.
	                spacer.css('display', 'none');

	                // Remove the style attributes that were added to the target.
	                // This will reverse the target back to the its original style.
	                target.css({
	                    'z-index': originalZIndex,
	                    'width': '',
	                    'position': originalPosition,
	                    'left': '',
	                    'top': originalOffsetTop,
	                    'margin-left': ''
	                });

	                target.removeClass('scroll-to-fixed-fixed');

	                if (base.options.className) {
	                    target.removeClass(base.options.className);
	                }

	                position = null;
	            }
	        }

	        // Moves the target element left or right relative to the horizontal
	        // scroll position.
	        function setLeft(x) {
	            // Only if the scroll is not what it was last time we did this.
	            if (x != lastOffsetLeft) {
	                // Move the target element horizontally relative to its original
	                // horizontal position.
	                target.css('left', offsetLeft - x);

	                // Hold the last horizontal position set.
	                lastOffsetLeft = x;
	            }
	        }

	        function getMarginTop() {
	            var marginTop = base.options.marginTop;
	            if (!marginTop) return 0;

	            if (typeof marginTop === 'function') {
	                return marginTop.apply(target);
	            }
	            return marginTop;
	        }

	        // Checks to see if we need to do something based on new scroll position
	        // of the page.
	        function checkScroll() {
	            if (!$.isScrollToFixed(target) || target.is(':hidden')) return;
	            var wasReset = isReset;
	            var wasUnfixed = isUnfixed();

	            // If resetScroll has not yet been called, call it. This only
	            // happens once.
	            if (!isReset) {
	                resetScroll();
	            } else if (isUnfixed()) {
	                // if the offset has changed since the last scroll,
	                // we need to get it again.

	                // Capture the offset top of the target element.
	                offsetTop = target.offset().top;

	                // Capture the offset left of the target element.
	                offsetLeft = target.offset().left;
	            }

	            // Grab the current horizontal scroll position.
	            var x = $(window).scrollLeft();

	            // Grab the current vertical scroll position.
	            var y = $(window).scrollTop();

	            // Get the limit, if there is one.
	            var limit = getLimit();

	            // If the vertical scroll position, plus the optional margin, would
	            // put the target element at the specified limit, set the target
	            // element to absolute.
	            if (base.options.minWidth && $(window).width() < base.options.minWidth) {
	                if (!isUnfixed() || !wasReset) {
	                    postPosition();
	                    target.trigger('preUnfixed.ScrollToFixed');
	                    setUnfixed();
	                    target.trigger('unfixed.ScrollToFixed');
	                }
	            } else if (base.options.maxWidth && $(window).width() > base.options.maxWidth) {
	                if (!isUnfixed() || !wasReset) {
	                    postPosition();
	                    target.trigger('preUnfixed.ScrollToFixed');
	                    setUnfixed();
	                    target.trigger('unfixed.ScrollToFixed');
	                }
	            } else if (base.options.bottom == -1) {
	                // If the vertical scroll position, plus the optional margin, would
	                // put the target element at the specified limit, set the target
	                // element to absolute.
	                if (limit > 0 && y >= limit - getMarginTop()) {
	                    if (!wasUnfixed && (!isAbsolute() || !wasReset)) {
	                        postPosition();
	                        target.trigger('preAbsolute.ScrollToFixed');
	                        setAbsolute();
	                        target.trigger('unfixed.ScrollToFixed');
	                    }
	                    // If the vertical scroll position, plus the optional margin, would
	                    // put the target element above the top of the page, set the target
	                    // element to fixed.
	                } else if (y >= offsetTop - getMarginTop()) {
	                        if (!isFixed() || !wasReset) {
	                            postPosition();
	                            target.trigger('preFixed.ScrollToFixed');

	                            // Set the target element to fixed.
	                            setFixed();

	                            // Reset the last offset left because we just went fixed.
	                            lastOffsetLeft = -1;

	                            target.trigger('fixed.ScrollToFixed');
	                        }
	                        // If the page has been scrolled horizontally as well, move the
	                        // target element accordingly.
	                        setLeft(x);
	                    } else {
	                        // Set the target element to unfixed, placing it where it was
	                        // before.
	                        if (!isUnfixed() || !wasReset) {
	                            postPosition();
	                            target.trigger('preUnfixed.ScrollToFixed');
	                            setUnfixed();
	                            target.trigger('unfixed.ScrollToFixed');
	                        }
	                    }
	            } else {
	                if (limit > 0) {
	                    if (y + $(window).height() - target.outerHeight(true) >= limit - (getMarginTop() || -getBottom())) {
	                        if (isFixed()) {
	                            postPosition();
	                            target.trigger('preUnfixed.ScrollToFixed');

	                            if (originalPosition === 'absolute') {
	                                setAbsolute();
	                            } else {
	                                setUnfixed();
	                            }

	                            target.trigger('unfixed.ScrollToFixed');
	                        }
	                    } else {
	                        if (!isFixed()) {
	                            postPosition();
	                            target.trigger('preFixed.ScrollToFixed');
	                            setFixed();
	                        }
	                        setLeft(x);
	                        target.trigger('fixed.ScrollToFixed');
	                    }
	                } else {
	                    setLeft(x);
	                }
	            }
	        }

	        function getBottom() {
	            if (!base.options.bottom) return 0;
	            return base.options.bottom;
	        }

	        function postPosition() {
	            var position = target.css('position');

	            if (position == 'absolute') {
	                target.trigger('postAbsolute.ScrollToFixed');
	            } else if (position == 'fixed') {
	                target.trigger('postFixed.ScrollToFixed');
	            } else {
	                target.trigger('postUnfixed.ScrollToFixed');
	            }
	        }

	        var windowResize = function windowResize(event) {
	            // Check if the element is visible before updating it's position, which
	            // improves behavior with responsive designs where this element is hidden.
	            if (target.is(':visible')) {
	                isReset = false;
	                checkScroll();
	            } else {
	                // Ensure the spacer is hidden
	                setUnfixed();
	            }
	        };

	        var windowScroll = function windowScroll(event) {
	            !!window.requestAnimationFrame ? requestAnimationFrame(checkScroll) : checkScroll();
	        };

	        // From: http://kangax.github.com/cft/#IS_POSITION_FIXED_SUPPORTED
	        var isPositionFixedSupported = function isPositionFixedSupported() {
	            var container = document.body;

	            if (document.createElement && container && container.appendChild && container.removeChild) {
	                var el = document.createElement('div');

	                if (!el.getBoundingClientRect) return null;

	                el.innerHTML = 'x';
	                el.style.cssText = 'position:fixed;top:100px;';
	                container.appendChild(el);

	                var originalHeight = container.style.height,
	                    originalScrollTop = container.scrollTop;

	                container.style.height = '3000px';
	                container.scrollTop = 500;

	                var elementTop = el.getBoundingClientRect().top;
	                container.style.height = originalHeight;

	                var isSupported = elementTop === 100;
	                container.removeChild(el);
	                container.scrollTop = originalScrollTop;

	                return isSupported;
	            }

	            return null;
	        };

	        var preventDefault = function preventDefault(e) {
	            e = e || window.event;
	            if (e.preventDefault) {
	                e.preventDefault();
	            }
	            e.returnValue = false;
	        };

	        // Initializes this plugin. Captures the options passed in, turns this
	        // off for devices that do not support fixed position, adds the spacer,
	        // and binds to the window scroll and resize events.
	        base.init = function () {
	            // Capture the options for this plugin.
	            base.options = $.extend({}, $.ScrollToFixed.defaultOptions, options);

	            originalZIndex = target.css('z-index');

	            // Turn off this functionality for devices that do not support it.
	            // if (!(base.options && base.options.dontCheckForPositionFixedSupport)) {
	            //     var fixedSupported = isPositionFixedSupported();
	            //     if (!fixedSupported) return;
	            // }

	            // Put the target element on top of everything that could be below
	            // it. This reduces flicker when the target element is transitioning
	            // to fixed.
	            base.$el.css('z-index', base.options.zIndex);

	            // Create a spacer element to fill the void left by the target
	            // element when it goes fixed.
	            spacer = $('<div />');

	            position = target.css('position');
	            originalPosition = target.css('position');
	            originalFloat = target.css('float');
	            originalOffsetTop = target.css('top');

	            // Place the spacer right after the target element.
	            if (isUnfixed()) base.$el.after(spacer);

	            // Reset the target element offsets when the window is resized, then
	            // check to see if we need to fix or unfix the target element.
	            $(window).bind('resize.ScrollToFixed', windowResize);

	            // When the window scrolls, check to see if we need to fix or unfix
	            // the target element.
	            $(window).bind('scroll.ScrollToFixed', windowScroll);

	            // For touch devices, call checkScroll directlly rather than
	            // rAF wrapped windowScroll to animate the element
	            if ('ontouchmove' in window) {
	                $(window).bind('touchmove.ScrollToFixed', checkScroll);
	            }

	            if (base.options.preFixed) {
	                target.bind('preFixed.ScrollToFixed', base.options.preFixed);
	            }
	            if (base.options.postFixed) {
	                target.bind('postFixed.ScrollToFixed', base.options.postFixed);
	            }
	            if (base.options.preUnfixed) {
	                target.bind('preUnfixed.ScrollToFixed', base.options.preUnfixed);
	            }
	            if (base.options.postUnfixed) {
	                target.bind('postUnfixed.ScrollToFixed', base.options.postUnfixed);
	            }
	            if (base.options.preAbsolute) {
	                target.bind('preAbsolute.ScrollToFixed', base.options.preAbsolute);
	            }
	            if (base.options.postAbsolute) {
	                target.bind('postAbsolute.ScrollToFixed', base.options.postAbsolute);
	            }
	            if (base.options.fixed) {
	                target.bind('fixed.ScrollToFixed', base.options.fixed);
	            }
	            if (base.options.unfixed) {
	                target.bind('unfixed.ScrollToFixed', base.options.unfixed);
	            }

	            if (base.options.spacerClass) {
	                spacer.addClass(base.options.spacerClass);
	            }

	            target.bind('resize.ScrollToFixed', function () {
	                spacer.height(target.height());
	            });

	            target.bind('scroll.ScrollToFixed', function () {
	                target.trigger('preUnfixed.ScrollToFixed');
	                setUnfixed();
	                target.trigger('unfixed.ScrollToFixed');
	                checkScroll();
	            });

	            target.bind('detach.ScrollToFixed', function (ev) {
	                preventDefault(ev);

	                target.trigger('preUnfixed.ScrollToFixed');
	                setUnfixed();
	                target.trigger('unfixed.ScrollToFixed');

	                $(window).unbind('resize.ScrollToFixed', windowResize);
	                $(window).unbind('scroll.ScrollToFixed', windowScroll);

	                target.unbind('.ScrollToFixed');

	                //remove spacer from dom
	                spacer.remove();

	                base.$el.removeData('ScrollToFixed');
	            });

	            // Reset everything.
	            windowResize();
	        };

	        // Initialize the plugin.
	        base.init();
	    };

	    // Sets the option defaults.
	    $.ScrollToFixed.defaultOptions = {
	        marginTop: 0,
	        limit: 0,
	        bottom: -1,
	        zIndex: 1000,
	        baseClassName: 'scroll-to-fixed-fixed'
	    };

	    // Returns enhanced elements that will fix to the top of the page when the
	    // page is scrolled.
	    $.fn.scrollToFixed = function (options) {
	        return this.each(function () {
	            new $.ScrollToFixed(this, options);
	        });
	    };
	})(jQuery);
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(5)))

/***/ },
/* 23 */
/***/ function(module, exports, __webpack_require__) {

	__webpack_require__(24);
	module.exports = 'ngCookies';


/***/ },
/* 24 */
/***/ function(module, exports) {

	/**
	 * @license AngularJS v1.5.3
	 * (c) 2010-2016 Google, Inc. http://angularjs.org
	 * License: MIT
	 */
	(function(window, angular, undefined) {'use strict';

	/**
	 * @ngdoc module
	 * @name ngCookies
	 * @description
	 *
	 * # ngCookies
	 *
	 * The `ngCookies` module provides a convenient wrapper for reading and writing browser cookies.
	 *
	 *
	 * <div doc-module-components="ngCookies"></div>
	 *
	 * See {@link ngCookies.$cookies `$cookies`} for usage.
	 */


	angular.module('ngCookies', ['ng']).
	  /**
	   * @ngdoc provider
	   * @name $cookiesProvider
	   * @description
	   * Use `$cookiesProvider` to change the default behavior of the {@link ngCookies.$cookies $cookies} service.
	   * */
	   provider('$cookies', [function $CookiesProvider() {
	    /**
	     * @ngdoc property
	     * @name $cookiesProvider#defaults
	     * @description
	     *
	     * Object containing default options to pass when setting cookies.
	     *
	     * The object may have following properties:
	     *
	     * - **path** - `{string}` - The cookie will be available only for this path and its
	     *   sub-paths. By default, this is the URL that appears in your `<base>` tag.
	     * - **domain** - `{string}` - The cookie will be available only for this domain and
	     *   its sub-domains. For security reasons the user agent will not accept the cookie
	     *   if the current domain is not a sub-domain of this domain or equal to it.
	     * - **expires** - `{string|Date}` - String of the form "Wdy, DD Mon YYYY HH:MM:SS GMT"
	     *   or a Date object indicating the exact date/time this cookie will expire.
	     * - **secure** - `{boolean}` - If `true`, then the cookie will only be available through a
	     *   secured connection.
	     *
	     * Note: By default, the address that appears in your `<base>` tag will be used as the path.
	     * This is important so that cookies will be visible for all routes when html5mode is enabled.
	     *
	     **/
	    var defaults = this.defaults = {};

	    function calcOptions(options) {
	      return options ? angular.extend({}, defaults, options) : defaults;
	    }

	    /**
	     * @ngdoc service
	     * @name $cookies
	     *
	     * @description
	     * Provides read/write access to browser's cookies.
	     *
	     * <div class="alert alert-info">
	     * Up until Angular 1.3, `$cookies` exposed properties that represented the
	     * current browser cookie values. In version 1.4, this behavior has changed, and
	     * `$cookies` now provides a standard api of getters, setters etc.
	     * </div>
	     *
	     * Requires the {@link ngCookies `ngCookies`} module to be installed.
	     *
	     * @example
	     *
	     * ```js
	     * angular.module('cookiesExample', ['ngCookies'])
	     *   .controller('ExampleController', ['$cookies', function($cookies) {
	     *     // Retrieving a cookie
	     *     var favoriteCookie = $cookies.get('myFavorite');
	     *     // Setting a cookie
	     *     $cookies.put('myFavorite', 'oatmeal');
	     *   }]);
	     * ```
	     */
	    this.$get = ['$$cookieReader', '$$cookieWriter', function($$cookieReader, $$cookieWriter) {
	      return {
	        /**
	         * @ngdoc method
	         * @name $cookies#get
	         *
	         * @description
	         * Returns the value of given cookie key
	         *
	         * @param {string} key Id to use for lookup.
	         * @returns {string} Raw cookie value.
	         */
	        get: function(key) {
	          return $$cookieReader()[key];
	        },

	        /**
	         * @ngdoc method
	         * @name $cookies#getObject
	         *
	         * @description
	         * Returns the deserialized value of given cookie key
	         *
	         * @param {string} key Id to use for lookup.
	         * @returns {Object} Deserialized cookie value.
	         */
	        getObject: function(key) {
	          var value = this.get(key);
	          return value ? angular.fromJson(value) : value;
	        },

	        /**
	         * @ngdoc method
	         * @name $cookies#getAll
	         *
	         * @description
	         * Returns a key value object with all the cookies
	         *
	         * @returns {Object} All cookies
	         */
	        getAll: function() {
	          return $$cookieReader();
	        },

	        /**
	         * @ngdoc method
	         * @name $cookies#put
	         *
	         * @description
	         * Sets a value for given cookie key
	         *
	         * @param {string} key Id for the `value`.
	         * @param {string} value Raw value to be stored.
	         * @param {Object=} options Options object.
	         *    See {@link ngCookies.$cookiesProvider#defaults $cookiesProvider.defaults}
	         */
	        put: function(key, value, options) {
	          $$cookieWriter(key, value, calcOptions(options));
	        },

	        /**
	         * @ngdoc method
	         * @name $cookies#putObject
	         *
	         * @description
	         * Serializes and sets a value for given cookie key
	         *
	         * @param {string} key Id for the `value`.
	         * @param {Object} value Value to be stored.
	         * @param {Object=} options Options object.
	         *    See {@link ngCookies.$cookiesProvider#defaults $cookiesProvider.defaults}
	         */
	        putObject: function(key, value, options) {
	          this.put(key, angular.toJson(value), options);
	        },

	        /**
	         * @ngdoc method
	         * @name $cookies#remove
	         *
	         * @description
	         * Remove given cookie
	         *
	         * @param {string} key Id of the key-value pair to delete.
	         * @param {Object=} options Options object.
	         *    See {@link ngCookies.$cookiesProvider#defaults $cookiesProvider.defaults}
	         */
	        remove: function(key, options) {
	          $$cookieWriter(key, undefined, calcOptions(options));
	        }
	      };
	    }];
	  }]);

	angular.module('ngCookies').
	/**
	 * @ngdoc service
	 * @name $cookieStore
	 * @deprecated
	 * @requires $cookies
	 *
	 * @description
	 * Provides a key-value (string-object) storage, that is backed by session cookies.
	 * Objects put or retrieved from this storage are automatically serialized or
	 * deserialized by angular's toJson/fromJson.
	 *
	 * Requires the {@link ngCookies `ngCookies`} module to be installed.
	 *
	 * <div class="alert alert-danger">
	 * **Note:** The $cookieStore service is **deprecated**.
	 * Please use the {@link ngCookies.$cookies `$cookies`} service instead.
	 * </div>
	 *
	 * @example
	 *
	 * ```js
	 * angular.module('cookieStoreExample', ['ngCookies'])
	 *   .controller('ExampleController', ['$cookieStore', function($cookieStore) {
	 *     // Put cookie
	 *     $cookieStore.put('myFavorite','oatmeal');
	 *     // Get cookie
	 *     var favoriteCookie = $cookieStore.get('myFavorite');
	 *     // Removing a cookie
	 *     $cookieStore.remove('myFavorite');
	 *   }]);
	 * ```
	 */
	 factory('$cookieStore', ['$cookies', function($cookies) {

	    return {
	      /**
	       * @ngdoc method
	       * @name $cookieStore#get
	       *
	       * @description
	       * Returns the value of given cookie key
	       *
	       * @param {string} key Id to use for lookup.
	       * @returns {Object} Deserialized cookie value, undefined if the cookie does not exist.
	       */
	      get: function(key) {
	        return $cookies.getObject(key);
	      },

	      /**
	       * @ngdoc method
	       * @name $cookieStore#put
	       *
	       * @description
	       * Sets a value for given cookie key
	       *
	       * @param {string} key Id for the `value`.
	       * @param {Object} value Value to be stored.
	       */
	      put: function(key, value) {
	        $cookies.putObject(key, value);
	      },

	      /**
	       * @ngdoc method
	       * @name $cookieStore#remove
	       *
	       * @description
	       * Remove given cookie
	       *
	       * @param {string} key Id of the key-value pair to delete.
	       */
	      remove: function(key) {
	        $cookies.remove(key);
	      }
	    };

	  }]);

	/**
	 * @name $$cookieWriter
	 * @requires $document
	 *
	 * @description
	 * This is a private service for writing cookies
	 *
	 * @param {string} name Cookie name
	 * @param {string=} value Cookie value (if undefined, cookie will be deleted)
	 * @param {Object=} options Object with options that need to be stored for the cookie.
	 */
	function $$CookieWriter($document, $log, $browser) {
	  var cookiePath = $browser.baseHref();
	  var rawDocument = $document[0];

	  function buildCookieString(name, value, options) {
	    var path, expires;
	    options = options || {};
	    expires = options.expires;
	    path = angular.isDefined(options.path) ? options.path : cookiePath;
	    if (angular.isUndefined(value)) {
	      expires = 'Thu, 01 Jan 1970 00:00:00 GMT';
	      value = '';
	    }
	    if (angular.isString(expires)) {
	      expires = new Date(expires);
	    }

	    var str = encodeURIComponent(name) + '=' + encodeURIComponent(value);
	    str += path ? ';path=' + path : '';
	    str += options.domain ? ';domain=' + options.domain : '';
	    str += expires ? ';expires=' + expires.toUTCString() : '';
	    str += options.secure ? ';secure' : '';

	    // per http://www.ietf.org/rfc/rfc2109.txt browser must allow at minimum:
	    // - 300 cookies
	    // - 20 cookies per unique domain
	    // - 4096 bytes per cookie
	    var cookieLength = str.length + 1;
	    if (cookieLength > 4096) {
	      $log.warn("Cookie '" + name +
	        "' possibly not set or overflowed because it was too large (" +
	        cookieLength + " > 4096 bytes)!");
	    }

	    return str;
	  }

	  return function(name, value, options) {
	    rawDocument.cookie = buildCookieString(name, value, options);
	  };
	}

	$$CookieWriter.$inject = ['$document', '$log', '$browser'];

	angular.module('ngCookies').provider('$$cookieWriter', function $$CookieWriterProvider() {
	  this.$get = $$CookieWriter;
	});


	})(window, window.angular);


/***/ },
/* 25 */
/***/ function(module, exports, __webpack_require__) {

	__webpack_require__(26);
	module.exports = 'ngMessages';


/***/ },
/* 26 */
/***/ function(module, exports) {

	/**
	 * @license AngularJS v1.5.3
	 * (c) 2010-2016 Google, Inc. http://angularjs.org
	 * License: MIT
	 */
	(function(window, angular, undefined) {'use strict';

	/* jshint ignore:start */
	// this code is in the core, but not in angular-messages.js
	var isArray = angular.isArray;
	var forEach = angular.forEach;
	var isString = angular.isString;
	var jqLite = angular.element;
	/* jshint ignore:end */

	/**
	 * @ngdoc module
	 * @name ngMessages
	 * @description
	 *
	 * The `ngMessages` module provides enhanced support for displaying messages within templates
	 * (typically within forms or when rendering message objects that return key/value data).
	 * Instead of relying on JavaScript code and/or complex ng-if statements within your form template to
	 * show and hide error messages specific to the state of an input field, the `ngMessages` and
	 * `ngMessage` directives are designed to handle the complexity, inheritance and priority
	 * sequencing based on the order of how the messages are defined in the template.
	 *
	 * Currently, the ngMessages module only contains the code for the `ngMessages`, `ngMessagesInclude`
	 * `ngMessage` and `ngMessageExp` directives.
	 *
	 * # Usage
	 * The `ngMessages` directive allows keys in a key/value collection to be associated with a child element
	 * (or 'message') that will show or hide based on the truthiness of that key's value in the collection. A common use
	 * case for `ngMessages` is to display error messages for inputs using the `$error` object exposed by the
	 * {@link ngModel ngModel} directive.
	 *
	 * The child elements of the `ngMessages` directive are matched to the collection keys by a `ngMessage` or
	 * `ngMessageExp` directive. The value of these attributes must match a key in the collection that is provided by
	 * the `ngMessages` directive.
	 *
	 * Consider the following example, which illustrates a typical use case of `ngMessages`. Within the form `myForm` we
	 * have a text input named `myField` which is bound to the scope variable `field` using the {@link ngModel ngModel}
	 * directive.
	 *
	 * The `myField` field is a required input of type `email` with a maximum length of 15 characters.
	 *
	 * ```html
	 * <form name="myForm">
	 *   <label>
	 *     Enter text:
	 *     <input type="email" ng-model="field" name="myField" required maxlength="15" />
	 *   </label>
	 *   <div ng-messages="myForm.myField.$error" role="alert">
	 *     <div ng-message="required">Please enter a value for this field.</div>
	 *     <div ng-message="email">This field must be a valid email address.</div>
	 *     <div ng-message="maxlength">This field can be at most 15 characters long.</div>
	 *   </div>
	 * </form>
	 * ```
	 *
	 * In order to show error messages corresponding to `myField` we first create an element with an `ngMessages` attribute
	 * set to the `$error` object owned by the `myField` input in our `myForm` form.
	 *
	 * Within this element we then create separate elements for each of the possible errors that `myField` could have.
	 * The `ngMessage` attribute is used to declare which element(s) will appear for which error - for example,
	 * setting `ng-message="required"` specifies that this particular element should be displayed when there
	 * is no value present for the required field `myField` (because the key `required` will be `true` in the object
	 * `myForm.myField.$error`).
	 *
	 * ### Message order
	 *
	 * By default, `ngMessages` will only display one message for a particular key/value collection at any time. If more
	 * than one message (or error) key is currently true, then which message is shown is determined by the order of messages
	 * in the HTML template code (messages declared first are prioritised). This mechanism means the developer does not have
	 * to prioritise messages using custom JavaScript code.
	 *
	 * Given the following error object for our example (which informs us that the field `myField` currently has both the
	 * `required` and `email` errors):
	 *
	 * ```javascript
	 * <!-- keep in mind that ngModel automatically sets these error flags -->
	 * myField.$error = { required : true, email: true, maxlength: false };
	 * ```
	 * The `required` message will be displayed to the user since it appears before the `email` message in the DOM.
	 * Once the user types a single character, the `required` message will disappear (since the field now has a value)
	 * but the `email` message will be visible because it is still applicable.
	 *
	 * ### Displaying multiple messages at the same time
	 *
	 * While `ngMessages` will by default only display one error element at a time, the `ng-messages-multiple` attribute can
	 * be applied to the `ngMessages` container element to cause it to display all applicable error messages at once:
	 *
	 * ```html
	 * <!-- attribute-style usage -->
	 * <div ng-messages="myForm.myField.$error" ng-messages-multiple>...</div>
	 *
	 * <!-- element-style usage -->
	 * <ng-messages for="myForm.myField.$error" multiple>...</ng-messages>
	 * ```
	 *
	 * ## Reusing and Overriding Messages
	 * In addition to prioritization, ngMessages also allows for including messages from a remote or an inline
	 * template. This allows for generic collection of messages to be reused across multiple parts of an
	 * application.
	 *
	 * ```html
	 * <script type="text/ng-template" id="error-messages">
	 *   <div ng-message="required">This field is required</div>
	 *   <div ng-message="minlength">This field is too short</div>
	 * </script>
	 *
	 * <div ng-messages="myForm.myField.$error" role="alert">
	 *   <div ng-messages-include="error-messages"></div>
	 * </div>
	 * ```
	 *
	 * However, including generic messages may not be useful enough to match all input fields, therefore,
	 * `ngMessages` provides the ability to override messages defined in the remote template by redefining
	 * them within the directive container.
	 *
	 * ```html
	 * <!-- a generic template of error messages known as "my-custom-messages" -->
	 * <script type="text/ng-template" id="my-custom-messages">
	 *   <div ng-message="required">This field is required</div>
	 *   <div ng-message="minlength">This field is too short</div>
	 * </script>
	 *
	 * <form name="myForm">
	 *   <label>
	 *     Email address
	 *     <input type="email"
	 *            id="email"
	 *            name="myEmail"
	 *            ng-model="email"
	 *            minlength="5"
	 *            required />
	 *   </label>
	 *   <!-- any ng-message elements that appear BEFORE the ng-messages-include will
	 *        override the messages present in the ng-messages-include template -->
	 *   <div ng-messages="myForm.myEmail.$error" role="alert">
	 *     <!-- this required message has overridden the template message -->
	 *     <div ng-message="required">You did not enter your email address</div>
	 *
	 *     <!-- this is a brand new message and will appear last in the prioritization -->
	 *     <div ng-message="email">Your email address is invalid</div>
	 *
	 *     <!-- and here are the generic error messages -->
	 *     <div ng-messages-include="my-custom-messages"></div>
	 *   </div>
	 * </form>
	 * ```
	 *
	 * In the example HTML code above the message that is set on required will override the corresponding
	 * required message defined within the remote template. Therefore, with particular input fields (such
	 * email addresses, date fields, autocomplete inputs, etc...), specialized error messages can be applied
	 * while more generic messages can be used to handle other, more general input errors.
	 *
	 * ## Dynamic Messaging
	 * ngMessages also supports using expressions to dynamically change key values. Using arrays and
	 * repeaters to list messages is also supported. This means that the code below will be able to
	 * fully adapt itself and display the appropriate message when any of the expression data changes:
	 *
	 * ```html
	 * <form name="myForm">
	 *   <label>
	 *     Email address
	 *     <input type="email"
	 *            name="myEmail"
	 *            ng-model="email"
	 *            minlength="5"
	 *            required />
	 *   </label>
	 *   <div ng-messages="myForm.myEmail.$error" role="alert">
	 *     <div ng-message="required">You did not enter your email address</div>
	 *     <div ng-repeat="errorMessage in errorMessages">
	 *       <!-- use ng-message-exp for a message whose key is given by an expression -->
	 *       <div ng-message-exp="errorMessage.type">{{ errorMessage.text }}</div>
	 *     </div>
	 *   </div>
	 * </form>
	 * ```
	 *
	 * The `errorMessage.type` expression can be a string value or it can be an array so
	 * that multiple errors can be associated with a single error message:
	 *
	 * ```html
	 *   <label>
	 *     Email address
	 *     <input type="email"
	 *            ng-model="data.email"
	 *            name="myEmail"
	 *            ng-minlength="5"
	 *            ng-maxlength="100"
	 *            required />
	 *   </label>
	 *   <div ng-messages="myForm.myEmail.$error" role="alert">
	 *     <div ng-message-exp="'required'">You did not enter your email address</div>
	 *     <div ng-message-exp="['minlength', 'maxlength']">
	 *       Your email must be between 5 and 100 characters long
	 *     </div>
	 *   </div>
	 * ```
	 *
	 * Feel free to use other structural directives such as ng-if and ng-switch to further control
	 * what messages are active and when. Be careful, if you place ng-message on the same element
	 * as these structural directives, Angular may not be able to determine if a message is active
	 * or not. Therefore it is best to place the ng-message on a child element of the structural
	 * directive.
	 *
	 * ```html
	 * <div ng-messages="myForm.myEmail.$error" role="alert">
	 *   <div ng-if="showRequiredError">
	 *     <div ng-message="required">Please enter something</div>
	 *   </div>
	 * </div>
	 * ```
	 *
	 * ## Animations
	 * If the `ngAnimate` module is active within the application then the `ngMessages`, `ngMessage` and
	 * `ngMessageExp` directives will trigger animations whenever any messages are added and removed from
	 * the DOM by the `ngMessages` directive.
	 *
	 * Whenever the `ngMessages` directive contains one or more visible messages then the `.ng-active` CSS
	 * class will be added to the element. The `.ng-inactive` CSS class will be applied when there are no
	 * messages present. Therefore, CSS transitions and keyframes as well as JavaScript animations can
	 * hook into the animations whenever these classes are added/removed.
	 *
	 * Let's say that our HTML code for our messages container looks like so:
	 *
	 * ```html
	 * <div ng-messages="myMessages" class="my-messages" role="alert">
	 *   <div ng-message="alert" class="some-message">...</div>
	 *   <div ng-message="fail" class="some-message">...</div>
	 * </div>
	 * ```
	 *
	 * Then the CSS animation code for the message container looks like so:
	 *
	 * ```css
	 * .my-messages {
	 *   transition:1s linear all;
	 * }
	 * .my-messages.ng-active {
	 *   // messages are visible
	 * }
	 * .my-messages.ng-inactive {
	 *   // messages are hidden
	 * }
	 * ```
	 *
	 * Whenever an inner message is attached (becomes visible) or removed (becomes hidden) then the enter
	 * and leave animation is triggered for each particular element bound to the `ngMessage` directive.
	 *
	 * Therefore, the CSS code for the inner messages looks like so:
	 *
	 * ```css
	 * .some-message {
	 *   transition:1s linear all;
	 * }
	 *
	 * .some-message.ng-enter {}
	 * .some-message.ng-enter.ng-enter-active {}
	 *
	 * .some-message.ng-leave {}
	 * .some-message.ng-leave.ng-leave-active {}
	 * ```
	 *
	 * {@link ngAnimate Click here} to learn how to use JavaScript animations or to learn more about ngAnimate.
	 */
	angular.module('ngMessages', [])

	   /**
	    * @ngdoc directive
	    * @module ngMessages
	    * @name ngMessages
	    * @restrict AE
	    *
	    * @description
	    * `ngMessages` is a directive that is designed to show and hide messages based on the state
	    * of a key/value object that it listens on. The directive itself complements error message
	    * reporting with the `ngModel` $error object (which stores a key/value state of validation errors).
	    *
	    * `ngMessages` manages the state of internal messages within its container element. The internal
	    * messages use the `ngMessage` directive and will be inserted/removed from the page depending
	    * on if they're present within the key/value object. By default, only one message will be displayed
	    * at a time and this depends on the prioritization of the messages within the template. (This can
	    * be changed by using the `ng-messages-multiple` or `multiple` attribute on the directive container.)
	    *
	    * A remote template can also be used to promote message reusability and messages can also be
	    * overridden.
	    *
	    * {@link module:ngMessages Click here} to learn more about `ngMessages` and `ngMessage`.
	    *
	    * @usage
	    * ```html
	    * <!-- using attribute directives -->
	    * <ANY ng-messages="expression" role="alert">
	    *   <ANY ng-message="stringValue">...</ANY>
	    *   <ANY ng-message="stringValue1, stringValue2, ...">...</ANY>
	    *   <ANY ng-message-exp="expressionValue">...</ANY>
	    * </ANY>
	    *
	    * <!-- or by using element directives -->
	    * <ng-messages for="expression" role="alert">
	    *   <ng-message when="stringValue">...</ng-message>
	    *   <ng-message when="stringValue1, stringValue2, ...">...</ng-message>
	    *   <ng-message when-exp="expressionValue">...</ng-message>
	    * </ng-messages>
	    * ```
	    *
	    * @param {string} ngMessages an angular expression evaluating to a key/value object
	    *                 (this is typically the $error object on an ngModel instance).
	    * @param {string=} ngMessagesMultiple|multiple when set, all messages will be displayed with true
	    *
	    * @example
	    * <example name="ngMessages-directive" module="ngMessagesExample"
	    *          deps="angular-messages.js"
	    *          animations="true" fixBase="true">
	    *   <file name="index.html">
	    *     <form name="myForm">
	    *       <label>
	    *         Enter your name:
	    *         <input type="text"
	    *                name="myName"
	    *                ng-model="name"
	    *                ng-minlength="5"
	    *                ng-maxlength="20"
	    *                required />
	    *       </label>
	    *       <pre>myForm.myName.$error = {{ myForm.myName.$error | json }}</pre>
	    *
	    *       <div ng-messages="myForm.myName.$error" style="color:maroon" role="alert">
	    *         <div ng-message="required">You did not enter a field</div>
	    *         <div ng-message="minlength">Your field is too short</div>
	    *         <div ng-message="maxlength">Your field is too long</div>
	    *       </div>
	    *     </form>
	    *   </file>
	    *   <file name="script.js">
	    *     angular.module('ngMessagesExample', ['ngMessages']);
	    *   </file>
	    * </example>
	    */
	   .directive('ngMessages', ['$animate', function($animate) {
	     var ACTIVE_CLASS = 'ng-active';
	     var INACTIVE_CLASS = 'ng-inactive';

	     return {
	       require: 'ngMessages',
	       restrict: 'AE',
	       controller: ['$element', '$scope', '$attrs', function($element, $scope, $attrs) {
	         var ctrl = this;
	         var latestKey = 0;
	         var nextAttachId = 0;

	         this.getAttachId = function getAttachId() { return nextAttachId++; };

	         var messages = this.messages = {};
	         var renderLater, cachedCollection;

	         this.render = function(collection) {
	           collection = collection || {};

	           renderLater = false;
	           cachedCollection = collection;

	           // this is true if the attribute is empty or if the attribute value is truthy
	           var multiple = isAttrTruthy($scope, $attrs.ngMessagesMultiple) ||
	                          isAttrTruthy($scope, $attrs.multiple);

	           var unmatchedMessages = [];
	           var matchedKeys = {};
	           var messageItem = ctrl.head;
	           var messageFound = false;
	           var totalMessages = 0;

	           // we use != instead of !== to allow for both undefined and null values
	           while (messageItem != null) {
	             totalMessages++;
	             var messageCtrl = messageItem.message;

	             var messageUsed = false;
	             if (!messageFound) {
	               forEach(collection, function(value, key) {
	                 if (!messageUsed && truthy(value) && messageCtrl.test(key)) {
	                   // this is to prevent the same error name from showing up twice
	                   if (matchedKeys[key]) return;
	                   matchedKeys[key] = true;

	                   messageUsed = true;
	                   messageCtrl.attach();
	                 }
	               });
	             }

	             if (messageUsed) {
	               // unless we want to display multiple messages then we should
	               // set a flag here to avoid displaying the next message in the list
	               messageFound = !multiple;
	             } else {
	               unmatchedMessages.push(messageCtrl);
	             }

	             messageItem = messageItem.next;
	           }

	           forEach(unmatchedMessages, function(messageCtrl) {
	             messageCtrl.detach();
	           });

	           unmatchedMessages.length !== totalMessages
	              ? $animate.setClass($element, ACTIVE_CLASS, INACTIVE_CLASS)
	              : $animate.setClass($element, INACTIVE_CLASS, ACTIVE_CLASS);
	         };

	         $scope.$watchCollection($attrs.ngMessages || $attrs['for'], ctrl.render);

	         // If the element is destroyed, proactively destroy all the currently visible messages
	         $element.on('$destroy', function() {
	           forEach(messages, function(item) {
	             item.message.detach();
	           });
	         });

	         this.reRender = function() {
	           if (!renderLater) {
	             renderLater = true;
	             $scope.$evalAsync(function() {
	               if (renderLater) {
	                 cachedCollection && ctrl.render(cachedCollection);
	               }
	             });
	           }
	         };

	         this.register = function(comment, messageCtrl) {
	           var nextKey = latestKey.toString();
	           messages[nextKey] = {
	             message: messageCtrl
	           };
	           insertMessageNode($element[0], comment, nextKey);
	           comment.$$ngMessageNode = nextKey;
	           latestKey++;

	           ctrl.reRender();
	         };

	         this.deregister = function(comment) {
	           var key = comment.$$ngMessageNode;
	           delete comment.$$ngMessageNode;
	           removeMessageNode($element[0], comment, key);
	           delete messages[key];
	           ctrl.reRender();
	         };

	         function findPreviousMessage(parent, comment) {
	           var prevNode = comment;
	           var parentLookup = [];

	           while (prevNode && prevNode !== parent) {
	             var prevKey = prevNode.$$ngMessageNode;
	             if (prevKey && prevKey.length) {
	               return messages[prevKey];
	             }

	             // dive deeper into the DOM and examine its children for any ngMessage
	             // comments that may be in an element that appears deeper in the list
	             if (prevNode.childNodes.length && parentLookup.indexOf(prevNode) == -1) {
	               parentLookup.push(prevNode);
	               prevNode = prevNode.childNodes[prevNode.childNodes.length - 1];
	             } else if (prevNode.previousSibling) {
	               prevNode = prevNode.previousSibling;
	             } else {
	               prevNode = prevNode.parentNode;
	               parentLookup.push(prevNode);
	             }
	           }
	         }

	         function insertMessageNode(parent, comment, key) {
	           var messageNode = messages[key];
	           if (!ctrl.head) {
	             ctrl.head = messageNode;
	           } else {
	             var match = findPreviousMessage(parent, comment);
	             if (match) {
	               messageNode.next = match.next;
	               match.next = messageNode;
	             } else {
	               messageNode.next = ctrl.head;
	               ctrl.head = messageNode;
	             }
	           }
	         }

	         function removeMessageNode(parent, comment, key) {
	           var messageNode = messages[key];

	           var match = findPreviousMessage(parent, comment);
	           if (match) {
	             match.next = messageNode.next;
	           } else {
	             ctrl.head = messageNode.next;
	           }
	         }
	       }]
	     };

	     function isAttrTruthy(scope, attr) {
	      return (isString(attr) && attr.length === 0) || //empty attribute
	             truthy(scope.$eval(attr));
	     }

	     function truthy(val) {
	       return isString(val) ? val.length : !!val;
	     }
	   }])

	   /**
	    * @ngdoc directive
	    * @name ngMessagesInclude
	    * @restrict AE
	    * @scope
	    *
	    * @description
	    * `ngMessagesInclude` is a directive with the purpose to import existing ngMessage template
	    * code from a remote template and place the downloaded template code into the exact spot
	    * that the ngMessagesInclude directive is placed within the ngMessages container. This allows
	    * for a series of pre-defined messages to be reused and also allows for the developer to
	    * determine what messages are overridden due to the placement of the ngMessagesInclude directive.
	    *
	    * @usage
	    * ```html
	    * <!-- using attribute directives -->
	    * <ANY ng-messages="expression" role="alert">
	    *   <ANY ng-messages-include="remoteTplString">...</ANY>
	    * </ANY>
	    *
	    * <!-- or by using element directives -->
	    * <ng-messages for="expression" role="alert">
	    *   <ng-messages-include src="expressionValue1">...</ng-messages-include>
	    * </ng-messages>
	    * ```
	    *
	    * {@link module:ngMessages Click here} to learn more about `ngMessages` and `ngMessage`.
	    *
	    * @param {string} ngMessagesInclude|src a string value corresponding to the remote template.
	    */
	   .directive('ngMessagesInclude',
	     ['$templateRequest', '$document', '$compile', function($templateRequest, $document, $compile) {

	     return {
	       restrict: 'AE',
	       require: '^^ngMessages', // we only require this for validation sake
	       link: function($scope, element, attrs) {
	         var src = attrs.ngMessagesInclude || attrs.src;
	         $templateRequest(src).then(function(html) {
	           $compile(html)($scope, function(contents) {
	             element.after(contents);

	             // the anchor is placed for debugging purposes
	             var comment = $compile.$$createComment ?
	                 $compile.$$createComment('ngMessagesInclude', src) :
	                 $document[0].createComment(' ngMessagesInclude: ' + src + ' ');
	             var anchor = jqLite(comment);
	             element.after(anchor);

	             // we don't want to pollute the DOM anymore by keeping an empty directive element
	             element.remove();
	           });
	         });
	       }
	     };
	   }])

	   /**
	    * @ngdoc directive
	    * @name ngMessage
	    * @restrict AE
	    * @scope
	    *
	    * @description
	    * `ngMessage` is a directive with the purpose to show and hide a particular message.
	    * For `ngMessage` to operate, a parent `ngMessages` directive on a parent DOM element
	    * must be situated since it determines which messages are visible based on the state
	    * of the provided key/value map that `ngMessages` listens on.
	    *
	    * More information about using `ngMessage` can be found in the
	    * {@link module:ngMessages `ngMessages` module documentation}.
	    *
	    * @usage
	    * ```html
	    * <!-- using attribute directives -->
	    * <ANY ng-messages="expression" role="alert">
	    *   <ANY ng-message="stringValue">...</ANY>
	    *   <ANY ng-message="stringValue1, stringValue2, ...">...</ANY>
	    * </ANY>
	    *
	    * <!-- or by using element directives -->
	    * <ng-messages for="expression" role="alert">
	    *   <ng-message when="stringValue">...</ng-message>
	    *   <ng-message when="stringValue1, stringValue2, ...">...</ng-message>
	    * </ng-messages>
	    * ```
	    *
	    * @param {expression} ngMessage|when a string value corresponding to the message key.
	    */
	  .directive('ngMessage', ngMessageDirectiveFactory())


	   /**
	    * @ngdoc directive
	    * @name ngMessageExp
	    * @restrict AE
	    * @priority 1
	    * @scope
	    *
	    * @description
	    * `ngMessageExp` is a directive with the purpose to show and hide a particular message.
	    * For `ngMessageExp` to operate, a parent `ngMessages` directive on a parent DOM element
	    * must be situated since it determines which messages are visible based on the state
	    * of the provided key/value map that `ngMessages` listens on.
	    *
	    * @usage
	    * ```html
	    * <!-- using attribute directives -->
	    * <ANY ng-messages="expression">
	    *   <ANY ng-message-exp="expressionValue">...</ANY>
	    * </ANY>
	    *
	    * <!-- or by using element directives -->
	    * <ng-messages for="expression">
	    *   <ng-message when-exp="expressionValue">...</ng-message>
	    * </ng-messages>
	    * ```
	    *
	    * {@link module:ngMessages Click here} to learn more about `ngMessages` and `ngMessage`.
	    *
	    * @param {expression} ngMessageExp|whenExp an expression value corresponding to the message key.
	    */
	  .directive('ngMessageExp', ngMessageDirectiveFactory());

	function ngMessageDirectiveFactory() {
	  return ['$animate', function($animate) {
	    return {
	      restrict: 'AE',
	      transclude: 'element',
	      priority: 1, // must run before ngBind, otherwise the text is set on the comment
	      terminal: true,
	      require: '^^ngMessages',
	      link: function(scope, element, attrs, ngMessagesCtrl, $transclude) {
	        var commentNode = element[0];

	        var records;
	        var staticExp = attrs.ngMessage || attrs.when;
	        var dynamicExp = attrs.ngMessageExp || attrs.whenExp;
	        var assignRecords = function(items) {
	          records = items
	              ? (isArray(items)
	                    ? items
	                    : items.split(/[\s,]+/))
	              : null;
	          ngMessagesCtrl.reRender();
	        };

	        if (dynamicExp) {
	          assignRecords(scope.$eval(dynamicExp));
	          scope.$watchCollection(dynamicExp, assignRecords);
	        } else {
	          assignRecords(staticExp);
	        }

	        var currentElement, messageCtrl;
	        ngMessagesCtrl.register(commentNode, messageCtrl = {
	          test: function(name) {
	            return contains(records, name);
	          },
	          attach: function() {
	            if (!currentElement) {
	              $transclude(scope, function(elm) {
	                $animate.enter(elm, null, element);
	                currentElement = elm;

	                // Each time we attach this node to a message we get a new id that we can match
	                // when we are destroying the node later.
	                var $$attachId = currentElement.$$attachId = ngMessagesCtrl.getAttachId();

	                // in the event that the element or a parent element is destroyed
	                // by another structural directive then it's time
	                // to deregister the message from the controller
	                currentElement.on('$destroy', function() {
	                  if (currentElement && currentElement.$$attachId === $$attachId) {
	                    ngMessagesCtrl.deregister(commentNode);
	                    messageCtrl.detach();
	                  }
	                });
	              });
	            }
	          },
	          detach: function() {
	            if (currentElement) {
	              var elm = currentElement;
	              currentElement = null;
	              $animate.leave(elm);
	            }
	          }
	        });
	      }
	    };
	  }];

	  function contains(collection, key) {
	    if (collection) {
	      return isArray(collection)
	          ? collection.indexOf(key) >= 0
	          : collection.hasOwnProperty(key);
	    }
	  }
	}


	})(window, window.angular);


/***/ },
/* 27 */
/***/ function(module, exports) {

	angular.module('snap', []);

	(function() {
	  'use strict';
	  var version = [1, 8, 5]
	    , vObj = {
	        full: version.join('.'),
	        major: version[0],
	        minor: version[1],
	        patch: version[2]
	      };
	  angular.module('snap').constant('SNAP_VERSION', vObj);
	}());

	angular.module('snap')
	  .directive('snapClose', ['$rootScope', 'snapRemote', function($rootScope, snapRemote) {
	    'use strict';
	    return {
	      restrict: 'A',
	      link: function (scope, element, attrs) {
	        element.bind('click', function() {
	          // Wrap in anonymous function for easier testing
	          snapRemote.close(scope.$eval(attrs.snapId));
	          $rootScope.$digest();
	        });
	      }
	    };
	  }]);

	angular.module('snap')
	  .directive('snapContent', ['SnapConstructor', 'snapRemote', function (SnapConstructor, snapRemote) {
	    'use strict';
	    return {
	      restrict: 'AE',
	      link: function postLink(scope, element, attrs) {
	        element.addClass('snap-content');

	        var snapId = attrs.snapId;
	        if(!!snapId) {
	          snapId = scope.$eval(attrs.snapId);
	        }

	        var snapOptions = angular.extend({}, snapRemote.globalOptions);

	        var watchAttr = function(val, attr) {
	          scope.$watch(function() {
	            return scope.$eval(val);
	          }, function(newVal, oldVal) {
	            if(angular.isDefined(oldVal) && newVal !== oldVal) {
	              snapRemote.getSnapper(snapId).then(function(snapper) {
	                var settingsUpdate = {};
	                settingsUpdate[attr] = newVal;
	                snapper.settings(settingsUpdate);
	              });
	            }
	          });
	        };

	        // Get `snapOpt*` attrs, for now there is no *binding* going on here.
	        // We're just providing a more declarative way to set initial values.
	        angular.forEach(attrs, function(val, attr) {
	          if(attr.indexOf('snapOpt') === 0) {
	            attr = attr.substring(7);
	            if(attr.length) {
	              attr = attr[0].toLowerCase() + attr.substring(1);
	              snapOptions[attr] = scope.$eval(val);
	              watchAttr(val, attr);
	            }
	          }
	        });

	        // Always force the snap element to be the one this directive is
	        // attached to.
	        snapOptions.element = element[0];

	        // override snap options if some provided in snap-options attribute
	        if(angular.isDefined(attrs.snapOptions) && attrs.snapOptions) {
	          angular.extend(snapOptions, scope.$eval(attrs.snapOptions));
	        }

	        snapRemote.register(new SnapConstructor(snapOptions), snapId);

	        // watch snapOptions for updates
	        if(angular.isDefined(attrs.snapOptions) && attrs.snapOptions) {
	          scope.$watch(attrs.snapOptions, function(newSnapOptions) {
	            snapRemote.getSnapper(snapId).then(function(snapper) {
	              snapper.settings(newSnapOptions);
	            });
	          }, true);
	        }

	        scope.$on('$destroy', function() {
	          snapRemote.unregister(snapId);
	        });
	      }
	    };
	  }]);

	angular.module('snap')
	  .directive('snapDragger', ['snapRemote', function(snapRemote) {
	    'use strict';
	    return {
	      restrict: 'AE',
	      link: function(scope, element, attrs) {
	        var snapId = scope.$eval(attrs.snapId);
	        snapRemote.getSnapper(snapId).then(function(snapper) {
	          snapper.settings({
	            dragger: element[0]
	          });
	        });
	      }
	    };
	  }]);


	angular.module('snap')
	  .directive('snapDrawer', function () {
	    'use strict';
	    return {
	      restrict: 'AE',
	      link: function(scope, element, attrs) {
	        element.addClass('snap-drawer');

	        // Don't force a `snap-drawers` wrapper when we only want to use a
	        // single shelf
	        var parent = element.parent()
	          , needsDrawersWrapper = true;

	        if (attrs.snapDrawer === 'right') {
	          element.addClass('snap-drawer-right');
	        } else {
	          element.addClass('snap-drawer-left');
	        }

	        while(parent.length) {
	          if(parent.hasClass('snap-drawers')) {
	            needsDrawersWrapper = false;
	          }
	          parent = parent.parent();
	        }

	        if(needsDrawersWrapper) {
	          element.wrap('<div class="snap-drawers" />');
	        }

	      }
	    };
	  });

	angular.module('snap')
	  .directive('snapDrawers', function () {
	    'use strict';
	    return {
	      restrict: 'AE',
	      compile: function(element, attrs) {
	        element.addClass('snap-drawers');
	      }
	    };
	  });


	angular.module('snap')
	  .directive('snapToggle', ['$rootScope', 'snapRemote', function($rootScope, snapRemote) {
	      'use strict';
	      return {
	        restrict: 'A',
	        link: function (scope, element, attrs) {
	          var snapId = attrs.snapId
	            , snapSide = attrs.snapToggle || 'left';

	          if(!!snapId) {
	            snapId = scope.$eval(snapId);
	          }

	          /**
	           * Stifle mousedown and mouseup events by default
	           *
	           * See issue #61
	           *
	           * mousedown can create a race condition with the Snap.js `tapToClose`
	           * setting, the `tapToClose` handler runs first (if drawer is open)
	           * then our toggle handler runs. Depending on how far along in the
	           * close animation the drawer is when the toggle handler runs we may
	           * end up keeping the drawer open (i.e. a quick open/close) or *only*
	           * performing a double close.
	           *
	           * The situation is trickier because we want to allow mouseup events
	           * to flow through **if** the corresponding mousedown event did not
	           * target out toggle button... otherwise you could get stuck in a
	           * drag. We have a naive approach to preventing this... you can still
	           * get stuck in drag temporarily if you: mouse down on the toggle
	           * button, then mouse up off screen, then start a drag, then mouse
	           * down on the toggle button.
	           */
	          if(!attrs.snapUnsafe) {
	            var downOnMe = false;
	            element.bind('mousedown', function(event) {
	              downOnMe = true;
	              event.stopImmediatePropagation();
	            });

	            element.bind('mouseup', function(event) {
	              if(downOnMe) {
	                event.stopImmediatePropagation();
	              }
	              downOnMe = false;
	            });
	          }

	          element.bind('click', function() {
	            snapRemote.toggle(snapSide, snapId);
	            $rootScope.$digest();
	          });
	        }
	      };
	  }]);

	angular.module('snap')
	.provider('SnapConstructor', function() {
	  'use strict';
	  var constructor;

	  this.use = function(MySnap) {
	    constructor = MySnap;
	  };

	  this.$get = ['$window', function($window) {
	    var S = constructor || $window.Snap;
	    if(angular.isUndefined(S)) {
	      throw new Error('Snap constructor is not defined. Make sure ' +
	          'window.Snap is defined or supply your own with ' +
	          'SnapConstructorProvider.use(MySnap).');
	    }
	    return S;
	  }];
	});


	angular.module('snap')
	.provider('snapRemote', function SnapRemoteProvider() {
	  'use strict';

	  // Global Snap.js options
	  var self = this;
	  this.globalOptions = {};

	  this.$get = ['$q', function($q) {

	    var snapperStore = {}
	      , DEFAULT_SNAPPER_ID = '__DEFAULT_SNAPPER_ID__'
	      , exports = {}
	      , initStoreForId
	      , resolveInStoreById;

	    exports.globalOptions = self.globalOptions;

	    exports.getSnapper = function(id) {
	      id = id || DEFAULT_SNAPPER_ID;
	      if(!snapperStore.hasOwnProperty(id)) {
	        initStoreForId(id);
	      }
	      return snapperStore[id].deferred.promise;
	    };

	    exports.register = function(snapper, id) {
	      id = id || DEFAULT_SNAPPER_ID;
	      if(!snapperStore.hasOwnProperty(id)) {
	        initStoreForId(id);
	      }
	      if(snapperStore[id].isResolved) {
	        initStoreForId(id);
	      }
	      resolveInStoreById(snapper, id);
	    };

	    exports.unregister = function(id) {
	      id = id || DEFAULT_SNAPPER_ID;
	      if(snapperStore.hasOwnProperty(id)) {
	        delete snapperStore[id];
	      }
	    };

	    exports.toggle = function(side, id) {
	      id = id || DEFAULT_SNAPPER_ID;
	      exports.getSnapper(id).then(function(snapper) {
	        if(side === snapper.state().state) {
	          exports.close(id);
	        } else {
	          exports.open(side, id);
	        }
	      });
	    };

	    exports.open = function(side, id) {
	      id = id || DEFAULT_SNAPPER_ID;
	      exports.getSnapper(id).then(function(snapper) {
	        snapper.open(side);
	      });
	    };

	    exports.close = function(id) {
	      id = id || DEFAULT_SNAPPER_ID;
	      exports.getSnapper(id).then(function(snapper) {
	        snapper.close();
	      });
	    };

	    exports.expand = function(side, id) {
	      id = id || DEFAULT_SNAPPER_ID;
	      exports.getSnapper(id).then(function(snapper) {
	        snapper.expand(side);
	      });
	    };

	    exports.enable = function(id) {
	      id = id || DEFAULT_SNAPPER_ID;
	      exports.getSnapper(id).then(function(snapper) {
	        snapper.enable();
	      });
	    };

	    exports.disable = function(id) {
	      id = id || DEFAULT_SNAPPER_ID;
	      exports.getSnapper(id).then(function(snapper) {
	        snapper.disable();
	      });
	    };

	    initStoreForId = function(id) {
	      snapperStore[id] = {
	        deferred: $q.defer(),
	        isResolved: false
	      };
	    };

	    resolveInStoreById = function(snapper, id) {
	      snapperStore[id].deferred.resolve(snapper);
	      snapperStore[id].isResolved = true;
	    };

	    return exports;
	  }];

	  return this;
	});


/***/ },
/* 28 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	__webpack_require__(29);

	var copy = __webpack_require__(30); /**
	                                    * Created by rdollete on 4/1/16.
	                                    */


	var templateHome = __webpack_require__(93);
	var templateAbout = __webpack_require__(96);
	var templateWork = __webpack_require__(101);
	var templateWorkAnthem = __webpack_require__(102);
	var templateWorkWilsonX = __webpack_require__(104);
	var templateWorkSLS = __webpack_require__(105);
	var templateWorkXome = __webpack_require__(106);
	var templateWorkThinkThin = __webpack_require__(107);
	var templateWorkMens = __webpack_require__(108);
	var templateWorkSunny = __webpack_require__(109);
	var templateWorkCooper = __webpack_require__(110);
	var templateEntertainment = __webpack_require__(111);
	var templateCulture = __webpack_require__(112);
	var templateContact = __webpack_require__(121);
	var templateJobs = __webpack_require__(124);

	angular.module('phenoCom').config(function ($stateProvider, $urlRouterProvider, $sceDelegateProvider) {

	    $sceDelegateProvider.resourceUrlWhitelist(['self', 'http://tech.phenomenonstaging.com/**', 'https://player.vimeo.com/**', 'https://vimeo.com/**']);

	    // config routing
	    $urlRouterProvider.otherwise('/');

	    $stateProvider.state('home', {
	        url: '/',
	        template: templateHome,
	        data: {
	            pageTitle: 'PHENOMENON'
	        }
	    }).state('about', {
	        url: '/about',
	        template: templateAbout,
	        data: {
	            pageTitle: 'PHENOMENON'
	        }
	    }).state('work', {
	        url: '/work',
	        template: templateWork,
	        data: {
	            pageTitle: 'PHENOMENON - Wilson X case study'
	        }
	    }).state('work/wilson-anthem', {
	        url: '/work/wilson-anthem',
	        template: templateWorkAnthem,
	        data: {
	            pageTitle: 'PHENOMENON - Wilson Anthem case study'
	        }
	    }).state('work/wilson-x', {
	        url: '/work/wilson-x',
	        template: templateWorkWilsonX,
	        data: {
	            pageTitle: 'PHENOMENON - Wilson X case study'
	        }
	    }).state('work/xome', {
	        url: '/work/xome',
	        template: templateWorkXome,
	        data: {
	            pageTitle: 'PHENOMENON - Xome case study'
	        }
	    }).state('work/mens-wearhouse', {
	        url: '/work/mens-wearhouse',
	        template: templateWorkMens,
	        data: {
	            pageTitle: 'PHENOMENON - Wilson Anthem case study'
	        }
	    }).state('work/think-thin', {
	        url: '/work/think-thin',
	        template: templateWorkThinkThin,
	        data: {
	            pageTitle: 'PHENOMENON - Think Thin case study'
	        }
	    }).state('work/sls', {
	        url: '/work/sls',
	        template: templateWorkSLS,
	        data: {
	            pageTitle: 'PHENOMENON - SLS case study'
	        }
	    }).state('work/sunny', {
	        url: '/work/sunny',
	        template: templateWorkSunny,
	        data: {
	            pageTitle: 'PHENOMENON - Sunny case study'
	        }
	    }).state('work/cooper', {
	        url: '/work/cooper',
	        template: templateWorkCooper,
	        data: {
	            pageTitle: 'PHENOMENON - Mr.Cooper case study'
	        }
	    }).state('entertainment', {
	        url: '/entertainment',
	        template: templateEntertainment,
	        data: {
	            pageTitle: 'PHENOMENON - Wilson Anthem case study'
	        }
	    }).state('culture', {
	        url: '/culture',
	        template: templateCulture,
	        data: {
	            pageTitle: 'PHENOMENON - Xome case study'
	        }
	    }).state('think-thin', {
	        url: '/think-thin',
	        templateUrl: '/views/think-thin',
	        data: {
	            pageTitle: 'PHENOMENON - thinkThin case study'
	        }
	    }).state('jobs', {
	        url: '/jobs',
	        template: templateJobs,
	        data: {
	            pageTitle: 'PHENOMENON - Jobs'
	        }
	    }).state('contact', {
	        url: '/contact',
	        template: templateContact,
	        controller: 'contactController',
	        data: {
	            pageTitle: 'PHENOMENON - Contact Us'
	        }
	    }).state('thanks', {
	        url: '/thanks',
	        templateUrl: '/views/components/thanks',
	        data: {
	            pageTitle: 'PHENOMENON - Thanks'
	        }
	    });
	});

/***/ },
/* 29 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(jQuery) {/*
	 *  jQuery OwlCarousel v1.3.3
	 *
	 *  Copyright (c) 2013 Bartosz Wojciechowski
	 *  http://www.owlgraphic.com/owlcarousel/
	 *
	 *  Licensed under MIT
	 *
	 */

	/*JS Lint helpers: */
	/*global dragMove: false, dragEnd: false, $, jQuery, alert, window, document */
	/*jslint nomen: true, continue:true */

	if (typeof Object.create !== "function") {
	    Object.create = function (obj) {
	        function F() {}
	        F.prototype = obj;
	        return new F();
	    };
	}
	(function ($, window, document) {

	    var Carousel = {
	        init : function (options, el) {
	            var base = this;

	            base.$elem = $(el);
	            base.options = $.extend({}, $.fn.owlCarousel.options, base.$elem.data(), options);

	            base.userOptions = options;
	            base.loadContent();
	        },

	        loadContent : function () {
	            var base = this, url;

	            function getData(data) {
	                var i, content = "";
	                if (typeof base.options.jsonSuccess === "function") {
	                    base.options.jsonSuccess.apply(this, [data]);
	                } else {
	                    for (i in data.owl) {
	                        if (data.owl.hasOwnProperty(i)) {
	                            content += data.owl[i].item;
	                        }
	                    }
	                    base.$elem.html(content);
	                }
	                base.logIn();
	            }

	            if (typeof base.options.beforeInit === "function") {
	                base.options.beforeInit.apply(this, [base.$elem]);
	            }

	            if (typeof base.options.jsonPath === "string") {
	                url = base.options.jsonPath;
	                $.getJSON(url, getData);
	            } else {
	                base.logIn();
	            }
	        },

	        logIn : function () {
	            var base = this;

	            base.$elem.data({
	                "owl-originalStyles": base.$elem.attr("style"),
	                "owl-originalClasses": base.$elem.attr("class")
	            });

	            base.$elem.css({opacity: 0});
	            base.orignalItems = base.options.items;
	            base.checkBrowser();
	            base.wrapperWidth = 0;
	            base.checkVisible = null;
	            base.setVars();
	        },

	        setVars : function () {
	            var base = this;
	            if (base.$elem.children().length === 0) {return false; }
	            base.baseClass();
	            base.eventTypes();
	            base.$userItems = base.$elem.children();
	            base.itemsAmount = base.$userItems.length;
	            base.wrapItems();
	            base.$owlItems = base.$elem.find(".owl-item");
	            base.$owlWrapper = base.$elem.find(".owl-wrapper");
	            base.playDirection = "next";
	            base.prevItem = 0;
	            base.prevArr = [0];
	            base.currentItem = 0;
	            base.customEvents();
	            base.onStartup();
	        },

	        onStartup : function () {
	            var base = this;
	            base.updateItems();
	            base.calculateAll();
	            base.buildControls();
	            base.updateControls();
	            base.response();
	            base.moveEvents();
	            base.stopOnHover();
	            base.owlStatus();

	            if (base.options.transitionStyle !== false) {
	                base.transitionTypes(base.options.transitionStyle);
	            }
	            if (base.options.autoPlay === true) {
	                base.options.autoPlay = 5000;
	            }
	            base.play();

	            base.$elem.find(".owl-wrapper").css("display", "block");

	            if (!base.$elem.is(":visible")) {
	                base.watchVisibility();
	            } else {
	                base.$elem.css("opacity", 1);
	            }
	            base.onstartup = false;
	            base.eachMoveUpdate();
	            if (typeof base.options.afterInit === "function") {
	                base.options.afterInit.apply(this, [base.$elem]);
	            }
	        },

	        eachMoveUpdate : function () {
	            var base = this;

	            if (base.options.lazyLoad === true) {
	                base.lazyLoad();
	            }
	            if (base.options.autoHeight === true) {
	                base.autoHeight();
	            }
	            base.onVisibleItems();

	            if (typeof base.options.afterAction === "function") {
	                base.options.afterAction.apply(this, [base.$elem]);
	            }
	        },

	        updateVars : function () {
	            var base = this;
	            if (typeof base.options.beforeUpdate === "function") {
	                base.options.beforeUpdate.apply(this, [base.$elem]);
	            }
	            base.watchVisibility();
	            base.updateItems();
	            base.calculateAll();
	            base.updatePosition();
	            base.updateControls();
	            base.eachMoveUpdate();
	            if (typeof base.options.afterUpdate === "function") {
	                base.options.afterUpdate.apply(this, [base.$elem]);
	            }
	        },

	        reload : function () {
	            var base = this;
	            window.setTimeout(function () {
	                base.updateVars();
	            }, 0);
	        },

	        watchVisibility : function () {
	            var base = this;

	            if (base.$elem.is(":visible") === false) {
	                base.$elem.css({opacity: 0});
	                window.clearInterval(base.autoPlayInterval);
	                window.clearInterval(base.checkVisible);
	            } else {
	                return false;
	            }
	            base.checkVisible = window.setInterval(function () {
	                if (base.$elem.is(":visible")) {
	                    base.reload();
	                    base.$elem.animate({opacity: 1}, 200);
	                    window.clearInterval(base.checkVisible);
	                }
	            }, 500);
	        },

	        wrapItems : function () {
	            var base = this;
	            base.$userItems.wrapAll("<div class=\"owl-wrapper\">").wrap("<div class=\"owl-item\"></div>");
	            base.$elem.find(".owl-wrapper").wrap("<div class=\"owl-wrapper-outer\">");
	            base.wrapperOuter = base.$elem.find(".owl-wrapper-outer");
	            base.$elem.css("display", "block");
	        },

	        baseClass : function () {
	            var base = this,
	                hasBaseClass = base.$elem.hasClass(base.options.baseClass),
	                hasThemeClass = base.$elem.hasClass(base.options.theme);

	            if (!hasBaseClass) {
	                base.$elem.addClass(base.options.baseClass);
	            }

	            if (!hasThemeClass) {
	                base.$elem.addClass(base.options.theme);
	            }
	        },

	        updateItems : function () {
	            var base = this, width, i;

	            if (base.options.responsive === false) {
	                return false;
	            }
	            if (base.options.singleItem === true) {
	                base.options.items = base.orignalItems = 1;
	                base.options.itemsCustom = false;
	                base.options.itemsDesktop = false;
	                base.options.itemsDesktopSmall = false;
	                base.options.itemsTablet = false;
	                base.options.itemsTabletSmall = false;
	                base.options.itemsMobile = false;
	                return false;
	            }

	            width = $(base.options.responsiveBaseWidth).width();

	            if (width > (base.options.itemsDesktop[0] || base.orignalItems)) {
	                base.options.items = base.orignalItems;
	            }
	            if (base.options.itemsCustom !== false) {
	                //Reorder array by screen size
	                base.options.itemsCustom.sort(function (a, b) {return a[0] - b[0]; });

	                for (i = 0; i < base.options.itemsCustom.length; i += 1) {
	                    if (base.options.itemsCustom[i][0] <= width) {
	                        base.options.items = base.options.itemsCustom[i][1];
	                    }
	                }

	            } else {

	                if (width <= base.options.itemsDesktop[0] && base.options.itemsDesktop !== false) {
	                    base.options.items = base.options.itemsDesktop[1];
	                }

	                if (width <= base.options.itemsDesktopSmall[0] && base.options.itemsDesktopSmall !== false) {
	                    base.options.items = base.options.itemsDesktopSmall[1];
	                }

	                if (width <= base.options.itemsTablet[0] && base.options.itemsTablet !== false) {
	                    base.options.items = base.options.itemsTablet[1];
	                }

	                if (width <= base.options.itemsTabletSmall[0] && base.options.itemsTabletSmall !== false) {
	                    base.options.items = base.options.itemsTabletSmall[1];
	                }

	                if (width <= base.options.itemsMobile[0] && base.options.itemsMobile !== false) {
	                    base.options.items = base.options.itemsMobile[1];
	                }
	            }

	            //if number of items is less than declared
	            if (base.options.items > base.itemsAmount && base.options.itemsScaleUp === true) {
	                base.options.items = base.itemsAmount;
	            }
	        },

	        response : function () {
	            var base = this,
	                smallDelay,
	                lastWindowWidth;

	            if (base.options.responsive !== true) {
	                return false;
	            }
	            lastWindowWidth = $(window).width();

	            base.resizer = function () {
	                if ($(window).width() !== lastWindowWidth) {
	                    if (base.options.autoPlay !== false) {
	                        window.clearInterval(base.autoPlayInterval);
	                    }
	                    window.clearTimeout(smallDelay);
	                    smallDelay = window.setTimeout(function () {
	                        lastWindowWidth = $(window).width();
	                        base.updateVars();
	                    }, base.options.responsiveRefreshRate);
	                }
	            };
	            $(window).resize(base.resizer);
	        },

	        updatePosition : function () {
	            var base = this;
	            base.jumpTo(base.currentItem);
	            if (base.options.autoPlay !== false) {
	                base.checkAp();
	            }
	        },

	        appendItemsSizes : function () {
	            var base = this,
	                roundPages = 0,
	                lastItem = base.itemsAmount - base.options.items;

	            base.$owlItems.each(function (index) {
	                var $this = $(this);
	                $this
	                    .css({"width": base.itemWidth})
	                    .data("owl-item", Number(index));

	                if (index % base.options.items === 0 || index === lastItem) {
	                    if (!(index > lastItem)) {
	                        roundPages += 1;
	                    }
	                }
	                $this.data("owl-roundPages", roundPages);
	            });
	        },

	        appendWrapperSizes : function () {
	            var base = this,
	                width = base.$owlItems.length * base.itemWidth;

	            base.$owlWrapper.css({
	                "width": width * 2,
	                "left": 0
	            });
	            base.appendItemsSizes();
	        },

	        calculateAll : function () {
	            var base = this;
	            base.calculateWidth();
	            base.appendWrapperSizes();
	            base.loops();
	            base.max();
	        },

	        calculateWidth : function () {
	            var base = this;
	            base.itemWidth = Math.round(base.$elem.width() / base.options.items);
	        },

	        max : function () {
	            var base = this,
	                maximum = ((base.itemsAmount * base.itemWidth) - base.options.items * base.itemWidth) * -1;
	            if (base.options.items > base.itemsAmount) {
	                base.maximumItem = 0;
	                maximum = 0;
	                base.maximumPixels = 0;
	            } else {
	                base.maximumItem = base.itemsAmount - base.options.items;
	                base.maximumPixels = maximum;
	            }
	            return maximum;
	        },

	        min : function () {
	            return 0;
	        },

	        loops : function () {
	            var base = this,
	                prev = 0,
	                elWidth = 0,
	                i,
	                item,
	                roundPageNum;

	            base.positionsInArray = [0];
	            base.pagesInArray = [];

	            for (i = 0; i < base.itemsAmount; i += 1) {
	                elWidth += base.itemWidth;
	                base.positionsInArray.push(-elWidth);

	                if (base.options.scrollPerPage === true) {
	                    item = $(base.$owlItems[i]);
	                    roundPageNum = item.data("owl-roundPages");
	                    if (roundPageNum !== prev) {
	                        base.pagesInArray[prev] = base.positionsInArray[i];
	                        prev = roundPageNum;
	                    }
	                }
	            }
	        },

	        buildControls : function () {
	            var base = this;
	            if (base.options.navigation === true || base.options.pagination === true) {
	                base.owlControls = $("<div class=\"owl-controls\"/>").toggleClass("clickable", !base.browser.isTouch).appendTo(base.$elem);
	            }
	            if (base.options.pagination === true) {
	                base.buildPagination();
	            }
	            if (base.options.navigation === true) {
	                base.buildButtons();
	            }
	        },

	        buildButtons : function () {
	            var base = this,
	                buttonsWrapper = $("<div class=\"owl-buttons\"/>");
	            base.owlControls.append(buttonsWrapper);

	            base.buttonPrev = $("<div/>", {
	                "class" : "owl-prev",
	                "html" : base.options.navigationText[0] || ""
	            });

	            base.buttonNext = $("<div/>", {
	                "class" : "owl-next",
	                "html" : base.options.navigationText[1] || ""
	            });

	            buttonsWrapper
	                .append(base.buttonPrev)
	                .append(base.buttonNext);

	            buttonsWrapper.on("touchstart.owlControls mousedown.owlControls", "div[class^=\"owl\"]", function (event) {
	                event.preventDefault();
	            });

	            buttonsWrapper.on("touchend.owlControls mouseup.owlControls", "div[class^=\"owl\"]", function (event) {
	                event.preventDefault();
	                if ($(this).hasClass("owl-next")) {
	                    base.next();
	                } else {
	                    base.prev();
	                }
	            });
	        },

	        buildPagination : function () {
	            var base = this;

	            base.paginationWrapper = $("<div class=\"owl-pagination\"/>");
	            base.owlControls.append(base.paginationWrapper);

	            base.paginationWrapper.on("touchend.owlControls mouseup.owlControls", ".owl-page", function (event) {
	                event.preventDefault();
	                if (Number($(this).data("owl-page")) !== base.currentItem) {
	                    base.goTo(Number($(this).data("owl-page")), true);
	                }
	            });
	        },

	        updatePagination : function () {
	            var base = this,
	                counter,
	                lastPage,
	                lastItem,
	                i,
	                paginationButton,
	                paginationButtonInner;

	            if (base.options.pagination === false) {
	                return false;
	            }

	            base.paginationWrapper.html("");

	            counter = 0;
	            lastPage = base.itemsAmount - base.itemsAmount % base.options.items;

	            for (i = 0; i < base.itemsAmount; i += 1) {
	                if (i % base.options.items === 0) {
	                    counter += 1;
	                    if (lastPage === i) {
	                        lastItem = base.itemsAmount - base.options.items;
	                    }
	                    paginationButton = $("<div/>", {
	                        "class" : "owl-page"
	                    });
	                    paginationButtonInner = $("<span></span>", {
	                        "text": base.options.paginationNumbers === true ? counter : "",
	                        "class": base.options.paginationNumbers === true ? "owl-numbers" : ""
	                    });
	                    paginationButton.append(paginationButtonInner);

	                    paginationButton.data("owl-page", lastPage === i ? lastItem : i);
	                    paginationButton.data("owl-roundPages", counter);

	                    base.paginationWrapper.append(paginationButton);
	                }
	            }
	            base.checkPagination();
	        },
	        checkPagination : function () {
	            var base = this;
	            if (base.options.pagination === false) {
	                return false;
	            }
	            base.paginationWrapper.find(".owl-page").each(function () {
	                if ($(this).data("owl-roundPages") === $(base.$owlItems[base.currentItem]).data("owl-roundPages")) {
	                    base.paginationWrapper
	                        .find(".owl-page")
	                        .removeClass("active");
	                    $(this).addClass("active");
	                }
	            });
	        },

	        checkNavigation : function () {
	            var base = this;

	            if (base.options.navigation === false) {
	                return false;
	            }
	            if (base.options.rewindNav === false) {
	                if (base.currentItem === 0 && base.maximumItem === 0) {
	                    base.buttonPrev.addClass("disabled");
	                    base.buttonNext.addClass("disabled");
	                } else if (base.currentItem === 0 && base.maximumItem !== 0) {
	                    base.buttonPrev.addClass("disabled");
	                    base.buttonNext.removeClass("disabled");
	                } else if (base.currentItem === base.maximumItem) {
	                    base.buttonPrev.removeClass("disabled");
	                    base.buttonNext.addClass("disabled");
	                } else if (base.currentItem !== 0 && base.currentItem !== base.maximumItem) {
	                    base.buttonPrev.removeClass("disabled");
	                    base.buttonNext.removeClass("disabled");
	                }
	            }
	        },

	        updateControls : function () {
	            var base = this;
	            base.updatePagination();
	            base.checkNavigation();
	            if (base.owlControls) {
	                if (base.options.items >= base.itemsAmount) {
	                    base.owlControls.hide();
	                } else {
	                    base.owlControls.show();
	                }
	            }
	        },

	        destroyControls : function () {
	            var base = this;
	            if (base.owlControls) {
	                base.owlControls.remove();
	            }
	        },

	        next : function (speed) {
	            var base = this;

	            if (base.isTransition) {
	                return false;
	            }

	            base.currentItem += base.options.scrollPerPage === true ? base.options.items : 1;
	            if (base.currentItem > base.maximumItem + (base.options.scrollPerPage === true ? (base.options.items - 1) : 0)) {
	                if (base.options.rewindNav === true) {
	                    base.currentItem = 0;
	                    speed = "rewind";
	                } else {
	                    base.currentItem = base.maximumItem;
	                    return false;
	                }
	            }
	            base.goTo(base.currentItem, speed);
	        },

	        prev : function (speed) {
	            var base = this;

	            if (base.isTransition) {
	                return false;
	            }

	            if (base.options.scrollPerPage === true && base.currentItem > 0 && base.currentItem < base.options.items) {
	                base.currentItem = 0;
	            } else {
	                base.currentItem -= base.options.scrollPerPage === true ? base.options.items : 1;
	            }
	            if (base.currentItem < 0) {
	                if (base.options.rewindNav === true) {
	                    base.currentItem = base.maximumItem;
	                    speed = "rewind";
	                } else {
	                    base.currentItem = 0;
	                    return false;
	                }
	            }
	            base.goTo(base.currentItem, speed);
	        },

	        goTo : function (position, speed, drag) {
	            var base = this,
	                goToPixel;

	            if (base.isTransition) {
	                return false;
	            }
	            if (typeof base.options.beforeMove === "function") {
	                base.options.beforeMove.apply(this, [base.$elem]);
	            }
	            if (position >= base.maximumItem) {
	                position = base.maximumItem;
	            } else if (position <= 0) {
	                position = 0;
	            }

	            base.currentItem = base.owl.currentItem = position;
	            if (base.options.transitionStyle !== false && drag !== "drag" && base.options.items === 1 && base.browser.support3d === true) {
	                base.swapSpeed(0);
	                if (base.browser.support3d === true) {
	                    base.transition3d(base.positionsInArray[position]);
	                } else {
	                    base.css2slide(base.positionsInArray[position], 1);
	                }
	                base.afterGo();
	                base.singleItemTransition();
	                return false;
	            }
	            goToPixel = base.positionsInArray[position];

	            if (base.browser.support3d === true) {
	                base.isCss3Finish = false;

	                if (speed === true) {
	                    base.swapSpeed("paginationSpeed");
	                    window.setTimeout(function () {
	                        base.isCss3Finish = true;
	                    }, base.options.paginationSpeed);

	                } else if (speed === "rewind") {
	                    base.swapSpeed(base.options.rewindSpeed);
	                    window.setTimeout(function () {
	                        base.isCss3Finish = true;
	                    }, base.options.rewindSpeed);

	                } else {
	                    base.swapSpeed("slideSpeed");
	                    window.setTimeout(function () {
	                        base.isCss3Finish = true;
	                    }, base.options.slideSpeed);
	                }
	                base.transition3d(goToPixel);
	            } else {
	                if (speed === true) {
	                    base.css2slide(goToPixel, base.options.paginationSpeed);
	                } else if (speed === "rewind") {
	                    base.css2slide(goToPixel, base.options.rewindSpeed);
	                } else {
	                    base.css2slide(goToPixel, base.options.slideSpeed);
	                }
	            }
	            base.afterGo();
	        },

	        jumpTo : function (position) {
	            var base = this;
	            if (typeof base.options.beforeMove === "function") {
	                base.options.beforeMove.apply(this, [base.$elem]);
	            }
	            if (position >= base.maximumItem || position === -1) {
	                position = base.maximumItem;
	            } else if (position <= 0) {
	                position = 0;
	            }
	            base.swapSpeed(0);
	            if (base.browser.support3d === true) {
	                base.transition3d(base.positionsInArray[position]);
	            } else {
	                base.css2slide(base.positionsInArray[position], 1);
	            }
	            base.currentItem = base.owl.currentItem = position;
	            base.afterGo();
	        },

	        afterGo : function () {
	            var base = this;

	            base.prevArr.push(base.currentItem);
	            base.prevItem = base.owl.prevItem = base.prevArr[base.prevArr.length - 2];
	            base.prevArr.shift(0);

	            if (base.prevItem !== base.currentItem) {
	                base.checkPagination();
	                base.checkNavigation();
	                base.eachMoveUpdate();

	                if (base.options.autoPlay !== false) {
	                    base.checkAp();
	                }
	            }
	            if (typeof base.options.afterMove === "function" && base.prevItem !== base.currentItem) {
	                base.options.afterMove.apply(this, [base.$elem]);
	            }
	        },

	        stop : function () {
	            var base = this;
	            base.apStatus = "stop";
	            window.clearInterval(base.autoPlayInterval);
	        },

	        checkAp : function () {
	            var base = this;
	            if (base.apStatus !== "stop") {
	                base.play();
	            }
	        },

	        play : function () {
	            var base = this;
	            base.apStatus = "play";
	            if (base.options.autoPlay === false) {
	                return false;
	            }
	            window.clearInterval(base.autoPlayInterval);
	            base.autoPlayInterval = window.setInterval(function () {
	                base.next(true);
	            }, base.options.autoPlay);
	        },

	        swapSpeed : function (action) {
	            var base = this;
	            if (action === "slideSpeed") {
	                base.$owlWrapper.css(base.addCssSpeed(base.options.slideSpeed));
	            } else if (action === "paginationSpeed") {
	                base.$owlWrapper.css(base.addCssSpeed(base.options.paginationSpeed));
	            } else if (typeof action !== "string") {
	                base.$owlWrapper.css(base.addCssSpeed(action));
	            }
	        },

	        addCssSpeed : function (speed) {
	            return {
	                "-webkit-transition": "all " + speed + "ms ease",
	                "-moz-transition": "all " + speed + "ms ease",
	                "-o-transition": "all " + speed + "ms ease",
	                "transition": "all " + speed + "ms ease"
	            };
	        },

	        removeTransition : function () {
	            return {
	                "-webkit-transition": "",
	                "-moz-transition": "",
	                "-o-transition": "",
	                "transition": ""
	            };
	        },

	        doTranslate : function (pixels) {
	            return {
	                "-webkit-transform": "translate3d(" + pixels + "px, 0px, 0px)",
	                "-moz-transform": "translate3d(" + pixels + "px, 0px, 0px)",
	                "-o-transform": "translate3d(" + pixels + "px, 0px, 0px)",
	                "-ms-transform": "translate3d(" + pixels + "px, 0px, 0px)",
	                "transform": "translate3d(" + pixels + "px, 0px,0px)"
	            };
	        },

	        transition3d : function (value) {
	            var base = this;
	            base.$owlWrapper.css(base.doTranslate(value));
	        },

	        css2move : function (value) {
	            var base = this;
	            base.$owlWrapper.css({"left" : value});
	        },

	        css2slide : function (value, speed) {
	            var base = this;

	            base.isCssFinish = false;
	            base.$owlWrapper.stop(true, true).animate({
	                "left" : value
	            }, {
	                duration : speed || base.options.slideSpeed,
	                complete : function () {
	                    base.isCssFinish = true;
	                }
	            });
	        },

	        checkBrowser : function () {
	            var base = this,
	                translate3D = "translate3d(0px, 0px, 0px)",
	                tempElem = document.createElement("div"),
	                regex,
	                asSupport,
	                support3d,
	                isTouch;

	            tempElem.style.cssText = "  -moz-transform:" + translate3D +
	                                  "; -ms-transform:"     + translate3D +
	                                  "; -o-transform:"      + translate3D +
	                                  "; -webkit-transform:" + translate3D +
	                                  "; transform:"         + translate3D;
	            regex = /translate3d\(0px, 0px, 0px\)/g;
	            asSupport = tempElem.style.cssText.match(regex);
	            support3d = (asSupport !== null && asSupport.length === 1);

	            isTouch = "ontouchstart" in window || window.navigator.msMaxTouchPoints;

	            base.browser = {
	                "support3d" : support3d,
	                "isTouch" : isTouch
	            };
	        },

	        moveEvents : function () {
	            var base = this;
	            if (base.options.mouseDrag !== false || base.options.touchDrag !== false) {
	                base.gestures();
	                base.disabledEvents();
	            }
	        },

	        eventTypes : function () {
	            var base = this,
	                types = ["s", "e", "x"];

	            base.ev_types = {};

	            if (base.options.mouseDrag === true && base.options.touchDrag === true) {
	                types = [
	                    "touchstart.owl mousedown.owl",
	                    "touchmove.owl mousemove.owl",
	                    "touchend.owl touchcancel.owl mouseup.owl"
	                ];
	            } else if (base.options.mouseDrag === false && base.options.touchDrag === true) {
	                types = [
	                    "touchstart.owl",
	                    "touchmove.owl",
	                    "touchend.owl touchcancel.owl"
	                ];
	            } else if (base.options.mouseDrag === true && base.options.touchDrag === false) {
	                types = [
	                    "mousedown.owl",
	                    "mousemove.owl",
	                    "mouseup.owl"
	                ];
	            }

	            base.ev_types.start = types[0];
	            base.ev_types.move = types[1];
	            base.ev_types.end = types[2];
	        },

	        disabledEvents :  function () {
	            var base = this;
	            base.$elem.on("dragstart.owl", function (event) { event.preventDefault(); });
	            base.$elem.on("mousedown.disableTextSelect", function (e) {
	                return $(e.target).is('input, textarea, select, option');
	            });
	        },

	        gestures : function () {
	            /*jslint unparam: true*/
	            var base = this,
	                locals = {
	                    offsetX : 0,
	                    offsetY : 0,
	                    baseElWidth : 0,
	                    relativePos : 0,
	                    position: null,
	                    minSwipe : null,
	                    maxSwipe: null,
	                    sliding : null,
	                    dargging: null,
	                    targetElement : null
	                };

	            base.isCssFinish = true;

	            function getTouches(event) {
	                if (event.touches !== undefined) {
	                    return {
	                        x : event.touches[0].pageX,
	                        y : event.touches[0].pageY
	                    };
	                }

	                if (event.touches === undefined) {
	                    if (event.pageX !== undefined) {
	                        return {
	                            x : event.pageX,
	                            y : event.pageY
	                        };
	                    }
	                    if (event.pageX === undefined) {
	                        return {
	                            x : event.clientX,
	                            y : event.clientY
	                        };
	                    }
	                }
	            }

	            function swapEvents(type) {
	                if (type === "on") {
	                    $(document).on(base.ev_types.move, dragMove);
	                    $(document).on(base.ev_types.end, dragEnd);
	                } else if (type === "off") {
	                    $(document).off(base.ev_types.move);
	                    $(document).off(base.ev_types.end);
	                }
	            }

	            function dragStart(event) {
	                var ev = event.originalEvent || event || window.event,
	                    position;

	                if (ev.which === 3) {
	                    return false;
	                }
	                if (base.itemsAmount <= base.options.items) {
	                    return;
	                }
	                if (base.isCssFinish === false && !base.options.dragBeforeAnimFinish) {
	                    return false;
	                }
	                if (base.isCss3Finish === false && !base.options.dragBeforeAnimFinish) {
	                    return false;
	                }

	                if (base.options.autoPlay !== false) {
	                    window.clearInterval(base.autoPlayInterval);
	                }

	                if (base.browser.isTouch !== true && !base.$owlWrapper.hasClass("grabbing")) {
	                    base.$owlWrapper.addClass("grabbing");
	                }

	                base.newPosX = 0;
	                base.newRelativeX = 0;

	                $(this).css(base.removeTransition());

	                position = $(this).position();
	                locals.relativePos = position.left;

	                locals.offsetX = getTouches(ev).x - position.left;
	                locals.offsetY = getTouches(ev).y - position.top;

	                swapEvents("on");

	                locals.sliding = false;
	                locals.targetElement = ev.target || ev.srcElement;
	            }

	            function dragMove(event) {
	                var ev = event.originalEvent || event || window.event,
	                    minSwipe,
	                    maxSwipe;

	                base.newPosX = getTouches(ev).x - locals.offsetX;
	                base.newPosY = getTouches(ev).y - locals.offsetY;
	                base.newRelativeX = base.newPosX - locals.relativePos;

	                if (typeof base.options.startDragging === "function" && locals.dragging !== true && base.newRelativeX !== 0) {
	                    locals.dragging = true;
	                    base.options.startDragging.apply(base, [base.$elem]);
	                }

	                if ((base.newRelativeX > 8 || base.newRelativeX < -8) && (base.browser.isTouch === true)) {
	                    if (ev.preventDefault !== undefined) {
	                        ev.preventDefault();
	                    } else {
	                        ev.returnValue = false;
	                    }
	                    locals.sliding = true;
	                }

	                if ((base.newPosY > 10 || base.newPosY < -10) && locals.sliding === false) {
	                    $(document).off("touchmove.owl");
	                }

	                minSwipe = function () {
	                    return base.newRelativeX / 5;
	                };

	                maxSwipe = function () {
	                    return base.maximumPixels + base.newRelativeX / 5;
	                };

	                base.newPosX = Math.max(Math.min(base.newPosX, minSwipe()), maxSwipe());
	                if (base.browser.support3d === true) {
	                    base.transition3d(base.newPosX);
	                } else {
	                    base.css2move(base.newPosX);
	                }
	            }

	            function dragEnd(event) {
	                var ev = event.originalEvent || event || window.event,
	                    newPosition,
	                    handlers,
	                    owlStopEvent;

	                ev.target = ev.target || ev.srcElement;

	                locals.dragging = false;

	                if (base.browser.isTouch !== true) {
	                    base.$owlWrapper.removeClass("grabbing");
	                }

	                if (base.newRelativeX < 0) {
	                    base.dragDirection = base.owl.dragDirection = "left";
	                } else {
	                    base.dragDirection = base.owl.dragDirection = "right";
	                }

	                if (base.newRelativeX !== 0) {
	                    newPosition = base.getNewPosition();
	                    base.goTo(newPosition, false, "drag");
	                    if (locals.targetElement === ev.target && base.browser.isTouch !== true) {
	                        $(ev.target).on("click.disable", function (ev) {
	                            ev.stopImmediatePropagation();
	                            ev.stopPropagation();
	                            ev.preventDefault();
	                            $(ev.target).off("click.disable");
	                        });
	                        handlers = $._data(ev.target, "events").click;
	                        owlStopEvent = handlers.pop();
	                        handlers.splice(0, 0, owlStopEvent);
	                    }
	                }
	                swapEvents("off");
	            }
	            base.$elem.on(base.ev_types.start, ".owl-wrapper", dragStart);
	        },

	        getNewPosition : function () {
	            var base = this,
	                newPosition = base.closestItem();

	            if (newPosition > base.maximumItem) {
	                base.currentItem = base.maximumItem;
	                newPosition  = base.maximumItem;
	            } else if (base.newPosX >= 0) {
	                newPosition = 0;
	                base.currentItem = 0;
	            }
	            return newPosition;
	        },
	        closestItem : function () {
	            var base = this,
	                array = base.options.scrollPerPage === true ? base.pagesInArray : base.positionsInArray,
	                goal = base.newPosX,
	                closest = null;

	            $.each(array, function (i, v) {
	                if (goal - (base.itemWidth / 20) > array[i + 1] && goal - (base.itemWidth / 20) < v && base.moveDirection() === "left") {
	                    closest = v;
	                    if (base.options.scrollPerPage === true) {
	                        base.currentItem = $.inArray(closest, base.positionsInArray);
	                    } else {
	                        base.currentItem = i;
	                    }
	                } else if (goal + (base.itemWidth / 20) < v && goal + (base.itemWidth / 20) > (array[i + 1] || array[i] - base.itemWidth) && base.moveDirection() === "right") {
	                    if (base.options.scrollPerPage === true) {
	                        closest = array[i + 1] || array[array.length - 1];
	                        base.currentItem = $.inArray(closest, base.positionsInArray);
	                    } else {
	                        closest = array[i + 1];
	                        base.currentItem = i + 1;
	                    }
	                }
	            });
	            return base.currentItem;
	        },

	        moveDirection : function () {
	            var base = this,
	                direction;
	            if (base.newRelativeX < 0) {
	                direction = "right";
	                base.playDirection = "next";
	            } else {
	                direction = "left";
	                base.playDirection = "prev";
	            }
	            return direction;
	        },

	        customEvents : function () {
	            /*jslint unparam: true*/
	            var base = this;
	            base.$elem.on("owl.next", function () {
	                base.next();
	            });
	            base.$elem.on("owl.prev", function () {
	                base.prev();
	            });
	            base.$elem.on("owl.play", function (event, speed) {
	                base.options.autoPlay = speed;
	                base.play();
	                base.hoverStatus = "play";
	            });
	            base.$elem.on("owl.stop", function () {
	                base.stop();
	                base.hoverStatus = "stop";
	            });
	            base.$elem.on("owl.goTo", function (event, item) {
	                base.goTo(item);
	            });
	            base.$elem.on("owl.jumpTo", function (event, item) {
	                base.jumpTo(item);
	            });
	        },

	        stopOnHover : function () {
	            var base = this;
	            if (base.options.stopOnHover === true && base.browser.isTouch !== true && base.options.autoPlay !== false) {
	                base.$elem.on("mouseover", function () {
	                    base.stop();
	                });
	                base.$elem.on("mouseout", function () {
	                    if (base.hoverStatus !== "stop") {
	                        base.play();
	                    }
	                });
	            }
	        },

	        lazyLoad : function () {
	            var base = this,
	                i,
	                $item,
	                itemNumber,
	                $lazyImg,
	                follow;

	            if (base.options.lazyLoad === false) {
	                return false;
	            }
	            for (i = 0; i < base.itemsAmount; i += 1) {
	                $item = $(base.$owlItems[i]);

	                if ($item.data("owl-loaded") === "loaded") {
	                    continue;
	                }

	                itemNumber = $item.data("owl-item");
	                $lazyImg = $item.find(".lazyOwl");

	                if (typeof $lazyImg.data("src") !== "string") {
	                    $item.data("owl-loaded", "loaded");
	                    continue;
	                }
	                if ($item.data("owl-loaded") === undefined) {
	                    $lazyImg.hide();
	                    $item.addClass("loading").data("owl-loaded", "checked");
	                }
	                if (base.options.lazyFollow === true) {
	                    follow = itemNumber >= base.currentItem;
	                } else {
	                    follow = true;
	                }
	                if (follow && itemNumber < base.currentItem + base.options.items && $lazyImg.length) {
	                    $lazyImg.each(function() {
	                        base.lazyPreload($item, $(this));
	                    });
	                }
	            }
	        },

	        lazyPreload : function ($item, $lazyImg) {
	            var base = this,
	                iterations = 0,
	                isBackgroundImg;

	            if ($lazyImg.prop("tagName") === "DIV") {
	                $lazyImg.css("background-image", "url(" + $lazyImg.data("src") + ")");
	                isBackgroundImg = true;
	            } else {
	                $lazyImg[0].src = $lazyImg.data("src");
	            }

	            function showImage() {
	                $item.data("owl-loaded", "loaded").removeClass("loading");
	                $lazyImg.removeAttr("data-src");
	                if (base.options.lazyEffect === "fade") {
	                    $lazyImg.fadeIn(400);
	                } else {
	                    $lazyImg.show();
	                }
	                if (typeof base.options.afterLazyLoad === "function") {
	                    base.options.afterLazyLoad.apply(this, [base.$elem]);
	                }
	            }

	            function checkLazyImage() {
	                iterations += 1;
	                if (base.completeImg($lazyImg.get(0)) || isBackgroundImg === true) {
	                    showImage();
	                } else if (iterations <= 100) {//if image loads in less than 10 seconds 
	                    window.setTimeout(checkLazyImage, 100);
	                } else {
	                    showImage();
	                }
	            }

	            checkLazyImage();
	        },

	        autoHeight : function () {
	            var base = this,
	                $currentimg = $(base.$owlItems[base.currentItem]).find("img"),
	                iterations;

	            function addHeight() {
	                var $currentItem = $(base.$owlItems[base.currentItem]).height();
	                base.wrapperOuter.css("height", $currentItem + "px");
	                if (!base.wrapperOuter.hasClass("autoHeight")) {
	                    window.setTimeout(function () {
	                        base.wrapperOuter.addClass("autoHeight");
	                    }, 0);
	                }
	            }

	            function checkImage() {
	                iterations += 1;
	                if (base.completeImg($currentimg.get(0))) {
	                    addHeight();
	                } else if (iterations <= 100) { //if image loads in less than 10 seconds 
	                    window.setTimeout(checkImage, 100);
	                } else {
	                    base.wrapperOuter.css("height", ""); //Else remove height attribute
	                }
	            }

	            if ($currentimg.get(0) !== undefined) {
	                iterations = 0;
	                checkImage();
	            } else {
	                addHeight();
	            }
	        },

	        completeImg : function (img) {
	            var naturalWidthType;

	            if (!img.complete) {
	                return false;
	            }
	            naturalWidthType = typeof img.naturalWidth;
	            if (naturalWidthType !== "undefined" && img.naturalWidth === 0) {
	                return false;
	            }
	            return true;
	        },

	        onVisibleItems : function () {
	            var base = this,
	                i;

	            if (base.options.addClassActive === true) {
	                base.$owlItems.removeClass("active");
	            }
	            base.visibleItems = [];
	            for (i = base.currentItem; i < base.currentItem + base.options.items; i += 1) {
	                base.visibleItems.push(i);

	                if (base.options.addClassActive === true) {
	                    $(base.$owlItems[i]).addClass("active");
	                }
	            }
	            base.owl.visibleItems = base.visibleItems;
	        },

	        transitionTypes : function (className) {
	            var base = this;
	            //Currently available: "fade", "backSlide", "goDown", "fadeUp"
	            base.outClass = "owl-" + className + "-out";
	            base.inClass = "owl-" + className + "-in";
	        },

	        singleItemTransition : function () {
	            var base = this,
	                outClass = base.outClass,
	                inClass = base.inClass,
	                $currentItem = base.$owlItems.eq(base.currentItem),
	                $prevItem = base.$owlItems.eq(base.prevItem),
	                prevPos = Math.abs(base.positionsInArray[base.currentItem]) + base.positionsInArray[base.prevItem],
	                origin = Math.abs(base.positionsInArray[base.currentItem]) + base.itemWidth / 2,
	                animEnd = 'webkitAnimationEnd oAnimationEnd MSAnimationEnd animationend';

	            base.isTransition = true;

	            base.$owlWrapper
	                .addClass('owl-origin')
	                .css({
	                    "-webkit-transform-origin" : origin + "px",
	                    "-moz-perspective-origin" : origin + "px",
	                    "perspective-origin" : origin + "px"
	                });
	            function transStyles(prevPos) {
	                return {
	                    "position" : "relative",
	                    "left" : prevPos + "px"
	                };
	            }

	            $prevItem
	                .css(transStyles(prevPos, 10))
	                .addClass(outClass)
	                .on(animEnd, function () {
	                    base.endPrev = true;
	                    $prevItem.off(animEnd);
	                    base.clearTransStyle($prevItem, outClass);
	                });

	            $currentItem
	                .addClass(inClass)
	                .on(animEnd, function () {
	                    base.endCurrent = true;
	                    $currentItem.off(animEnd);
	                    base.clearTransStyle($currentItem, inClass);
	                });
	        },

	        clearTransStyle : function (item, classToRemove) {
	            var base = this;
	            item.css({
	                "position" : "",
	                "left" : ""
	            }).removeClass(classToRemove);

	            if (base.endPrev && base.endCurrent) {
	                base.$owlWrapper.removeClass('owl-origin');
	                base.endPrev = false;
	                base.endCurrent = false;
	                base.isTransition = false;
	            }
	        },

	        owlStatus : function () {
	            var base = this;
	            base.owl = {
	                "userOptions"   : base.userOptions,
	                "baseElement"   : base.$elem,
	                "userItems"     : base.$userItems,
	                "owlItems"      : base.$owlItems,
	                "currentItem"   : base.currentItem,
	                "prevItem"      : base.prevItem,
	                "visibleItems"  : base.visibleItems,
	                "isTouch"       : base.browser.isTouch,
	                "browser"       : base.browser,
	                "dragDirection" : base.dragDirection
	            };
	        },

	        clearEvents : function () {
	            var base = this;
	            base.$elem.off(".owl owl mousedown.disableTextSelect");
	            $(document).off(".owl owl");
	            $(window).off("resize", base.resizer);
	        },

	        unWrap : function () {
	            var base = this;
	            if (base.$elem.children().length !== 0) {
	                base.$owlWrapper.unwrap();
	                base.$userItems.unwrap().unwrap();
	                if (base.owlControls) {
	                    base.owlControls.remove();
	                }
	            }
	            base.clearEvents();
	            base.$elem.attr({
	                style: base.$elem.data("owl-originalStyles") || "",
	                class: base.$elem.data("owl-originalClasses")
	            });
	        },

	        destroy : function () {
	            var base = this;
	            base.stop();
	            window.clearInterval(base.checkVisible);
	            base.unWrap();
	            base.$elem.removeData();
	        },

	        reinit : function (newOptions) {
	            var base = this,
	                options = $.extend({}, base.userOptions, newOptions);
	            base.unWrap();
	            base.init(options, base.$elem);
	        },

	        addItem : function (htmlString, targetPosition) {
	            var base = this,
	                position;

	            if (!htmlString) {return false; }

	            if (base.$elem.children().length === 0) {
	                base.$elem.append(htmlString);
	                base.setVars();
	                return false;
	            }
	            base.unWrap();
	            if (targetPosition === undefined || targetPosition === -1) {
	                position = -1;
	            } else {
	                position = targetPosition;
	            }
	            if (position >= base.$userItems.length || position === -1) {
	                base.$userItems.eq(-1).after(htmlString);
	            } else {
	                base.$userItems.eq(position).before(htmlString);
	            }

	            base.setVars();
	        },

	        removeItem : function (targetPosition) {
	            var base = this,
	                position;

	            if (base.$elem.children().length === 0) {
	                return false;
	            }
	            if (targetPosition === undefined || targetPosition === -1) {
	                position = -1;
	            } else {
	                position = targetPosition;
	            }

	            base.unWrap();
	            base.$userItems.eq(position).remove();
	            base.setVars();
	        }

	    };

	    $.fn.owlCarousel = function (options) {
	        return this.each(function () {
	            if ($(this).data("owl-init") === true) {
	                return false;
	            }
	            $(this).data("owl-init", true);
	            var carousel = Object.create(Carousel);
	            carousel.init(options, this);
	            $.data(this, "owlCarousel", carousel);
	        });
	    };

	    $.fn.owlCarousel.options = {

	        items : 5,
	        itemsCustom : false,
	        itemsDesktop : [1199, 4],
	        itemsDesktopSmall : [979, 3],
	        itemsTablet : [768, 2],
	        itemsTabletSmall : false,
	        itemsMobile : [479, 1],
	        singleItem : false,
	        itemsScaleUp : false,

	        slideSpeed : 200,
	        paginationSpeed : 800,
	        rewindSpeed : 1000,

	        autoPlay : false,
	        stopOnHover : false,

	        navigation : false,
	        navigationText : ["prev", "next"],
	        rewindNav : true,
	        scrollPerPage : false,

	        pagination : true,
	        paginationNumbers : false,

	        responsive : true,
	        responsiveRefreshRate : 200,
	        responsiveBaseWidth : window,

	        baseClass : "owl-carousel",
	        theme : "owl-theme",

	        lazyLoad : false,
	        lazyFollow : true,
	        lazyEffect : "fade",

	        autoHeight : false,

	        jsonPath : false,
	        jsonSuccess : false,

	        dragBeforeAnimFinish : true,
	        mouseDrag : true,
	        touchDrag : true,

	        addClassActive : false,
	        transitionStyle : false,

	        beforeUpdate : false,
	        afterUpdate : false,
	        beforeInit : false,
	        afterInit : false,
	        beforeMove : false,
	        afterMove : false,
	        afterAction : false,
	        startDragging : false,
	        afterLazyLoad: false
	    };
	}(jQuery, window, document));

	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(5)))

/***/ },
/* 30 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";

	/**
	 * Created by Raydius on 4/3/16.
	 */

	var copy = {
	  "logo": {
	    "src": __webpack_require__(31),
	    "alt": "Phenomenon Logo"
	  },
	  "navigation": [{
	    "navTitle": "About",
	    "title": "View About Page",
	    "uiSref": "about",
	    "className": "about"
	  }, {
	    "navTitle": "Work",
	    "title": "View Work Page",
	    "uiSref": "work",
	    "className": "work"
	  }, {
	    "navTitle": "Culture",
	    "title": "View Culture Page",
	    "uiSref": "culture",
	    "className": "culture"
	  }, {
	    "navTitle": "Jobs",
	    "title": "View Jobs Page",
	    "uiSref": "jobs"
	  }, {
	    "navTitle": "Contact",
	    "title": "View Contact Form",
	    "uiSref": "contact"
	  }, {
	    "navTitle": "Entertainment",
	    "title": "Phenomenon Entertainment",
	    "uiSref": "entertainment",
	    "className": "contact"
	  }, {
	    "navTitle": "Blogs",
	    "title": "View Contact Form",
	    "uiSref": "blogs"
	  }],
	  "footer": {
	    "offices": {
	      "la": {
	        "title": "Los Angeles",
	        "address": {
	          "line1": "5900 Wilshire Blvd, Floor 28",
	          "line2": "Los Angeles, CA 90036"
	        },
	        "phone": {
	          "href": "tel:13236484000",
	          "formatted": "+1 323 648 4000",
	          "title": "Phenomenon Los Angeles Office Phone Number"
	        }
	      },
	      "chicago": {
	        "title": "Chicago",
	        "address": {
	          "line1": "118 N. Peoria St, Suite 5N",
	          "line2": "Chicago, IL 60607"
	        },
	        "phone": {
	          "href": "tel:13236484000",
	          "formatted": "+1 323 648 4000",
	          "title": "Phenomenon Chicago Office Phone Number"
	        }
	      }
	    },
	    "social": {
	      "instagram": {
	        "url": "https://www.instagram.com/phenomenon/",
	        "className": "icon-instagram",
	        "title": "View Phenomenon's Instagram"
	      },
	      "twitter": {
	        "url": "https://www.twitter.com/phenomenon/",
	        "className": "icon-twitter",
	        "title": "View Phenomenon's Tweets"
	      },
	      "facebook": {
	        "url": "https://www.facebook.com/phenomenon/",
	        "className": "icon-facebook",
	        "title": "View Phenomenon's Facebook Page"
	      },
	      "linkedin": {
	        "url": "https://www.linkedin.com/company/phenomenon",
	        "className": "icon-linkedin",
	        "title": "View Phenomenon's Facebook Page"
	      }
	    }
	  },
	  "content": {
	    "home": {
	      "contributors": [{
	        "name": "Amy Weisenbach",
	        "jobTitle": "VP Marketing, Wilson",
	        "project": "Wilson Is Now <br>Fully Equipped.",
	        "contributorAvatar": __webpack_require__(32)
	      }, {
	        "name": "Matt Stringer",
	        "jobTitle": "EVP Marketing, Men&#8217s Wearhouse",
	        "project": "Men&#8217s Wearhouse<br> Updates Its Wardrobe.",
	        "contributorAvatar": __webpack_require__(33)
	      }, {
	        "name": "Megan Crossland",
	        "jobTitle": "Director of Marketing, thinkThin",
	        "project": "thinkThin Helps<br> Women Shed the Guilt.",
	        "contributorAvatar": __webpack_require__(34)
	      }],
	      "contributorsMore": [{
	        "name": "By Kevin Dahlstrom",
	        "jobTitle": "Chief Marketing Office, Mr. Cooper Home Loans",
	        "project": "Wilson Is Now <br>Fully Equipped.",
	        "contributorAvatar": __webpack_require__(35)
	      }, {
	        "name": "By Kevin Dahlstrom",
	        "jobTitle": "Chief Marketing Office, Mr. Cooper Home Loans",
	        "project": "Wilson Is Now <br>Fully Equipped.",
	        "contributorAvatar": __webpack_require__(36)
	      }, {
	        "name": "By Kevin Dahlstrom",
	        "jobTitle": "Chief Marketing Office, Mr. Cooper Home Loans",
	        "project": "Wilson Is Now <br>Fully Equipped.",
	        "contributorAvatar": __webpack_require__(37)
	      }, {
	        "name": "By Kevin Dahlstrom",
	        "jobTitle": "Chief Marketing Office, Mr. Cooper Home Loans",
	        "project": "Wilson Is Now <br>Fully Equipped.",
	        "contributorAvatar": __webpack_require__(38)
	      }, {
	        "name": "By Kevin Dahlstrom",
	        "jobTitle": "Chief Marketing Office, Mr. Cooper Home Loans",
	        "project": "Wilson Is Now <br>Fully Equipped.",
	        "contributorAvatar": __webpack_require__(39)
	      }, {
	        "name": "By Kevin Dahlstrom",
	        "jobTitle": "Chief Marketing Office, Mr. Cooper Home Loans",
	        "project": "Wilson Is Now <br>Fully Equipped.",
	        "contributorAvatar": __webpack_require__(40)
	      }]
	    },
	    "about": {
	      "title": "About Phenomenon",
	      "className": "about",
	      "description": "Phenomenon - About",
	      "heroThumb": __webpack_require__(41),
	      "heroThumbAlt": "Xome - TV Spot",
	      "heroThumbTitle": "Click to play video",
	      "heroVimeo": "155071130",
	      "details": ["Buying or selling a home is often a complex, fragmented and darned unfriendly process. Xome is a radically better way to do it because it lets you complete everything from the convenience of an app. In just six weeks we built Xome: the first truly integrated way to buy and sell a home. The app lets you list your home, search for a home, make and receive offers, move into escrow and close the deal.", "When it came to the TV spot, we created something that spoke to the core of what Xome does, it makes the entire home buying/selling process more transparent. This teaser spot led people to our site where a demo video explained in better detail everything Xome does for the home buyer."],
	      "maincontent": [],
	      "subcontent": [{
	        "type": "video",
	        "video": true,
	        "thumb": __webpack_require__(42),
	        "thumbAlt": "Xome - TV Spot - Transparent House",
	        "thumbTitle": "Click to play video",
	        "vimeo": "159123265"
	      }, {
	        "type": "image",
	        "image": true,
	        "imageUrl": __webpack_require__(43),
	        "imageAlt": "Xome Image 1"
	      }]
	    },
	    "work": {
	      "title": "Work Cases Phenomenon",
	      "className": "work",
	      "description": "Phenomenon - Work",

	      "maincontent": [],
	      "subcontent": [{
	        "type": "image",
	        "image": true,
	        "imageUrl": __webpack_require__(44),
	        "imageAlt": "Wilson Image 1",
	        "legend": "Home / Real Estate",
	        "headline": "Wilson Is Now Fully Equipped.",
	        "cite": "",
	        "description": "New company looks to make buying and selling a home not only more mobile, but more transparent.",
	        "readmoreUrl": "#/work/wilson-anthem"
	      }, {
	        "type": "image",
	        "image": true,
	        "imageUrl": __webpack_require__(45),
	        "imageAlt": "Wilson Image 2",
	        "legend": "Sports/ Lifestyle",
	        "headline": "When Buying a House, There's no place like Xome",
	        "cite": "",
	        "description": "360 degree global campaign is the first in the company's 50 year history.",
	        "readmoreUrl": "#/work/xome"

	      }, {
	        "type": "image",
	        "image": true,
	        "imageUrl": __webpack_require__(46),
	        "imageAlt": "Wilson Image 3",
	        "legend": "Fashion / Retail",
	        "headline": "Men",
	        "cite": "",
	        "description": "After the departure of longtime owner and face of brand, company looks to modernize all the way down to the cufflinks.",
	        "readmoreUrl": "#/work/mens-wearhouse"

	      }, {
	        "type": "image",
	        "image": true,
	        "imageUrl": __webpack_require__(47),
	        "imageAlt": "Wilson Image 4",
	        "legend": "Sport / Lifestyle",
	        "headline": "Wilson Launches Futuristic Ball",
	        "cite": "",
	        "description": "For the first time a basketball is connected to your smartphone to track makes, misses and enhance performance.",
	        "readmoreUrl": "#/work/wilson-x"
	      }, {
	        "type": "image",
	        "image": true,
	        "imageUrl": __webpack_require__(48),
	        "imageAlt": "Wilson Image 5",
	        "legend": "Finance / Loans",
	        "headline": 'It\'s A "Sunny" Day for Payday Loans.',
	        "cite": "",
	        "description": "British company creates a whole new business model for payday loans that gives borrowers a better chance at getting out of debt.",
	        "readmoreUrl": "#/work/sunny"
	      }, {
	        "type": "image",
	        "image": true,
	        "imageUrl": __webpack_require__(49),
	        "imageAlt": "Wilson Image 6",
	        "legend": "Food / Drink",
	        "headline": "thinkThin Helps Women to Shed Guilt",
	        "cite": "",
	        "description": "Nutritional bar targeted to women launches its campaign using humor to rave reviews online.",
	        "readmoreUrl": "#/work/think-thin"

	      }, {
	        "type": "image",
	        "image": true,
	        "imageUrl": __webpack_require__(50),
	        "imageAlt": "Wilson Image 7",
	        "legend": "Travel / Leisure",
	        "headline": "SLS Vegas Gives the Strip a Whole New Look.",
	        "cite": "",
	        "description": "Growing LA Entertainment group decides to make a splash in Sin City with launch of bold hotel and casino.",
	        "readmoreUrl": "#/work/sls"
	      }]
	    },
	    "wilson-anthem": {
	      "title": "Wilson Anthem",
	      "className": "wilson-anthem",
	      "client": "Wilson",
	      "clientLogo": __webpack_require__(51),
	      "project": "Wilson Anthem",
	      "media": "Branding, Video, Digital",
	      "blockquote": "Wilson Is Now<br> Fully Equipped.",
	      "description": "CVU - Phenomenon - Wilson X",
	      "topDescription": ["Wilson has been around for over 100 years but we've never had a global brand campaign. Since this was our first campaign, we needed to identify what Wilson is all about. We make quality, trusted equipment, but what do we stand for? What is our role in the world of sports? We worked with the strategic team at Phenomenon to land on a pretty powerful yet simple idea; Wilson is every athletes faithful weapon.", "<span class='red'>We worked with the strategic team at Phenomenon to land on a pretty powerful yet simple idea; Wilson is every athletes faithful weapon.</span>", "Before we did any consumer-facing branding, we asked Pheno to create something that could rally the Wilson team from within. What did this new face of Wilson mean? How could we as employees live this? So we produced a beautifully bound brand book containing words and images that boldly and loudly defined who we are and handed them out to each of our employees."],
	      "heroThumb": __webpack_require__(52),
	      "heroThumbAlt": "Wilson X - Case Study Video",
	      "heroThumbTitle": "Click to play video",
	      "heroVimeo": "155010841",
	      "details": ["Wilson X's idea is simple. It's the first basketball that connects to your smartphone to help you track makes and misses without any sort of rim attachment. It was Wilson's first connected product and was an opportunity for us to show not just how revolutionary the ball was, but how digitally savvy Wilson was becoming. In just a few weeks we named the product. Designed the packaging. Designed the entire app experience. And created the ad campaign around it."],
	      "detailcontent": [{
	        "carousel": true,
	        "images": [{
	          "url": __webpack_require__(53),
	          "alt": "Wilson X Packaging Photo 1"
	        }, {
	          "url": __webpack_require__(54),
	          "alt": "Wilson X Packaging Photo 2"
	        }, {
	          "url": __webpack_require__(55),
	          "alt": "Wilson X Packaging Photo 3"
	        }, {
	          "url": __webpack_require__(56),
	          "alt": "Wilson X Packaging Photo 4"
	        }, {
	          "url": __webpack_require__(57),
	          "alt": "Wilson X Packaging Photo 5"
	        }, {
	          "url": __webpack_require__(58),
	          "alt": "Wilson X Packaging Photo 6"
	        }],
	        "mainDescription": ["Wilson X's idea is simple. It's the first basketball that connects to your smartphone to help you track makes and misses without any sort of rim attachment. It was Wilson's first connected product and was an opportunity for us to show not just how revolutionary the ball was, but how digitally savvy Wilson was becoming. In just a few weeks we named the product. Designed the packaging. Designed the entire app experience. And created the ad campaign around it."]
	      }, {
	        "carousel": true,
	        "images": [{
	          "url": __webpack_require__(53),
	          "alt": "Wilson X Packaging Photo 1"
	        }, {
	          "url": __webpack_require__(54),
	          "alt": "Wilson X Packaging Photo 2"
	        }, {
	          "url": __webpack_require__(55),
	          "alt": "Wilson X Packaging Photo 3"
	        }, {
	          "url": __webpack_require__(56),
	          "alt": "Wilson X Packaging Photo 4"
	        }, {
	          "url": __webpack_require__(57),
	          "alt": "Wilson X Packaging Photo 5"
	        }, {
	          "url": __webpack_require__(58),
	          "alt": "Wilson X Packaging Photo 6"
	        }],
	        "mainDescription": ["Wilson X's idea is simple. It's the first basketball that connects to your smartphone to help you track makes and misses without any sort of rim attachment. It was Wilson's first connected product and was an opportunity for us to show not just how revolutionary the ball was, but how digitally savvy Wilson was becoming. In just a few weeks we named the product. Designed the packaging. Designed the entire app experience. And created the ad campaign around it."]
	      }, {
	        "video": true,
	        "thumb": __webpack_require__(59),
	        "thumbAlt": "Wilson X - TV Spot - All Day",
	        "thumbTitle": "Click to play video",
	        "vimeo": "155010839",
	        "mainDescription": ["The results: We sold out on Amazon in just two weeks and Wilson X will be in retail stores all over the country this Spring."]
	      }]
	    },
	    "wilsonX": {
	      "title": "Wilson X",
	      "className": "wilson-x",
	      "client": "Wilson",
	      "clientLogo": __webpack_require__(51),
	      "project": "Wilson Anthem",
	      "media": "Branding, Video, Digital",
	      "blockquote": "Wilson Is Now <br>Fully Equipped.",
	      "description": "CVU - Phenomenon - Wilson X",
	      "topDescription": ["Wilson has been around for over 100 years but we've never had a global brand campaign. Since this was our first campaign, we needed to identify what Wilson is all about. We make quality, trusted equipment, but what do we stand for? What is our role in the world of sports? We worked with the strategic team at Phenomenon to land on a pretty powerful yet simple idea; Wilson is every athletes faithful weapon.", "<span class='red'>We worked with the strategic team at Phenomenon to land on a pretty powerful yet simple idea; Wilson is every athletes faithful weapon.</span>", "Before we did any consumer-facing branding, we asked Pheno to create something that could rally the Wilson team from within. What did this new face of Wilson mean? How could we as employees live this? So we produced a beautifully bound brand book containing words and images that boldly and loudly defined who we are and handed them out to each of our employees."],
	      "heroThumb": __webpack_require__(52),
	      "heroThumbAlt": "Wilson X - Case Study Video",
	      "heroThumbTitle": "Click to play video",
	      "heroVimeo": "155010841",
	      "details": ["Wilson X's idea is simple. It's the first basketball that connects to your smartphone to help you track makes and misses without any sort of rim attachment. It was Wilson's first connected product and was an opportunity for us to show not just how revolutionary the ball was, but how digitally savvy Wilson was becoming. In just a few weeks we named the product. Designed the packaging. Designed the entire app experience. And created the ad campaign around it."],
	      "detailcontent": [{
	        "carousel": true,
	        "images": [{
	          "url": __webpack_require__(53),
	          "alt": "Wilson X Packaging Photo 1"
	        }, {
	          "url": __webpack_require__(54),
	          "alt": "Wilson X Packaging Photo 2"
	        }, {
	          "url": __webpack_require__(55),
	          "alt": "Wilson X Packaging Photo 3"
	        }, {
	          "url": __webpack_require__(56),
	          "alt": "Wilson X Packaging Photo 4"
	        }, {
	          "url": __webpack_require__(57),
	          "alt": "Wilson X Packaging Photo 5"
	        }, {
	          "url": __webpack_require__(58),
	          "alt": "Wilson X Packaging Photo 6"
	        }],
	        "mainDescription": ["Wilson X's idea is simple. It's the first basketball that connects to your smartphone to help you track makes and misses without any sort of rim attachment. It was Wilson's first connected product and was an opportunity for us to show not just how revolutionary the ball was, but how digitally savvy Wilson was becoming. In just a few weeks we named the product. Designed the packaging. Designed the entire app experience. And created the ad campaign around it."]
	      }, {
	        "carousel": true,
	        "images": [{
	          "url": __webpack_require__(53),
	          "alt": "Wilson X Packaging Photo 1"
	        }, {
	          "url": __webpack_require__(54),
	          "alt": "Wilson X Packaging Photo 2"
	        }, {
	          "url": __webpack_require__(55),
	          "alt": "Wilson X Packaging Photo 3"
	        }, {
	          "url": __webpack_require__(56),
	          "alt": "Wilson X Packaging Photo 4"
	        }, {
	          "url": __webpack_require__(57),
	          "alt": "Wilson X Packaging Photo 5"
	        }, {
	          "url": __webpack_require__(58),
	          "alt": "Wilson X Packaging Photo 6"
	        }],
	        "mainDescription": ["Wilson X's idea is simple. It's the first basketball that connects to your smartphone to help you track makes and misses without any sort of rim attachment. It was Wilson's first connected product and was an opportunity for us to show not just how revolutionary the ball was, but how digitally savvy Wilson was becoming. In just a few weeks we named the product. Designed the packaging. Designed the entire app experience. And created the ad campaign around it."]
	      }, {
	        "video": true,
	        "thumb": __webpack_require__(59),
	        "thumbAlt": "Wilson X - TV Spot - All Day",
	        "thumbTitle": "Click to play video",
	        "vimeo": "155010839",
	        "mainDescription": ["The results: We sold out on Amazon in just two weeks and Wilson X will be in retail stores all over the country this Spring."]
	      }]
	    },
	    "sls": {
	      "title": "SLS",
	      "className": "sls",
	      "client": "SBE",
	      "clientLogo": __webpack_require__(60),
	      "project": "SLS",
	      "media": "Branding",
	      "blockquote": " SLS Vegas Gives the Strip a Whole New Look.",
	      "description": "CVU - Phenomenon - Wilson X",
	      "topDescription": ["The SLS chain of high-end, luxury hotels has been a mainstay in Miami and Los Angeles for over a decade. Since 2007 we have been anxiously anticipating our expansion to Sin City. And 7 years later we were ready to launch. But when it comes to Vegas, it's not as simple as just opening the doors. You have to really identify and brand who you are. Every hotel in Vegas has shows. Everyone has restaurants. Everyone has gambling. But what will you get when you come to the SLS Vegas? That was the challenge ahead of us.", "<span class='red'>So when we created the branding for the SLS Vegas, we literally mixed the old Vegas with the new.</span>", "The first thing Pheno loved about our new location is the same thing we loved, the history. The site was the exact location of the iconic Sahara Hotel & Casino which was the place you wanted to be in 60s Vegas. It was elegant, sophisticated, glamorous. The Sahara represented a different time for Vegas, with different values. And we wanted to bring those feelings back. A new old way to experience Vegas, so-to-speak. So when we created the branding for the SLS Vegas, we literally mixed the old Vegas with the new."],
	      "details": ["Wilson X's idea is simple. It's the first basketball that connects to your smartphone to help you track makes and misses without any sort of rim attachment. It was Wilson's first connected product and was an opportunity for us to show not just how revolutionary the ball was, but how digitally savvy Wilson was becoming. In just a few weeks we named the product. Designed the packaging. Designed the entire app experience. And created the ad campaign around it."],
	      "detailcontent": [{
	        "type": "image",
	        "image": true,
	        "imageUrl": __webpack_require__(61),
	        "imageAlt": "SLS",
	        "mainDescription": ["Most people don't know, but in LA - where the SLS is iconic- we actually own numerous restaurants and clubs in addition to the hotels. But the challenge with our new Vegas location, was that all of these entities are housed under the same roof. So from a visual standpoint, we wanted some kind of harmony, some kind of tone that unified everything from a club to a little coffee shop.", "They designed the packaging for the amenities in the hotel. They created logos and brand books for just about all of our new restaurants and clubs. They even named our espresso bar, Perq.", "Phenomenon helped us with all of this. They designed the packaging for the amenities in the hotel. They created logos and brand books for just about all of our new restaurants and clubs. They even named our espresso bar, Perq."]
	      }, {
	        "type": "image",
	        "image": true,
	        "imageUrl": __webpack_require__(62),
	        "imageAlt": "SLS",
	        "mainDescription": ["Most people consider the lobby to be where hotels make their first impression. That's wrong. It's the website. When most people first heard about the SLS Vegas they couldn't even visit it, because it wasn't open yet. So the website was not only the first interaction, it was the only one. We wanted the site to be easily browsable so you could see all that you could do while staying here. Tonally we never said all inclusive but visually we wanted people to feel like leaving would be a bad idea. Creating a perfect experience online also meant simplifying, all the way down to the event calendar. This was people's first experience with the SLS Vegas, it needed to feel as effortless as staying there."]
	      }, {
	        "carousel": true,
	        "images": [{
	          "url": __webpack_require__(63),
	          "alt": "Wilson X Packaging Photo 1"
	        }, {
	          "url": __webpack_require__(54),
	          "alt": "Wilson X Packaging Photo 2"
	        }, {
	          "url": __webpack_require__(55),
	          "alt": "Wilson X Packaging Photo 3"
	        }, {
	          "url": __webpack_require__(56),
	          "alt": "Wilson X Packaging Photo 4"
	        }, {
	          "url": __webpack_require__(57),
	          "alt": "Wilson X Packaging Photo 5"
	        }, {
	          "url": __webpack_require__(58),
	          "alt": "Wilson X Packaging Photo 6"
	        }]
	      }]
	    },
	    "xome": {
	      "title": "Xome",
	      "className": "Xome",
	      "client": "Xome",
	      "clientLogo": __webpack_require__(64),
	      "project": "Xome",
	      "media": "Branding",
	      "blockquote": 'It&#8217;s A &#8220;Sunny&#8221; Day <br>for Payday Loans',
	      "description": "CVU - Phenomenon - Wilson X",
	      "topDescription": ["In the UK, the short-term loans business is not dissimilar to the US in that we have a huge problem with perception. Most people associate us with shady strip malls with big neon signs and questionable business practices. And brands you do know, like Wonga, notoriously take advantage of consumers and their need for fast cash.", "<span class='red'>We went to Phenomenon to help us create a differentiating short-term loan product</span>", "We went to Phenomenon, not to create a brand campaign or an app or some other piece of communication. We went to Phenomenon to help us create a differentiating short-term loan product. And they came back to us with an interesting idea they aptly called Sunny."],
	      "detailcontent": [{
	        "type": "image",
	        "image": true,
	        "imageUrl": __webpack_require__(65),
	        "imageAlt": "Sunny",
	        "mainDescription": ['Strategically, Pheno recognized that there was no loyalty in our industry. People took out their first loan and then had to pay so much back that they took out another loan to pay for that, and so on and so on. Often working with multiple companies in the process, or as they deemed it, "a circle of debt."', "They designed the packaging for the amenities in the hotel. They created logos and brand books for just about all of our new restaurants and clubs. They even named our espresso bar, Perq.", "Phenomenon helped us with all of this. They designed the packaging for the amenities in the hotel. They created logos and brand books for just about all of our new restaurants and clubs. They even named our espresso bar, Perq."]
	      }, {
	        "type": "image",
	        "image": true,
	        "imageUrl": __webpack_require__(66),
	        "imageAlt": "Sunny"
	      }, {
	        "type": "video",
	        "video": true,
	        "thumb": __webpack_require__(42),
	        "thumbAlt": "Xome - TV Spot - Transparent House",
	        "thumbTitle": "Click to play video",
	        "vimeo": "159123265"
	      }]
	    },
	    "sunny": {
	      "title": "Sunny",
	      "className": "sunny",
	      "client": "Sunny",
	      "clientLogo": __webpack_require__(67),
	      "project": "SLS",
	      "media": "Branding",
	      "blockquote": 'It\'s A "Sunny" Day for Payday Loans',
	      "description": "CVU - Phenomenon - Wilson X",
	      "topDescription": ["In the UK, the short-term loans business is not dissimilar to the US in that we have a huge problem with perception. Most people associate us with shady strip malls with big neon signs and questionable business practices. And brands you do know, like Wonga, notoriously take advantage of consumers and their need for fast cash.", "<span class='red'>We went to Phenomenon to help us create a differentiating short-term loan product</span>", "We went to Phenomenon, not to create a brand campaign or an app or some other piece of communication. We went to Phenomenon to help us create a differentiating short-term loan product. And they came back to us with an interesting idea they aptly called Sunny."],
	      "detailcontent": [{
	        "type": "image",
	        "image": true,
	        "imageUrl": __webpack_require__(65),
	        "imageAlt": "Sunny",
	        "mainDescription": ['Strategically, Pheno recognized that there was no loyalty in our industry. People took out their first loan and then had to pay so much back that they took out another loan to pay for that, and so on and so on. Often working with multiple companies in the process, or as they deemed it, "a circle of debt."', "They designed the packaging for the amenities in the hotel. They created logos and brand books for just about all of our new restaurants and clubs. They even named our espresso bar, Perq.", "Phenomenon helped us with all of this. They designed the packaging for the amenities in the hotel. They created logos and brand books for just about all of our new restaurants and clubs. They even named our espresso bar, Perq."]
	      }, {
	        "type": "image",
	        "image": true,
	        "imageUrl": __webpack_require__(66),
	        "imageAlt": "Sunny"
	      }, {
	        "type": "video",
	        "video": true,
	        "thumb": __webpack_require__(42),
	        "thumbAlt": "Xome - TV Spot - Transparent House",
	        "thumbTitle": "Click to play video",
	        "vimeo": "159123265"
	      }]
	    },
	    "mens-wearhouse": {
	      "title": "Men's Wearhouse",
	      "className": "mens-wearhouse",
	      "client": "Men's Wearhouse",
	      "clientLogo": __webpack_require__(68),
	      "project": "Men's Wearhouse",
	      "media": "Branding",
	      "blockquote": "Men&#8217;s Wearhouse<br> Updates Its Wardrobe.",
	      "description": "CVU - Phenomenon - Wilson X",
	      "topDescription": ["For over 20 years, Men's Wearhouse advertising centered around one line delivered by one man. But in 2013, when our founder and longtime CEO left the company, we had to make some pretty significant changes. After an extensive agency review we selected Phenomenon to take both strategic and creative lead on the future of Men's Wearhouse as our Agency of Record.", "The new tone and feel for us started early in 2014 when we acquired the men's fashion brand Joseph Abboud. We used that acquisition as a launching point to redefine our image. To kick things off, we developed a television spot that announced the partnership with Abboud and positioned the American Designer as our new Creative Director."],
	      "detailcontent": [{
	        "type": "video",
	        "video": true,
	        "thumb": __webpack_require__(42),
	        "thumbAlt": "Xome - TV Spot - Transparent House",
	        "thumbTitle": "Click to play video",
	        "vimeo": "159123265"
	      }, {
	        "carousel": true,
	        "images": [{
	          "url": __webpack_require__(69),
	          "alt": "Men's Wearhouse Photo 1"
	        }, {
	          "url": __webpack_require__(54),
	          "alt": "Wilson X Packaging Photo 2"
	        }, {
	          "url": __webpack_require__(55),
	          "alt": "Wilson X Packaging Photo 3"
	        }, {
	          "url": __webpack_require__(56),
	          "alt": "Wilson X Packaging Photo 4"
	        }, {
	          "url": __webpack_require__(57),
	          "alt": "Wilson X Packaging Photo 5"
	        }, {
	          "url": __webpack_require__(58),
	          "alt": "Wilson X Packaging Photo 6"
	        }]
	      }, {
	        "type": "video",
	        "video": true,
	        "thumb": __webpack_require__(42),
	        "thumbAlt": "Xome - TV Spot - Transparent House",
	        "thumbTitle": "Click to play video",
	        "vimeo": "159123265"
	      }]
	    },
	    "think-thin": {
	      "title": "Think Thin",
	      "className": "think-thin",
	      "client": "Think Thin",
	      "clientLogo": __webpack_require__(70),
	      "project": "Think Thin",
	      "media": "Branding",
	      "blockquote": 'thinkThin Helps Womens Shed the Guilty',
	      "description": "CVU - Phenomenon - Wilson X",
	      "topDescription": ["In the UK, the short-term loans business is not dissimilar to the US in that we have a huge problem with perception. Most people associate us with shady strip malls with big neon signs and questionable business practices. And brands you do know, like Wonga, notoriously take advantage of consumers and their need for fast cash.", "<span class='red'>We went to Phenomenon to help us create a differentiating short-term loan product</span>", "We went to Phenomenon, not to create a brand campaign or an app or some other piece of communication. We went to Phenomenon to help us create a differentiating short-term loan product. And they came back to us with an interesting idea they aptly called Sunny."],
	      "detailcontent": [{
	        "type": "video",
	        "video": true,
	        "thumb": __webpack_require__(42),
	        "thumbAlt": "Xome - TV Spot - Transparent House",
	        "thumbTitle": "Click to play video",
	        "vimeo": "159123265"
	      }]
	    },
	    "cooper": {
	      "title": "Cooper",
	      "className": "cooper",
	      "client": "Mr.Cooper",
	      "clientLogo": __webpack_require__(71),
	      "project": "Mr.Cooper",
	      "media": "Branding",
	      "blockquote": "Home Loans Get More Human with Mr.Cooper",
	      "description": "CVU - Phenomenon - Wilson X",
	      "topDescription": ["In the UK, the short-term loans business is not dissimilar to the States in that we have a huge stigma problem. Most people associate us with shady strip malls with big neon signs and questionable business practices. And brands you do know, like Wonga, notoriously take advantage of consumers and their need for fast cash.", "We went to Phenomenon to help us create a differentiating short-term loan product", "We went to Phenomenon, not to create a brand campaign or an app or some other piece of communication. We went to Phenomenon to help us create a differentiating short-term loan product. And they came back to us with an interesting idea they called Sunny."],
	      "detailcontent": [{
	        "type": "image",
	        "image": true,
	        "imageUrl": __webpack_require__(72),
	        "imageAlt": "Cooper",
	        "mainDescription": ["Most people don't know, but in LA - where the SLS is iconic- we actually own numerous restaurants and clubs in addition to the hotels. But the challenge with our new Vegas location, was that all of these entities are housed under the same roof. So from a visual standpoint, we wanted some kind of harmony, some kind of tone that unified everything from a club to a little coffee shop.", "They designed the packaging for the amenities in the hotel. They created logos and brand books for just about all of our new restaurants and clubs. They even named our espresso bar, Perq.", "Phenomenon helped us with all of this. They designed the packaging for the amenities in the hotel. They created logos and brand books for just about all of our new restaurants and clubs. They even named our espresso bar, Perq."]
	      }, {
	        "type": "image",
	        "image": true,
	        "imageUrl": __webpack_require__(73),
	        "imageAlt": "SLS",
	        "mainDescription": ["Most people consider the lobby to be where hotels make their first impression. That's wrong. It's the website. When most people first heard about the SLS Vegas they couldn't even visit it, because it wasn't open yet. So the website was not only the first interaction, it was the only one. We wanted the site to be easily browsable so you could see all that you could do while staying here. Tonally we never said all inclusive but visually we wanted people to feel like leaving would be a bad idea. Creating a perfect experience online also meant simplifying, all the way down to the event calendar. This was people's first experience with the SLS Vegas, it needed to feel as effortless as staying there."]
	      }, {
	        "carousel": true,
	        "images": [{
	          "url": __webpack_require__(74),
	          "alt": "Wilson X Packaging Photo 1"
	        }, {
	          "url": __webpack_require__(54),
	          "alt": "Wilson X Packaging Photo 2"
	        }, {
	          "url": __webpack_require__(55),
	          "alt": "Wilson X Packaging Photo 3"
	        }, {
	          "url": __webpack_require__(56),
	          "alt": "Wilson X Packaging Photo 4"
	        }, {
	          "url": __webpack_require__(57),
	          "alt": "Wilson X Packaging Photo 5"
	        }, {
	          "url": __webpack_require__(58),
	          "alt": "Wilson X Packaging Photo 6"
	        }]
	      }]
	    },
	    "moreCases": [{
	      "projectName": "Men's Wearhouse <br>Updates Its Closet.",
	      "writerName": "Mike Dowse",
	      "writerTitle": "CEO, Wilson",
	      "prjectThumbSrc": __webpack_require__(58)
	    }, {
	      "projectName": "Men's Wearhouse <br>Updates Its Closet.",
	      "writerName": "Mike Dowse",
	      "writerTitle": "CEO, Wilson",
	      "prjectThumbSrc": __webpack_require__(58)
	    }, {
	      "projectName": "Men's Wearhouse <br>Updates Its Closet.",
	      "writerName": "Mike Dowse",
	      "writerTitle": "CEO, Wilson",
	      "prjectThumbSrc": __webpack_require__(58)
	    }],
	    "entertainment": {
	      "title": "Wilson Anthem",
	      "className": "wilson-anthem",
	      "description": "CVU - Phenomenon - Wilson Anthem",
	      "heroThumb": __webpack_require__(75),
	      "heroThumbAlt": "Wilson Anthem - TV Spot",
	      "heroThumbTitle": "Click to play video",
	      "heroVimeo": "155010840",
	      "details": ["Wilson has been around for over 100 years but they've never had a global brand campaign. Since this was their first campaign, we needed to identify what Wilson is all about. What do they stand for? What is their role in the world of sports? Strategically we boiled it down to one simple insight: Wilson is every athlete's faithful weapon. This was important because even though Wilson has a star-studded lineup of professional athletes on their roster, by putting amateurs and kids on the same level we were truly celebrating all athletes.", "Since we didn't have a massive media buy, we had to figure out a way to leverage social media and get our fans to participate in the idea. So we let kids upload videos of themselves playing, which we then edited into the spot and sent back out to them.", "Beyond the brand spot, we created a beautiful bound brand book to handout to employees and we relaunched Wilson.com where watchable content revolved around the equipment."],
	      "subcontent": [{
	        "type": "carousel",
	        "carousel": true,
	        "images": [{
	          "url": __webpack_require__(76),
	          "alt": "Wilson Anthem Brand Ethos Book Image 1"
	        }, {
	          "url": __webpack_require__(77),
	          "alt": "Wilson Anthem Brand Ethos Book Image 2"
	        }, {
	          "url": __webpack_require__(78),
	          "alt": "Wilson Anthem Brand Ethos Book Image 3"
	        }, {
	          "url": __webpack_require__(79),
	          "alt": "Wilson Anthem Brand Ethos Book Image 4"
	        }, {
	          "url": __webpack_require__(80),
	          "alt": "Wilson Anthem Brand Ethos Book Image 5"
	        }, {
	          "url": __webpack_require__(81),
	          "alt": "Wilson Anthem Brand Ethos Book Image 6"
	        }, {
	          "url": __webpack_require__(82),
	          "alt": "Wilson Anthem Brand Ethos Book Image 7"
	        }, {
	          "url": __webpack_require__(83),
	          "alt": "Wilson Anthem Brand Ethos Book Image 8"
	        }]
	      }, {
	        "type": "scrollable",
	        "scrollable": true,
	        "imageAlt": "Wilson Anthem Landing Page"
	      }, {
	        "type": "carousel",
	        "carousel": true,
	        "images": [{
	          "url": __webpack_require__(84),
	          "alt": "Wilson Anthem Banner 1"
	        }, {
	          "url": __webpack_require__(85),
	          "alt": "Wilson Anthem Banner 2"
	        }]
	      }]
	    },
	    "culture": {
	      "title": "Culture",
	      "className": "culture",
	      "description": "CVU - Phenomenon - Xome Culture",
	      "details": ["Buying or selling a home is often a complex, fragmented and darned unfriendly process. Xome is a radically better way to do it because it lets you complete everything from the convenience of an app. In just six weeks we built Xome: the first truly integrated way to buy and sell a home. The app lets you list your home, search for a home, make and receive offers, move into escrow and close the deal.", "When it came to the TV spot, we created something that spoke to the core of what Xome does, it makes the entire home buying/selling process more transparent. This teaser spot led people to our site where a demo video explained in better detail everything Xome does for the home buyer."],
	      "subcontent": [{
	        "type": "image",
	        "image": true,
	        "imageUrl": __webpack_require__(43),
	        "imageAlt": "Xome Image 1"
	      }, {
	        "type": "image",
	        "image": true,
	        "imageUrl": __webpack_require__(43),
	        "imageAlt": "Xome Image 1"
	      }]
	    },
	    "jobs": {
	      "title": "Xome",
	      "className": "xome",
	      "description": "CVU - Phenomenon - Xome",
	      "heroThumb": __webpack_require__(41),
	      "heroThumbAlt": "Xome - TV Spot",
	      "heroThumbTitle": "Click to play video",
	      "heroVimeo": "155071130",
	      "details": ["Buying or selling a home is often a complex, fragmented and darned unfriendly process. Xome is a radically better way to do it because it lets you complete everything from the convenience of an app. In just six weeks we built Xome: the first truly integrated way to buy and sell a home. The app lets you list your home, search for a home, make and receive offers, move into escrow and close the deal.", "When it came to the TV spot, we created something that spoke to the core of what Xome does, it makes the entire home buying/selling process more transparent. This teaser spot led people to our site where a demo video explained in better detail everything Xome does for the home buyer."],
	      "subcontent": [{
	        "type": "video",
	        "video": true,
	        "thumb": __webpack_require__(42),
	        "thumbAlt": "Xome - TV Spot - Transparent House",
	        "thumbTitle": "Click to play video",
	        "vimeo": "159123265"
	      }, {
	        "type": "image",
	        "image": true,
	        "imageUrl": __webpack_require__(43),
	        "imageAlt": "Xome Image 1"
	      }]
	    },
	    "blogs": {
	      "title": "thinkThin",
	      "className": "think-thin",
	      "description": "CVU - Phenomenon - thinkThin",
	      "heroThumb": __webpack_require__(86),
	      "heroThumbAlt": "thinkThin - TV Spot - Pool",
	      "heroThumbTitle": "Click to play video",
	      "heroVimeo": "158975908",
	      "details": ["thinkThin is a nutritional bar founded by a strong, female entrepreneur to promote health and vitality for women and their often hectic lives. For years, they did little to no advertising. As they grew, they wanted to have a brand presence that showed off both their range of products as well as their personality.", "We netted out on a pretty fun campaign idea that laughed at all the guilty moments women have in their lives, while making the simple point that eating our bars is something you should never feel guilty about."],
	      "subcontent": [{
	        "type": "video",
	        "video": true,
	        "thumb": __webpack_require__(87),
	        "thumbAlt": "Wilson X - TV Spot - Run",
	        "thumbTitle": "Click to play video",
	        "vimeo": "159447308"
	      }, {
	        "type": "video",
	        "video": true,
	        "thumb": __webpack_require__(88),
	        "thumbAlt": "Wilson X - TV Spot - Text",
	        "thumbTitle": "Click to play video",
	        "vimeo": "159448353"
	      }, {
	        "type": "carousel",
	        "carousel": true,
	        "images": [{
	          "url": __webpack_require__(89),
	          "alt": "thinkThin Print Ad 1"
	        }, {
	          "url": __webpack_require__(90),
	          "alt": "thinkThin Print Ad 2"
	        }]
	      }, {
	        "type": "carousel",
	        "carousel": true,
	        "images": [{
	          "url": __webpack_require__(91),
	          "alt": "thinkThin Mobile Shaker Banner Ad 1"
	        }, {
	          "url": __webpack_require__(92),
	          "alt": "thinkThin Mobile Shaker Banner Ad 2"
	        }]
	      }]
	    }
	  }
	};

	module.exports = copy;

/***/ },
/* 31 */
/***/ function(module, exports, __webpack_require__) {

	module.exports = __webpack_require__.p + "d8c51a52da9003332cd04759141e734b.svg";

/***/ },
/* 32 */
/***/ function(module, exports, __webpack_require__) {

	module.exports = __webpack_require__.p + "70ee34b73a9fd571b244a7c805096bd7.png";

/***/ },
/* 33 */
/***/ function(module, exports, __webpack_require__) {

	module.exports = __webpack_require__.p + "0d6f75d0b80d32578b10aa5933cd1225.png";

/***/ },
/* 34 */
/***/ function(module, exports, __webpack_require__) {

	module.exports = __webpack_require__.p + "80836e2f78abdc8fb85078d87f569eb8.png";

/***/ },
/* 35 */
/***/ function(module, exports, __webpack_require__) {

	module.exports = __webpack_require__.p + "4ea78a46efdd5c4cf6da777f2127dfc7.png";

/***/ },
/* 36 */
/***/ function(module, exports, __webpack_require__) {

	module.exports = __webpack_require__.p + "e0601b88fc65383f716df30deec45f2e.png";

/***/ },
/* 37 */
/***/ function(module, exports, __webpack_require__) {

	module.exports = __webpack_require__.p + "232a040dacc534bb08e015648f62a67e.png";

/***/ },
/* 38 */
/***/ function(module, exports, __webpack_require__) {

	module.exports = __webpack_require__.p + "70ee34b73a9fd571b244a7c805096bd7.png";

/***/ },
/* 39 */
/***/ function(module, exports, __webpack_require__) {

	module.exports = __webpack_require__.p + "0d6f75d0b80d32578b10aa5933cd1225.png";

/***/ },
/* 40 */
/***/ function(module, exports, __webpack_require__) {

	module.exports = __webpack_require__.p + "80836e2f78abdc8fb85078d87f569eb8.png";

/***/ },
/* 41 */
/***/ function(module, exports, __webpack_require__) {

	module.exports = __webpack_require__.p + "93a31115f65c3c825adb3dcca820d56e.jpg";

/***/ },
/* 42 */
/***/ function(module, exports, __webpack_require__) {

	module.exports = __webpack_require__.p + "a70ff7466d09de32e2e9511bfc6e7c9d.jpg";

/***/ },
/* 43 */
/***/ function(module, exports, __webpack_require__) {

	module.exports = __webpack_require__.p + "119506de5a7dcc53d3e3525f6da34155.jpg";

/***/ },
/* 44 */
/***/ function(module, exports, __webpack_require__) {

	module.exports = __webpack_require__.p + "526e1f649d5d7aa989d34e0d6d54a3b4.jpg";

/***/ },
/* 45 */
/***/ function(module, exports, __webpack_require__) {

	module.exports = __webpack_require__.p + "7978d2f859689d4e1cd994eb31887700.jpg";

/***/ },
/* 46 */
/***/ function(module, exports, __webpack_require__) {

	module.exports = __webpack_require__.p + "b452e1844c266c5a6ce0633a44c36271.jpg";

/***/ },
/* 47 */
/***/ function(module, exports, __webpack_require__) {

	module.exports = __webpack_require__.p + "d07f7e8da2740a71875e6e932d1af604.png";

/***/ },
/* 48 */
/***/ function(module, exports, __webpack_require__) {

	module.exports = __webpack_require__.p + "4427801d181edcfed0afdb4665d8c38b.jpg";

/***/ },
/* 49 */
/***/ function(module, exports, __webpack_require__) {

	module.exports = __webpack_require__.p + "5be7a2784c653570910ab3c69ab8f0bb.jpg";

/***/ },
/* 50 */
/***/ function(module, exports, __webpack_require__) {

	module.exports = __webpack_require__.p + "0efd84c8ed658f046fb4c47895edb937.png";

/***/ },
/* 51 */
/***/ function(module, exports, __webpack_require__) {

	module.exports = __webpack_require__.p + "f9726a95bfd691a6b83f2f8d0ade0556.svg";

/***/ },
/* 52 */
/***/ function(module, exports, __webpack_require__) {

	module.exports = __webpack_require__.p + "713dc5d51f6cd85c70828cac2759d3bc.jpg";

/***/ },
/* 53 */
/***/ function(module, exports, __webpack_require__) {

	module.exports = __webpack_require__.p + "764672546b4fcde33a41d6e6c498f644.jpg";

/***/ },
/* 54 */
/***/ function(module, exports, __webpack_require__) {

	module.exports = __webpack_require__.p + "c903ec51974035760109dc4fb9b9447d.jpg";

/***/ },
/* 55 */
/***/ function(module, exports, __webpack_require__) {

	module.exports = __webpack_require__.p + "ae8ad378baff97860dc343b7df3332a1.jpg";

/***/ },
/* 56 */
/***/ function(module, exports, __webpack_require__) {

	module.exports = __webpack_require__.p + "e85f58be18d67fc1ebaf3c7a8d018260.jpg";

/***/ },
/* 57 */
/***/ function(module, exports, __webpack_require__) {

	module.exports = __webpack_require__.p + "3b3b4cab8d9407f9cce0a865e88ffe78.jpg";

/***/ },
/* 58 */
/***/ function(module, exports, __webpack_require__) {

	module.exports = __webpack_require__.p + "a8d85eafa39a85538fb2af962c9a2720.jpg";

/***/ },
/* 59 */
/***/ function(module, exports, __webpack_require__) {

	module.exports = __webpack_require__.p + "a800876fdd8983a904793f33d53cea63.jpg";

/***/ },
/* 60 */
/***/ function(module, exports, __webpack_require__) {

	module.exports = __webpack_require__.p + "4fe13517a16e1b123f89588e8969def6.svg";

/***/ },
/* 61 */
/***/ function(module, exports, __webpack_require__) {

	module.exports = __webpack_require__.p + "ac8fe890d7f17157c4eb1cc511fddcaf.jpg";

/***/ },
/* 62 */
/***/ function(module, exports, __webpack_require__) {

	module.exports = __webpack_require__.p + "e8bebbf0b98d4e8b2ffba9cc4cf774ba.jpg";

/***/ },
/* 63 */
/***/ function(module, exports, __webpack_require__) {

	module.exports = __webpack_require__.p + "16d2094763eb3b0cbb010d44ea3e7023.jpg";

/***/ },
/* 64 */
/***/ function(module, exports, __webpack_require__) {

	module.exports = __webpack_require__.p + "fa9778f2b326a0174018d6dcb10436e0.svg";

/***/ },
/* 65 */
/***/ function(module, exports, __webpack_require__) {

	module.exports = __webpack_require__.p + "ff05ee0f1d42c5f113c4bf37bb78c6d7.jpg";

/***/ },
/* 66 */
/***/ function(module, exports, __webpack_require__) {

	module.exports = __webpack_require__.p + "8c3af982c67910320f75fe83f311a792.jpg";

/***/ },
/* 67 */
/***/ function(module, exports, __webpack_require__) {

	module.exports = __webpack_require__.p + "b6e0cab17fdd72ed5ff26b1de9efb606.svg";

/***/ },
/* 68 */
/***/ function(module, exports, __webpack_require__) {

	module.exports = __webpack_require__.p + "6fd5b28b01b168dbf793436467211f78.svg";

/***/ },
/* 69 */
/***/ function(module, exports, __webpack_require__) {

	module.exports = __webpack_require__.p + "15eaabfbf1fa9dbe13f3fff44712ccfe.jpg";

/***/ },
/* 70 */
/***/ function(module, exports, __webpack_require__) {

	module.exports = __webpack_require__.p + "0e97eda7d383d34aa636df98f38385b9.svg";

/***/ },
/* 71 */
/***/ function(module, exports, __webpack_require__) {

	module.exports = __webpack_require__.p + "50ce313e5934b4baee1ffeac6e176fe9.svg";

/***/ },
/* 72 */
/***/ function(module, exports, __webpack_require__) {

	module.exports = __webpack_require__.p + "d263f8e0798be4451ee576c1919a2feb.jpg";

/***/ },
/* 73 */
/***/ function(module, exports, __webpack_require__) {

	module.exports = __webpack_require__.p + "44011bb8390ddc7d79dafb37638cb1bc.jpg";

/***/ },
/* 74 */
/***/ function(module, exports, __webpack_require__) {

	module.exports = __webpack_require__.p + "20080d6bf26b203336d913cd8d463ad4.jpg";

/***/ },
/* 75 */
/***/ function(module, exports, __webpack_require__) {

	module.exports = __webpack_require__.p + "07bdc531aa38c91b569eb9d37bb29c38.jpg";

/***/ },
/* 76 */
/***/ function(module, exports, __webpack_require__) {

	module.exports = __webpack_require__.p + "9fb55cd5a7f4f5cff03b3a82837c74c4.jpg";

/***/ },
/* 77 */
/***/ function(module, exports, __webpack_require__) {

	module.exports = __webpack_require__.p + "3beeeb0d72922367fad150969c1fe502.jpg";

/***/ },
/* 78 */
/***/ function(module, exports, __webpack_require__) {

	module.exports = __webpack_require__.p + "3edd8f032a1faeddda10bcb826100223.jpg";

/***/ },
/* 79 */
/***/ function(module, exports, __webpack_require__) {

	module.exports = __webpack_require__.p + "2d0b29da6ec3e10ed0788f8e4e25b6ae.jpg";

/***/ },
/* 80 */
/***/ function(module, exports, __webpack_require__) {

	module.exports = __webpack_require__.p + "7911ced760d19d9465bba44046346b51.jpg";

/***/ },
/* 81 */
/***/ function(module, exports, __webpack_require__) {

	module.exports = __webpack_require__.p + "f0d5c14ba54b4ebd9df60c9600648dbf.jpg";

/***/ },
/* 82 */
/***/ function(module, exports, __webpack_require__) {

	module.exports = __webpack_require__.p + "5a3e28303d49c14f6458fe9a67c35a82.jpg";

/***/ },
/* 83 */
/***/ function(module, exports, __webpack_require__) {

	module.exports = __webpack_require__.p + "4118e2e04597a01cd7cde1236ff13b92.jpg";

/***/ },
/* 84 */
/***/ function(module, exports, __webpack_require__) {

	module.exports = __webpack_require__.p + "dbbe426245a0644f50bc4742355fdd77.jpg";

/***/ },
/* 85 */
/***/ function(module, exports, __webpack_require__) {

	module.exports = __webpack_require__.p + "be09c829bc54b8634e79e56570703214.jpg";

/***/ },
/* 86 */
/***/ function(module, exports, __webpack_require__) {

	module.exports = __webpack_require__.p + "0e4b6840c502f5245bee9b08f233bcb0.jpg";

/***/ },
/* 87 */
/***/ function(module, exports, __webpack_require__) {

	module.exports = __webpack_require__.p + "0b2081b456bdc0e84bf3eb08635128c6.jpg";

/***/ },
/* 88 */
/***/ function(module, exports, __webpack_require__) {

	module.exports = __webpack_require__.p + "635909b36843df8c25cd4f0e9a43db06.jpg";

/***/ },
/* 89 */
/***/ function(module, exports, __webpack_require__) {

	module.exports = __webpack_require__.p + "acf4e5bab7a83aa54158988f860686dc.jpg";

/***/ },
/* 90 */
/***/ function(module, exports, __webpack_require__) {

	module.exports = __webpack_require__.p + "f99b25a37aeb25905f4556d5fb13c77e.jpg";

/***/ },
/* 91 */
/***/ function(module, exports, __webpack_require__) {

	module.exports = __webpack_require__.p + "ba4762b0624f843e1b73b39bfe7bfcbd.jpg";

/***/ },
/* 92 */
/***/ function(module, exports, __webpack_require__) {

	module.exports = __webpack_require__.p + "e737659557d4cff07f1ffe60a399cb23.jpg";

/***/ },
/* 93 */
/***/ function(module, exports, __webpack_require__) {

	var jade = __webpack_require__(94);

	module.exports = function template(locals) {
	var buf = [];
	var jade_mixins = {};
	var jade_interp;
	;var locals_for_with = (locals || {});(function (copy, page, pageData, undefined) {
	buf.push("");
	copy = __webpack_require__(30)
	page = "home"
	pageData = copy.content[page]
	buf.push("<!-- title and body copy--><section class=\"row no-padding home\"><div class=\"top-main col-md-12\"><h2> \nThe first agency site\u2028 <br>written by clients.</h2><p class=\"red\">Except for this part. </p><input type=\"checkbox\" id=\"toggle-featured-contributors\" class=\"view-this-part\"><label for=\"toggle-featured-contributors\" class=\"icon-right-arrow\"> </label><ul class=\"row no-padding featured-contributors\"><h6>Featured Contributors</h6>");
	// iterate pageData.contributors
	;(function(){
	  var $$obj = pageData.contributors;
	  if ('number' == typeof $$obj.length) {

	    for (var $index = 0, $$l = $$obj.length; $index < $$l; $index++) {
	      var contributorItem = $$obj[$index];

	buf.push("<li class=\"col-md-4\"> ");
	if ( contributorItem.contributorAvatar )
	{
	buf.push("<img" + (jade.attr("src", contributorItem.contributorAvatar, true, true)) + ">");
	}
	buf.push("<cite>");
	if ( contributorItem.name)
	{
	buf.push("<span>" + (null == (jade_interp = contributorItem.name) ? "" : jade_interp) + "</span>");
	}
	if ( contributorItem.jobTitle)
	{
	buf.push("<span>" + (null == (jade_interp = contributorItem.jobTitle) ? "" : jade_interp) + "</span>");
	}
	buf.push("</cite>");
	if ( contributorItem.project)
	{
	buf.push("<p>" + (null == (jade_interp = contributorItem.project) ? "" : jade_interp) + "</p>");
	}
	buf.push("<a href=\"#\" class=\"red\">Read full articles &gt;</a></li>");
	    }

	  } else {
	    var $$l = 0;
	    for (var $index in $$obj) {
	      $$l++;      var contributorItem = $$obj[$index];

	buf.push("<li class=\"col-md-4\"> ");
	if ( contributorItem.contributorAvatar )
	{
	buf.push("<img" + (jade.attr("src", contributorItem.contributorAvatar, true, true)) + ">");
	}
	buf.push("<cite>");
	if ( contributorItem.name)
	{
	buf.push("<span>" + (null == (jade_interp = contributorItem.name) ? "" : jade_interp) + "</span>");
	}
	if ( contributorItem.jobTitle)
	{
	buf.push("<span>" + (null == (jade_interp = contributorItem.jobTitle) ? "" : jade_interp) + "</span>");
	}
	buf.push("</cite>");
	if ( contributorItem.project)
	{
	buf.push("<p>" + (null == (jade_interp = contributorItem.project) ? "" : jade_interp) + "</p>");
	}
	buf.push("<a href=\"#\" class=\"red\">Read full articles &gt;</a></li>");
	    }

	  }
	}).call(this);

	buf.push("<div class=\"clear\"></div><div class=\"see-more\"><input type=\"checkbox\" name=\"toggle\" id=\"toggle\" class=\"red view-more\"><label for=\"toggle\"> </label><div class=\"see-more-container\">");
	// iterate pageData.contributorsMore
	;(function(){
	  var $$obj = pageData.contributorsMore;
	  if ('number' == typeof $$obj.length) {

	    for (var $index = 0, $$l = $$obj.length; $index < $$l; $index++) {
	      var contributorItem = $$obj[$index];

	buf.push("<li class=\"col-md-4\"> ");
	if ( contributorItem.contributorAvatar )
	{
	buf.push("<img" + (jade.attr("src", contributorItem.contributorAvatar, true, true)) + ">");
	}
	buf.push("<cite>");
	if ( contributorItem.name)
	{
	buf.push("<span>" + (null == (jade_interp = contributorItem.name) ? "" : jade_interp) + "</span>");
	}
	if ( contributorItem.jobTitle)
	{
	buf.push("<span>" + (null == (jade_interp = contributorItem.jobTitle) ? "" : jade_interp) + "</span>");
	}
	buf.push("</cite>");
	if ( contributorItem.project)
	{
	buf.push("<p>" + (null == (jade_interp = contributorItem.project) ? "" : jade_interp) + "</p>");
	}
	buf.push("<a href=\"#\" class=\"red\">Read full articles &gt;</a></li>");
	    }

	  } else {
	    var $$l = 0;
	    for (var $index in $$obj) {
	      $$l++;      var contributorItem = $$obj[$index];

	buf.push("<li class=\"col-md-4\"> ");
	if ( contributorItem.contributorAvatar )
	{
	buf.push("<img" + (jade.attr("src", contributorItem.contributorAvatar, true, true)) + ">");
	}
	buf.push("<cite>");
	if ( contributorItem.name)
	{
	buf.push("<span>" + (null == (jade_interp = contributorItem.name) ? "" : jade_interp) + "</span>");
	}
	if ( contributorItem.jobTitle)
	{
	buf.push("<span>" + (null == (jade_interp = contributorItem.jobTitle) ? "" : jade_interp) + "</span>");
	}
	buf.push("</cite>");
	if ( contributorItem.project)
	{
	buf.push("<p>" + (null == (jade_interp = contributorItem.project) ? "" : jade_interp) + "</p>");
	}
	buf.push("<a href=\"#\" class=\"red\">Read full articles &gt;</a></li>");
	    }

	  }
	}).call(this);

	buf.push("</div></div></ul></div></section>");}.call(this,"copy" in locals_for_with?locals_for_with.copy:typeof copy!=="undefined"?copy:undefined,"page" in locals_for_with?locals_for_with.page:typeof page!=="undefined"?page:undefined,"pageData" in locals_for_with?locals_for_with.pageData:typeof pageData!=="undefined"?pageData:undefined,"undefined" in locals_for_with?locals_for_with.undefined: false?undefined:undefined));;return buf.join("");
	}

/***/ },
/* 94 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	/**
	 * Merge two attribute objects giving precedence
	 * to values in object `b`. Classes are special-cased
	 * allowing for arrays and merging/joining appropriately
	 * resulting in a string.
	 *
	 * @param {Object} a
	 * @param {Object} b
	 * @return {Object} a
	 * @api private
	 */

	exports.merge = function merge(a, b) {
	  if (arguments.length === 1) {
	    var attrs = a[0];
	    for (var i = 1; i < a.length; i++) {
	      attrs = merge(attrs, a[i]);
	    }
	    return attrs;
	  }
	  var ac = a['class'];
	  var bc = b['class'];

	  if (ac || bc) {
	    ac = ac || [];
	    bc = bc || [];
	    if (!Array.isArray(ac)) ac = [ac];
	    if (!Array.isArray(bc)) bc = [bc];
	    a['class'] = ac.concat(bc).filter(nulls);
	  }

	  for (var key in b) {
	    if (key != 'class') {
	      a[key] = b[key];
	    }
	  }

	  return a;
	};

	/**
	 * Filter null `val`s.
	 *
	 * @param {*} val
	 * @return {Boolean}
	 * @api private
	 */

	function nulls(val) {
	  return val != null && val !== '';
	}

	/**
	 * join array as classes.
	 *
	 * @param {*} val
	 * @return {String}
	 */
	exports.joinClasses = joinClasses;
	function joinClasses(val) {
	  return (Array.isArray(val) ? val.map(joinClasses) :
	    (val && typeof val === 'object') ? Object.keys(val).filter(function (key) { return val[key]; }) :
	    [val]).filter(nulls).join(' ');
	}

	/**
	 * Render the given classes.
	 *
	 * @param {Array} classes
	 * @param {Array.<Boolean>} escaped
	 * @return {String}
	 */
	exports.cls = function cls(classes, escaped) {
	  var buf = [];
	  for (var i = 0; i < classes.length; i++) {
	    if (escaped && escaped[i]) {
	      buf.push(exports.escape(joinClasses([classes[i]])));
	    } else {
	      buf.push(joinClasses(classes[i]));
	    }
	  }
	  var text = joinClasses(buf);
	  if (text.length) {
	    return ' class="' + text + '"';
	  } else {
	    return '';
	  }
	};


	exports.style = function (val) {
	  if (val && typeof val === 'object') {
	    return Object.keys(val).map(function (style) {
	      return style + ':' + val[style];
	    }).join(';');
	  } else {
	    return val;
	  }
	};
	/**
	 * Render the given attribute.
	 *
	 * @param {String} key
	 * @param {String} val
	 * @param {Boolean} escaped
	 * @param {Boolean} terse
	 * @return {String}
	 */
	exports.attr = function attr(key, val, escaped, terse) {
	  if (key === 'style') {
	    val = exports.style(val);
	  }
	  if ('boolean' == typeof val || null == val) {
	    if (val) {
	      return ' ' + (terse ? key : key + '="' + key + '"');
	    } else {
	      return '';
	    }
	  } else if (0 == key.indexOf('data') && 'string' != typeof val) {
	    if (JSON.stringify(val).indexOf('&') !== -1) {
	      console.warn('Since Jade 2.0.0, ampersands (`&`) in data attributes ' +
	                   'will be escaped to `&amp;`');
	    };
	    if (val && typeof val.toISOString === 'function') {
	      console.warn('Jade will eliminate the double quotes around dates in ' +
	                   'ISO form after 2.0.0');
	    }
	    return ' ' + key + "='" + JSON.stringify(val).replace(/'/g, '&apos;') + "'";
	  } else if (escaped) {
	    if (val && typeof val.toISOString === 'function') {
	      console.warn('Jade will stringify dates in ISO form after 2.0.0');
	    }
	    return ' ' + key + '="' + exports.escape(val) + '"';
	  } else {
	    if (val && typeof val.toISOString === 'function') {
	      console.warn('Jade will stringify dates in ISO form after 2.0.0');
	    }
	    return ' ' + key + '="' + val + '"';
	  }
	};

	/**
	 * Render the given attributes object.
	 *
	 * @param {Object} obj
	 * @param {Object} escaped
	 * @return {String}
	 */
	exports.attrs = function attrs(obj, terse){
	  var buf = [];

	  var keys = Object.keys(obj);

	  if (keys.length) {
	    for (var i = 0; i < keys.length; ++i) {
	      var key = keys[i]
	        , val = obj[key];

	      if ('class' == key) {
	        if (val = joinClasses(val)) {
	          buf.push(' ' + key + '="' + val + '"');
	        }
	      } else {
	        buf.push(exports.attr(key, val, false, terse));
	      }
	    }
	  }

	  return buf.join('');
	};

	/**
	 * Escape the given string of `html`.
	 *
	 * @param {String} html
	 * @return {String}
	 * @api private
	 */

	var jade_encode_html_rules = {
	  '&': '&amp;',
	  '<': '&lt;',
	  '>': '&gt;',
	  '"': '&quot;'
	};
	var jade_match_html = /[&<>"]/g;

	function jade_encode_char(c) {
	  return jade_encode_html_rules[c] || c;
	}

	exports.escape = jade_escape;
	function jade_escape(html){
	  var result = String(html).replace(jade_match_html, jade_encode_char);
	  if (result === '' + html) return html;
	  else return result;
	};

	/**
	 * Re-throw the given `err` in context to the
	 * the jade in `filename` at the given `lineno`.
	 *
	 * @param {Error} err
	 * @param {String} filename
	 * @param {String} lineno
	 * @api private
	 */

	exports.rethrow = function rethrow(err, filename, lineno, str){
	  if (!(err instanceof Error)) throw err;
	  if ((typeof window != 'undefined' || !filename) && !str) {
	    err.message += ' on line ' + lineno;
	    throw err;
	  }
	  try {
	    str = str || __webpack_require__(95).readFileSync(filename, 'utf8')
	  } catch (ex) {
	    rethrow(err, null, lineno)
	  }
	  var context = 3
	    , lines = str.split('\n')
	    , start = Math.max(lineno - context, 0)
	    , end = Math.min(lines.length, lineno + context);

	  // Error context
	  var context = lines.slice(start, end).map(function(line, i){
	    var curr = i + start + 1;
	    return (curr == lineno ? '  > ' : '    ')
	      + curr
	      + '| '
	      + line;
	  }).join('\n');

	  // Alter exception message
	  err.path = filename;
	  err.message = (filename || 'Jade') + ':' + lineno
	    + '\n' + context + '\n\n' + err.message;
	  throw err;
	};

	exports.DebugItem = function DebugItem(lineno, filename) {
	  this.lineno = lineno;
	  this.filename = filename;
	}


/***/ },
/* 95 */
/***/ function(module, exports) {

	/* (ignored) */

/***/ },
/* 96 */
/***/ function(module, exports, __webpack_require__) {

	var jade = __webpack_require__(94);

	module.exports = function template(locals) {
	var buf = [];
	var jade_mixins = {};
	var jade_interp;
	;var locals_for_with = (locals || {});(function (copy, page, pageData) {
	buf.push("");
	copy = __webpack_require__(30)
	page = "about"
	pageData = copy.content[page]
	buf.push("<!-- title and body copy--><section class=\"row no-padding about\"><div class=\"top-main col-md-12\"><h2> \nSomething like <br> a Phenomenon.</h2><p>A behind the scenes look at the most\u2028appropriately-named agency I know.</p><cite><img" + (jade.attr("src", __webpack_require__(97), true, true)) + "><span>By Kevin Dahlstrom </span><span> \nChief Marketing Office, Mr. Cooper Home Loans</span></cite></div><div class=\"col-xs-12 col-md-12 no-padding\"><div class=\"col-xs-12 col-md-5 no-padding\"><figure><img" + (jade.attr("src", __webpack_require__(98), true, true)) + "><figcaption><h3>Phenotype</h3><ul> <span>nonu</span><li>1. a person adept at solving problems.</li><span>verb</span><li>2. to carry out a solution in any direction that is correct for the problem.</li></ul></figcaption></figure></div><section class=\"col-xs-12 col-md-7 no-padding\"><article class=\"col-md-12 border-bottom\"><p>I first met Phenomenon in 2010 when I was looking for an agency to help launch a Payday Loan company. Pheno was a small shop and I was sure that we would be one of their biggest clients, so I was excited to talk to them. But when I got them on the phone and explained the brief to them, they weren't interested. </p><p>\tYears later, as we sat down on the 28th floor of the SBE building in Los Angeles, our conversation began with that rather inauspicious start.</p></article><article class=\"col-md-12\"><p>So, do you say, \"no\" to every client at first, or was it just me?<span>PHENO: Ha! So this is where you want to start?</span></p><p>Absolutely<span> \nLook, we throw ourselves into everything we do. We work long hours, we scrutinize, we push. We really go all out. And to put that much effort into something, we have to believe in it. And, truthfully, the Payday Loan business had a lot of negative implications with predatory lending and all that. And it just didn't feel like the kind of thing we could feel good about.</span></p><p>So what changed your mind?<span> \nThe second you gave us the permission to help you create a new kind of company, one that actually helped people break the cycle of poverty and bad credit, we were in. 100%. We're actually not very good at working with clients who want more of the same. It's when they want to radically change their business, growth, trajectory and market share that we're the right firm to call. </span></p><p>\tSo you kind of self-select clients that are going to appreciate the kind of work you do.<span>Very much so.</span></p></article></section></div><div class=\"col-xs-12 col-md-12 no-padding\"><img" + (jade.attr("src", __webpack_require__(99), true, true)) + "></div><div class=\"col-md-12 no-padding\"><div class=\"col-md-5 no-padding\"></div><div class=\"col-md-7 no-padding\"><article class=\"col-md-12\"><p> \nYou guys do a lot of different things for clients. You're not an ad agency, but you make ads. You're not a strategy firm, but you do strategy... how do you explain what it is you're all about?<span> \nIt's always hard to define something that's completely new and different and a departure from everything that's come before it. First and foremost we're an Innovations Agency. Sometimes that innovation is an app, tool or piece of technology. Sometimes it's a product. Sometimes it's a radical business strategy. Sometimes it's a new retail concept.  Sometimes it's inventing a whole new brand or category. Sometimes it's an ad campaign. And fairly often it's all of the above. </span></p><p> \nRight, but playing devil's advocate for a second, that's the same stuff that everyone promises. How are you any different?<span> \nAh, my favorite question. So historically there are 4 types of agencies: Strategic Agencies that can analyze your business, Design Agencies that can do your graphic ID, packaging and brand guidelines, Digital Agencies that can do your websites and apps and Advertising Agencies that can do your brand campaign or retail work. </span><span> \nAnd you're right, to some degree they all claim to be able to do everything. But truthfully, they have a legacy as a specific kind of agency, and they are geared to create a certain kind of deliverable.</span></p><p> \nRight. I know if I go to an Ad Agency with my problem, I'm going to get an ad campaign as the solution</p><p> <span>Exactly! Which makes perfect sense because that's what they're built to make. They invest their money in people that make ads, and they need a return on that investment. They may hire a digital leader, or a proper business strategist, but that person is always going to feel a bit like a fish out of water in that kind of environment. And unfortunately, they'll feel like a second class citizen because their work isn't driving revenue anywhere near the level that the advertising is. </span></p><p>\t<span>When a client talks to us, we don't have any preconceived notions about what the solution will be. We always start with strategic insights and go from there. Based on the results, we may recommend a product portfolio solution, or an app/utility solution, or a user experience solution, or an integrated ad campaign. Or something completely different that's never been done before. </span></p><p><span>To put it simply, everyone else is trying, very slowly, to move to the intersection of the 4 types of agencies, but we don't need to move an inch, because we were actually born there.</span></p><img" + (jade.attr("src", __webpack_require__(100), true, true)) + "></article></div></div><div class=\"col-md-12 no-padding\"><div class=\"col-md-5 no-padding\"><section class=\"ac-container\"><div class=\"test\"><input id=\"ac-1\" name=\"accordion-1\" type=\"radio\" checked=\"\"><label for=\"ac-1\">Marketing Innovation</label><article class=\"ac-small\"><p>We help consumer companies refocus their marketing spend, evolve their brands, and take advantage of \"big idea\" thinking.</p></article></div><div class=\"test\"><input id=\"ac-2\" name=\"accordion-1\" type=\"radio\"><label for=\"ac-2\">UX Innovation</label><article class=\"ac-small\"><p>We help consumer companies refocus their marketing spend, evolve their brands, and take advantage of \"big idea\" thinking.</p></article></div><div class=\"test\"><input id=\"ac-3\" name=\"accordion-1\" type=\"radio\"><label for=\"ac-3\">Digital Innovation</label><article class=\"ac-small\"><p>We help consumer companies refocus their marketing spend, evolve their brands, and take advantage of \"big idea\" thinking.</p></article></div><div class=\"test\"><input id=\"ac-4\" name=\"accordion-1\" type=\"radio\"><label for=\"ac-4\">Cultural Innovation</label><article class=\"ac-small\"><p>We help consumer companies refocus their marketing spend, evolve their brands, and take advantage of \"big idea\" thinking.</p></article></div></section></div><div class=\"col-md-7 no-padding\"><article class=\"col-md-12\"><p> \nOK, but can you really claim to be experts in each of those categories? How are you not a jack of all trades and master of none?</p><p> <span>We've been giving it a lot of thought and we think there are two things that made this happen: our people and our organization. </span></p><p>\t<span>Our people are strategists who love strategy, but hate the limits of working at a strategy firm. They're designers who love design, but feel handcuffed working at a pure design shop. They're digital leaders who don't want to be so disconnected from the brand thinking. And they're ad agency leaders who are sick and tired of being relegated to just TV, Print and Out of Home. They're all looking for innovation. And our organization gives them the ability to apply their skills in all kinds of new ways.</span></p><p><span>We fundamentally understand each of these disciplines and how to plug them into the agency. They aren't bolted onto the framework as an added discipline. They are a part of the gears and fabric of the agency at a very core lev</span></p><p> \nIt's interesting that you say that your talent is looking for innovation, because as a client, that's exactly what I'm looking for too.</p><p> <span>Right, and when the client's ambitions mesh with the agency's ambitions and the ambitions of the individuals that work there, that's when great things happen.</span></p><p>So how do you do it? How do you innovate? What's your process?<span> \nWell, off the bat if anyone claims to be innovative but sells you on a rigid process, they're selling snake oil. We have a framework called Phenomenology that allows us to start each process with a roadmap, but we never use it the exact same way twice. We are always re-inventing it for the task at hand. </span><span> \nThe general categories that we apply Phenomenology to are Marketing Innovation, UX Innovation, Digital Innovation and Cultural Innovation. </span><span> \nBut what sets us a part is that at every step of the process, we stop and question if our thinking has gone far enough. Is there a new piece of technology that can make this even better? How can it be more social and more participatory? Is there a way to simplify the user journey? Is this as big and powerful as it can be?</span></p><p>Well, I can attest to the fact that it works. You killed it for me on both Rise and Sunny, and now Mr. Cooper. It's just amazing work and I'm always looking forward to our next conversation.<span> \nThanks! We live for this kind of stuff. </span></p><p>\t\nAlright, to wrap this up, I thought you guys were the communications experts, so why do you have clients doing all the writing on your website?<span>When agencies try to explain what they do and why they're good at it, they just always sound so pompous and full of themselveseven the really good ones. And that's not us. We think what our clients have to say is much more interesting than what we have to say. Plus we thought it would be fun.</span></p></article></div></div></section><!--include ./components/content-template.jade-->");}.call(this,"copy" in locals_for_with?locals_for_with.copy:typeof copy!=="undefined"?copy:undefined,"page" in locals_for_with?locals_for_with.page:typeof page!=="undefined"?page:undefined,"pageData" in locals_for_with?locals_for_with.pageData:typeof pageData!=="undefined"?pageData:undefined));;return buf.join("");
	}

/***/ },
/* 97 */
/***/ function(module, exports, __webpack_require__) {

	module.exports = __webpack_require__.p + "3a0a4e6220242549635c1e2ace56f4b6.png";

/***/ },
/* 98 */
/***/ function(module, exports, __webpack_require__) {

	module.exports = __webpack_require__.p + "741fd50068f8498aafa60c4562563674.png";

/***/ },
/* 99 */
/***/ function(module, exports, __webpack_require__) {

	module.exports = __webpack_require__.p + "8a0ae414ba18df9fac6920c643dbbdfd.png";

/***/ },
/* 100 */
/***/ function(module, exports, __webpack_require__) {

	module.exports = __webpack_require__.p + "0f98fc6faef7da614f8cbd9a1e7a2a5e.png";

/***/ },
/* 101 */
/***/ function(module, exports, __webpack_require__) {

	var jade = __webpack_require__(94);

	module.exports = function template(locals) {
	var buf = [];
	var jade_mixins = {};
	var jade_interp;
	;var locals_for_with = (locals || {});(function (copy, page, pageData, undefined) {
	buf.push("");
	copy = __webpack_require__(30)
	page = "work"
	pageData = copy.content[page]
	buf.push("<section class=\"row no-padding work\"><article class=\"col-md-12 no-padding top-main\"><h2> <blockquote> \nA lot of the work they do is confidential. <br>Here's some that isn't.</blockquote></h2><cite><img" + (jade.attr("src", __webpack_require__(97), true, true)) + "><span>Mike Dowse</span><span>CEO, Wilson</span></cite></article>");
	// iterate pageData.subcontent 
	;(function(){
	  var $$obj = pageData.subcontent ;
	  if ('number' == typeof $$obj.length) {

	    for (var $index = 0, $$l = $$obj.length; $index < $$l; $index++) {
	      var contentItem = $$obj[$index];

	buf.push("<article class=\"col-md-12 no-padding\"><div class=\"col-xs-12 col-sm-12 col-md-8\">");
	if ( contentItem.image)
	{
	buf.push("<img" + (jade.attr("src", contentItem.imageUrl, true, true)) + (jade.attr("alt", contentItem.imageAlt, true, true)) + ">");
	}
	buf.push("</div><div class=\"col-xs-12 col-sm-12 col-md-4\"><fieldset><legend>" + (jade.escape(null == (jade_interp = contentItem.legend) ? "" : jade_interp)) + "</legend><h3>" + (jade.escape(null == (jade_interp = contentItem.headline) ? "" : jade_interp)) + "</h3><cite><span>By Amy Weisenbach</span><span>VP Marketing, Wilson</span></cite><div class=\"line\"></div><p>" + (jade.escape(null == (jade_interp = contentItem.description) ? "" : jade_interp)) + "</p><a" + (jade.attr("href", contentItem.readmoreUrl, true, true)) + " class=\"red\">Read More &gt; </a></fieldset></div></article>");
	    }

	  } else {
	    var $$l = 0;
	    for (var $index in $$obj) {
	      $$l++;      var contentItem = $$obj[$index];

	buf.push("<article class=\"col-md-12 no-padding\"><div class=\"col-xs-12 col-sm-12 col-md-8\">");
	if ( contentItem.image)
	{
	buf.push("<img" + (jade.attr("src", contentItem.imageUrl, true, true)) + (jade.attr("alt", contentItem.imageAlt, true, true)) + ">");
	}
	buf.push("</div><div class=\"col-xs-12 col-sm-12 col-md-4\"><fieldset><legend>" + (jade.escape(null == (jade_interp = contentItem.legend) ? "" : jade_interp)) + "</legend><h3>" + (jade.escape(null == (jade_interp = contentItem.headline) ? "" : jade_interp)) + "</h3><cite><span>By Amy Weisenbach</span><span>VP Marketing, Wilson</span></cite><div class=\"line\"></div><p>" + (jade.escape(null == (jade_interp = contentItem.description) ? "" : jade_interp)) + "</p><a" + (jade.attr("href", contentItem.readmoreUrl, true, true)) + " class=\"red\">Read More &gt; </a></fieldset></div></article>");
	    }

	  }
	}).call(this);

	buf.push("</section>");}.call(this,"copy" in locals_for_with?locals_for_with.copy:typeof copy!=="undefined"?copy:undefined,"page" in locals_for_with?locals_for_with.page:typeof page!=="undefined"?page:undefined,"pageData" in locals_for_with?locals_for_with.pageData:typeof pageData!=="undefined"?pageData:undefined,"undefined" in locals_for_with?locals_for_with.undefined: false?undefined:undefined));;return buf.join("");
	}

/***/ },
/* 102 */
/***/ function(module, exports, __webpack_require__) {

	var jade = __webpack_require__(94);

	module.exports = function template(locals) {
	var buf = [];
	var jade_mixins = {};
	var jade_interp;
	;var locals_for_with = (locals || {});(function (copy, page, pageData, undefined) {
	buf.push("");
	copy = __webpack_require__(30)
	page = "wilson-anthem"
	pageData = copy.content[page] 
	buf.push("<!-- dynamically populate content from copy.json data-->");
	copy = __webpack_require__(30)
	pageData = copy.content[page]
	buf.push("<section class=\"row no-padding work work-details\"><article class=\"col-md-12 no-padding top-main\"><h2> <blockquote>" + (null == (jade_interp = pageData.blockquote) ? "" : jade_interp) + "</blockquote></h2><cite><img src=\"assets/images/about/about-avatar.png\"><span>Mike Dowse</span><span>CEO, Wilson</span></cite></article><article class=\"col-md-12 no-padding\"><div class=\"col-md-7 top-description\">");
	if ( pageData.topDescription)
	{
	// iterate pageData.topDescription
	;(function(){
	  var $$obj = pageData.topDescription;
	  if ('number' == typeof $$obj.length) {

	    for (var $index = 0, $$l = $$obj.length; $index < $$l; $index++) {
	      var par = $$obj[$index];

	buf.push("<p>" + (null == (jade_interp = par) ? "" : jade_interp) + "</p>");
	    }

	  } else {
	    var $$l = 0;
	    for (var $index in $$obj) {
	      $$l++;      var par = $$obj[$index];

	buf.push("<p>" + (null == (jade_interp = par) ? "" : jade_interp) + "</p>");
	    }

	  }
	}).call(this);

	}
	buf.push("</div><div class=\"col-md-4 col-md-offset-1\"><aside><img" + (jade.attr("src", pageData.clientLogo, true, true)) + " class=\"clientlogo\"><fieldset> <legend>Client</legend><span>" + (jade.escape(null == (jade_interp = pageData.client) ? "" : jade_interp)) + "</span></fieldset><fieldset> <legend>Project</legend><span>" + (jade.escape(null == (jade_interp = pageData.project) ? "" : jade_interp)) + "</span></fieldset><fieldset> <legend>Media</legend><span>" + (jade.escape(null == (jade_interp = pageData.media) ? "" : jade_interp)) + "</span></fieldset><fieldset><legend class=\"share\">Share</legend></fieldset></aside></div></article>");
	// iterate pageData.detailcontent
	;(function(){
	  var $$obj = pageData.detailcontent;
	  if ('number' == typeof $$obj.length) {

	    for (var $index = 0, $$l = $$obj.length; $index < $$l; $index++) {
	      var contentItem = $$obj[$index];

	buf.push("<article class=\"col-md-12 no-padding\">");
	if ( contentItem.video)
	{
	buf.push("<video-component" + (jade.attr("thumb", contentItem.thumb, true, true)) + (jade.attr("alt", contentItem.thumbAlt, true, true)) + (jade.attr("title", contentItem.thumbTitle, true, true)) + (jade.attr("vimeo", contentItem.vimeo, true, true)) + "></video-component>");
	}
	if ( contentItem.carousel)
	{
	buf.push("<carousel-component class=\"carousel-component component section no-padding\">");
	// iterate contentItem.images
	;(function(){
	  var $$obj = contentItem.images;
	  if ('number' == typeof $$obj.length) {

	    for (var $index = 0, $$l = $$obj.length; $index < $$l; $index++) {
	      var carouselItem = $$obj[$index];

	buf.push("<img" + (jade.attr("src", carouselItem.url, true, true)) + (jade.attr("alt", carouselItem.alt, true, true)) + ">");
	    }

	  } else {
	    var $$l = 0;
	    for (var $index in $$obj) {
	      $$l++;      var carouselItem = $$obj[$index];

	buf.push("<img" + (jade.attr("src", carouselItem.url, true, true)) + (jade.attr("alt", carouselItem.alt, true, true)) + ">");
	    }

	  }
	}).call(this);

	buf.push("</carousel-component>");
	}
	if ( contentItem.image)
	{
	buf.push("<section class=\"image-component component row no-padding\"><div class=\"col-xs-12 no-padding\"><img" + (jade.attr("src", contentItem.imageUrl, true, true)) + (jade.attr("alt", contentItem.imageAlt, true, true)) + "></div></section>");
	}
	if ( contentItem.mainDescription)
	{
	// iterate contentItem.mainDescription
	;(function(){
	  var $$obj = contentItem.mainDescription;
	  if ('number' == typeof $$obj.length) {

	    for (var $index = 0, $$l = $$obj.length; $index < $$l; $index++) {
	      var par = $$obj[$index];

	buf.push("<p>" + (jade.escape(null == (jade_interp = par) ? "" : jade_interp)) + "</p>");
	    }

	  } else {
	    var $$l = 0;
	    for (var $index in $$obj) {
	      $$l++;      var par = $$obj[$index];

	buf.push("<p>" + (jade.escape(null == (jade_interp = par) ? "" : jade_interp)) + "</p>");
	    }

	  }
	}).call(this);

	}
	buf.push("</article>");
	    }

	  } else {
	    var $$l = 0;
	    for (var $index in $$obj) {
	      $$l++;      var contentItem = $$obj[$index];

	buf.push("<article class=\"col-md-12 no-padding\">");
	if ( contentItem.video)
	{
	buf.push("<video-component" + (jade.attr("thumb", contentItem.thumb, true, true)) + (jade.attr("alt", contentItem.thumbAlt, true, true)) + (jade.attr("title", contentItem.thumbTitle, true, true)) + (jade.attr("vimeo", contentItem.vimeo, true, true)) + "></video-component>");
	}
	if ( contentItem.carousel)
	{
	buf.push("<carousel-component class=\"carousel-component component section no-padding\">");
	// iterate contentItem.images
	;(function(){
	  var $$obj = contentItem.images;
	  if ('number' == typeof $$obj.length) {

	    for (var $index = 0, $$l = $$obj.length; $index < $$l; $index++) {
	      var carouselItem = $$obj[$index];

	buf.push("<img" + (jade.attr("src", carouselItem.url, true, true)) + (jade.attr("alt", carouselItem.alt, true, true)) + ">");
	    }

	  } else {
	    var $$l = 0;
	    for (var $index in $$obj) {
	      $$l++;      var carouselItem = $$obj[$index];

	buf.push("<img" + (jade.attr("src", carouselItem.url, true, true)) + (jade.attr("alt", carouselItem.alt, true, true)) + ">");
	    }

	  }
	}).call(this);

	buf.push("</carousel-component>");
	}
	if ( contentItem.image)
	{
	buf.push("<section class=\"image-component component row no-padding\"><div class=\"col-xs-12 no-padding\"><img" + (jade.attr("src", contentItem.imageUrl, true, true)) + (jade.attr("alt", contentItem.imageAlt, true, true)) + "></div></section>");
	}
	if ( contentItem.mainDescription)
	{
	// iterate contentItem.mainDescription
	;(function(){
	  var $$obj = contentItem.mainDescription;
	  if ('number' == typeof $$obj.length) {

	    for (var $index = 0, $$l = $$obj.length; $index < $$l; $index++) {
	      var par = $$obj[$index];

	buf.push("<p>" + (jade.escape(null == (jade_interp = par) ? "" : jade_interp)) + "</p>");
	    }

	  } else {
	    var $$l = 0;
	    for (var $index in $$obj) {
	      $$l++;      var par = $$obj[$index];

	buf.push("<p>" + (jade.escape(null == (jade_interp = par) ? "" : jade_interp)) + "</p>");
	    }

	  }
	}).call(this);

	}
	buf.push("</article>");
	    }

	  }
	}).call(this);

	buf.push("<!-- dynamically populate content from copy.json data-->");
	page = "moreCases"
	pageData = copy.content[page]
	buf.push("<section class=\"col-md-12 no-padding more-cases\"> <div class=\"more-case-wrapper cf\">");
	// iterate pageData
	;(function(){
	  var $$obj = pageData;
	  if ('number' == typeof $$obj.length) {

	    for (var $index = 0, $$l = $$obj.length; $index < $$l; $index++) {
	      var contentItem = $$obj[$index];

	buf.push("<article class=\"col-md-4\"> <img" + (jade.attr("src", __webpack_require__(103), true, true)) + "><p>" + (null == (jade_interp = contentItem.projectName) ? "" : jade_interp) + "<cite><span>" + (jade.escape(null == (jade_interp = contentItem.writerName) ? "" : jade_interp)) + "</span><span>" + (jade.escape(null == (jade_interp = contentItem.writerTitle) ? "" : jade_interp)) + "</span></cite></p><a href=\"#\" class=\"red\">read full article</a></article>");
	    }

	  } else {
	    var $$l = 0;
	    for (var $index in $$obj) {
	      $$l++;      var contentItem = $$obj[$index];

	buf.push("<article class=\"col-md-4\"> <img" + (jade.attr("src", __webpack_require__(103), true, true)) + "><p>" + (null == (jade_interp = contentItem.projectName) ? "" : jade_interp) + "<cite><span>" + (jade.escape(null == (jade_interp = contentItem.writerName) ? "" : jade_interp)) + "</span><span>" + (jade.escape(null == (jade_interp = contentItem.writerTitle) ? "" : jade_interp)) + "</span></cite></p><a href=\"#\" class=\"red\">read full article</a></article>");
	    }

	  }
	}).call(this);

	buf.push("</div></section></section>");}.call(this,"copy" in locals_for_with?locals_for_with.copy:typeof copy!=="undefined"?copy:undefined,"page" in locals_for_with?locals_for_with.page:typeof page!=="undefined"?page:undefined,"pageData" in locals_for_with?locals_for_with.pageData:typeof pageData!=="undefined"?pageData:undefined,"undefined" in locals_for_with?locals_for_with.undefined: false?undefined:undefined));;return buf.join("");
	}

/***/ },
/* 103 */
/***/ function(module, exports, __webpack_require__) {

	module.exports = __webpack_require__.p + "05bfcf3f56110e615c09123dd5b90e0d.jpg";

/***/ },
/* 104 */
/***/ function(module, exports, __webpack_require__) {

	var jade = __webpack_require__(94);

	module.exports = function template(locals) {
	var buf = [];
	var jade_mixins = {};
	var jade_interp;
	;var locals_for_with = (locals || {});(function (copy, page, pageData, undefined) {
	buf.push("");
	copy = __webpack_require__(30)
	page = "wilsonX"
	pageData = copy.content[page] 
	buf.push("<!-- dynamically populate content from copy.json data-->");
	copy = __webpack_require__(30)
	pageData = copy.content[page]
	buf.push("<section class=\"row no-padding work work-details\"><article class=\"col-md-12 no-padding top-main\"><h2> <blockquote>" + (null == (jade_interp = pageData.blockquote) ? "" : jade_interp) + "</blockquote></h2><cite><img src=\"assets/images/about/about-avatar.png\"><span>Mike Dowse</span><span>CEO, Wilson</span></cite></article><article class=\"col-md-12 no-padding\"><div class=\"col-md-7 top-description\">");
	if ( pageData.topDescription)
	{
	// iterate pageData.topDescription
	;(function(){
	  var $$obj = pageData.topDescription;
	  if ('number' == typeof $$obj.length) {

	    for (var $index = 0, $$l = $$obj.length; $index < $$l; $index++) {
	      var par = $$obj[$index];

	buf.push("<p>" + (null == (jade_interp = par) ? "" : jade_interp) + "</p>");
	    }

	  } else {
	    var $$l = 0;
	    for (var $index in $$obj) {
	      $$l++;      var par = $$obj[$index];

	buf.push("<p>" + (null == (jade_interp = par) ? "" : jade_interp) + "</p>");
	    }

	  }
	}).call(this);

	}
	buf.push("</div><div class=\"col-md-4 col-md-offset-1\"><aside><img" + (jade.attr("src", pageData.clientLogo, true, true)) + " class=\"clientlogo\"><fieldset> <legend>Client</legend><span>" + (jade.escape(null == (jade_interp = pageData.client) ? "" : jade_interp)) + "</span></fieldset><fieldset> <legend>Project</legend><span>" + (jade.escape(null == (jade_interp = pageData.project) ? "" : jade_interp)) + "</span></fieldset><fieldset> <legend>Media</legend><span>" + (jade.escape(null == (jade_interp = pageData.media) ? "" : jade_interp)) + "</span></fieldset><fieldset><legend class=\"share\">Share</legend></fieldset></aside></div></article>");
	// iterate pageData.detailcontent
	;(function(){
	  var $$obj = pageData.detailcontent;
	  if ('number' == typeof $$obj.length) {

	    for (var $index = 0, $$l = $$obj.length; $index < $$l; $index++) {
	      var contentItem = $$obj[$index];

	buf.push("<article class=\"col-md-12 no-padding\">");
	if ( contentItem.video)
	{
	buf.push("<video-component" + (jade.attr("thumb", contentItem.thumb, true, true)) + (jade.attr("alt", contentItem.thumbAlt, true, true)) + (jade.attr("title", contentItem.thumbTitle, true, true)) + (jade.attr("vimeo", contentItem.vimeo, true, true)) + "></video-component>");
	}
	if ( contentItem.carousel)
	{
	buf.push("<carousel-component class=\"carousel-component component section no-padding\">");
	// iterate contentItem.images
	;(function(){
	  var $$obj = contentItem.images;
	  if ('number' == typeof $$obj.length) {

	    for (var $index = 0, $$l = $$obj.length; $index < $$l; $index++) {
	      var carouselItem = $$obj[$index];

	buf.push("<img" + (jade.attr("src", carouselItem.url, true, true)) + (jade.attr("alt", carouselItem.alt, true, true)) + ">");
	    }

	  } else {
	    var $$l = 0;
	    for (var $index in $$obj) {
	      $$l++;      var carouselItem = $$obj[$index];

	buf.push("<img" + (jade.attr("src", carouselItem.url, true, true)) + (jade.attr("alt", carouselItem.alt, true, true)) + ">");
	    }

	  }
	}).call(this);

	buf.push("</carousel-component>");
	}
	if ( contentItem.image)
	{
	buf.push("<section class=\"image-component component row no-padding\"><div class=\"col-xs-12 no-padding\"><img" + (jade.attr("src", contentItem.imageUrl, true, true)) + (jade.attr("alt", contentItem.imageAlt, true, true)) + "></div></section>");
	}
	if ( contentItem.mainDescription)
	{
	// iterate contentItem.mainDescription
	;(function(){
	  var $$obj = contentItem.mainDescription;
	  if ('number' == typeof $$obj.length) {

	    for (var $index = 0, $$l = $$obj.length; $index < $$l; $index++) {
	      var par = $$obj[$index];

	buf.push("<p>" + (jade.escape(null == (jade_interp = par) ? "" : jade_interp)) + "</p>");
	    }

	  } else {
	    var $$l = 0;
	    for (var $index in $$obj) {
	      $$l++;      var par = $$obj[$index];

	buf.push("<p>" + (jade.escape(null == (jade_interp = par) ? "" : jade_interp)) + "</p>");
	    }

	  }
	}).call(this);

	}
	buf.push("</article>");
	    }

	  } else {
	    var $$l = 0;
	    for (var $index in $$obj) {
	      $$l++;      var contentItem = $$obj[$index];

	buf.push("<article class=\"col-md-12 no-padding\">");
	if ( contentItem.video)
	{
	buf.push("<video-component" + (jade.attr("thumb", contentItem.thumb, true, true)) + (jade.attr("alt", contentItem.thumbAlt, true, true)) + (jade.attr("title", contentItem.thumbTitle, true, true)) + (jade.attr("vimeo", contentItem.vimeo, true, true)) + "></video-component>");
	}
	if ( contentItem.carousel)
	{
	buf.push("<carousel-component class=\"carousel-component component section no-padding\">");
	// iterate contentItem.images
	;(function(){
	  var $$obj = contentItem.images;
	  if ('number' == typeof $$obj.length) {

	    for (var $index = 0, $$l = $$obj.length; $index < $$l; $index++) {
	      var carouselItem = $$obj[$index];

	buf.push("<img" + (jade.attr("src", carouselItem.url, true, true)) + (jade.attr("alt", carouselItem.alt, true, true)) + ">");
	    }

	  } else {
	    var $$l = 0;
	    for (var $index in $$obj) {
	      $$l++;      var carouselItem = $$obj[$index];

	buf.push("<img" + (jade.attr("src", carouselItem.url, true, true)) + (jade.attr("alt", carouselItem.alt, true, true)) + ">");
	    }

	  }
	}).call(this);

	buf.push("</carousel-component>");
	}
	if ( contentItem.image)
	{
	buf.push("<section class=\"image-component component row no-padding\"><div class=\"col-xs-12 no-padding\"><img" + (jade.attr("src", contentItem.imageUrl, true, true)) + (jade.attr("alt", contentItem.imageAlt, true, true)) + "></div></section>");
	}
	if ( contentItem.mainDescription)
	{
	// iterate contentItem.mainDescription
	;(function(){
	  var $$obj = contentItem.mainDescription;
	  if ('number' == typeof $$obj.length) {

	    for (var $index = 0, $$l = $$obj.length; $index < $$l; $index++) {
	      var par = $$obj[$index];

	buf.push("<p>" + (jade.escape(null == (jade_interp = par) ? "" : jade_interp)) + "</p>");
	    }

	  } else {
	    var $$l = 0;
	    for (var $index in $$obj) {
	      $$l++;      var par = $$obj[$index];

	buf.push("<p>" + (jade.escape(null == (jade_interp = par) ? "" : jade_interp)) + "</p>");
	    }

	  }
	}).call(this);

	}
	buf.push("</article>");
	    }

	  }
	}).call(this);

	buf.push("<!-- dynamically populate content from copy.json data-->");
	page = "moreCases"
	pageData = copy.content[page]
	buf.push("<section class=\"col-md-12 no-padding more-cases\"> <div class=\"more-case-wrapper cf\">");
	// iterate pageData
	;(function(){
	  var $$obj = pageData;
	  if ('number' == typeof $$obj.length) {

	    for (var $index = 0, $$l = $$obj.length; $index < $$l; $index++) {
	      var contentItem = $$obj[$index];

	buf.push("<article class=\"col-md-4\"> <img" + (jade.attr("src", __webpack_require__(103), true, true)) + "><p>" + (null == (jade_interp = contentItem.projectName) ? "" : jade_interp) + "<cite><span>" + (jade.escape(null == (jade_interp = contentItem.writerName) ? "" : jade_interp)) + "</span><span>" + (jade.escape(null == (jade_interp = contentItem.writerTitle) ? "" : jade_interp)) + "</span></cite></p><a href=\"#\" class=\"red\">read full article</a></article>");
	    }

	  } else {
	    var $$l = 0;
	    for (var $index in $$obj) {
	      $$l++;      var contentItem = $$obj[$index];

	buf.push("<article class=\"col-md-4\"> <img" + (jade.attr("src", __webpack_require__(103), true, true)) + "><p>" + (null == (jade_interp = contentItem.projectName) ? "" : jade_interp) + "<cite><span>" + (jade.escape(null == (jade_interp = contentItem.writerName) ? "" : jade_interp)) + "</span><span>" + (jade.escape(null == (jade_interp = contentItem.writerTitle) ? "" : jade_interp)) + "</span></cite></p><a href=\"#\" class=\"red\">read full article</a></article>");
	    }

	  }
	}).call(this);

	buf.push("</div></section></section>");}.call(this,"copy" in locals_for_with?locals_for_with.copy:typeof copy!=="undefined"?copy:undefined,"page" in locals_for_with?locals_for_with.page:typeof page!=="undefined"?page:undefined,"pageData" in locals_for_with?locals_for_with.pageData:typeof pageData!=="undefined"?pageData:undefined,"undefined" in locals_for_with?locals_for_with.undefined: false?undefined:undefined));;return buf.join("");
	}

/***/ },
/* 105 */
/***/ function(module, exports, __webpack_require__) {

	var jade = __webpack_require__(94);

	module.exports = function template(locals) {
	var buf = [];
	var jade_mixins = {};
	var jade_interp;
	;var locals_for_with = (locals || {});(function (copy, page, pageData, undefined) {
	buf.push("");
	copy = __webpack_require__(30)
	page = "sls"
	pageData = copy.content[page] 
	buf.push("<!-- dynamically populate content from copy.json data-->");
	copy = __webpack_require__(30)
	pageData = copy.content[page]
	buf.push("<section class=\"row no-padding work work-details\"><article class=\"col-md-12 no-padding top-main\"><h2> <blockquote>" + (null == (jade_interp = pageData.blockquote) ? "" : jade_interp) + "</blockquote></h2><cite><img src=\"assets/images/about/about-avatar.png\"><span>Mike Dowse</span><span>CEO, Wilson</span></cite></article><article class=\"col-md-12 no-padding\"><div class=\"col-md-7 top-description\">");
	if ( pageData.topDescription)
	{
	// iterate pageData.topDescription
	;(function(){
	  var $$obj = pageData.topDescription;
	  if ('number' == typeof $$obj.length) {

	    for (var $index = 0, $$l = $$obj.length; $index < $$l; $index++) {
	      var par = $$obj[$index];

	buf.push("<p>" + (null == (jade_interp = par) ? "" : jade_interp) + "</p>");
	    }

	  } else {
	    var $$l = 0;
	    for (var $index in $$obj) {
	      $$l++;      var par = $$obj[$index];

	buf.push("<p>" + (null == (jade_interp = par) ? "" : jade_interp) + "</p>");
	    }

	  }
	}).call(this);

	}
	buf.push("</div><div class=\"col-md-4 col-md-offset-1\"><aside><img" + (jade.attr("src", pageData.clientLogo, true, true)) + " class=\"clientlogo\"><fieldset> <legend>Client</legend><span>" + (jade.escape(null == (jade_interp = pageData.client) ? "" : jade_interp)) + "</span></fieldset><fieldset> <legend>Project</legend><span>" + (jade.escape(null == (jade_interp = pageData.project) ? "" : jade_interp)) + "</span></fieldset><fieldset> <legend>Media</legend><span>" + (jade.escape(null == (jade_interp = pageData.media) ? "" : jade_interp)) + "</span></fieldset><fieldset><legend class=\"share\">Share</legend></fieldset></aside></div></article>");
	// iterate pageData.detailcontent
	;(function(){
	  var $$obj = pageData.detailcontent;
	  if ('number' == typeof $$obj.length) {

	    for (var $index = 0, $$l = $$obj.length; $index < $$l; $index++) {
	      var contentItem = $$obj[$index];

	buf.push("<article class=\"col-md-12 no-padding\">");
	if ( contentItem.video)
	{
	buf.push("<video-component" + (jade.attr("thumb", contentItem.thumb, true, true)) + (jade.attr("alt", contentItem.thumbAlt, true, true)) + (jade.attr("title", contentItem.thumbTitle, true, true)) + (jade.attr("vimeo", contentItem.vimeo, true, true)) + "></video-component>");
	}
	if ( contentItem.carousel)
	{
	buf.push("<carousel-component class=\"carousel-component component section no-padding\">");
	// iterate contentItem.images
	;(function(){
	  var $$obj = contentItem.images;
	  if ('number' == typeof $$obj.length) {

	    for (var $index = 0, $$l = $$obj.length; $index < $$l; $index++) {
	      var carouselItem = $$obj[$index];

	buf.push("<img" + (jade.attr("src", carouselItem.url, true, true)) + (jade.attr("alt", carouselItem.alt, true, true)) + ">");
	    }

	  } else {
	    var $$l = 0;
	    for (var $index in $$obj) {
	      $$l++;      var carouselItem = $$obj[$index];

	buf.push("<img" + (jade.attr("src", carouselItem.url, true, true)) + (jade.attr("alt", carouselItem.alt, true, true)) + ">");
	    }

	  }
	}).call(this);

	buf.push("</carousel-component>");
	}
	if ( contentItem.image)
	{
	buf.push("<section class=\"image-component component row no-padding\"><div class=\"col-xs-12 no-padding\"><img" + (jade.attr("src", contentItem.imageUrl, true, true)) + (jade.attr("alt", contentItem.imageAlt, true, true)) + "></div></section>");
	}
	if ( contentItem.mainDescription)
	{
	// iterate contentItem.mainDescription
	;(function(){
	  var $$obj = contentItem.mainDescription;
	  if ('number' == typeof $$obj.length) {

	    for (var $index = 0, $$l = $$obj.length; $index < $$l; $index++) {
	      var par = $$obj[$index];

	buf.push("<p>" + (jade.escape(null == (jade_interp = par) ? "" : jade_interp)) + "</p>");
	    }

	  } else {
	    var $$l = 0;
	    for (var $index in $$obj) {
	      $$l++;      var par = $$obj[$index];

	buf.push("<p>" + (jade.escape(null == (jade_interp = par) ? "" : jade_interp)) + "</p>");
	    }

	  }
	}).call(this);

	}
	buf.push("</article>");
	    }

	  } else {
	    var $$l = 0;
	    for (var $index in $$obj) {
	      $$l++;      var contentItem = $$obj[$index];

	buf.push("<article class=\"col-md-12 no-padding\">");
	if ( contentItem.video)
	{
	buf.push("<video-component" + (jade.attr("thumb", contentItem.thumb, true, true)) + (jade.attr("alt", contentItem.thumbAlt, true, true)) + (jade.attr("title", contentItem.thumbTitle, true, true)) + (jade.attr("vimeo", contentItem.vimeo, true, true)) + "></video-component>");
	}
	if ( contentItem.carousel)
	{
	buf.push("<carousel-component class=\"carousel-component component section no-padding\">");
	// iterate contentItem.images
	;(function(){
	  var $$obj = contentItem.images;
	  if ('number' == typeof $$obj.length) {

	    for (var $index = 0, $$l = $$obj.length; $index < $$l; $index++) {
	      var carouselItem = $$obj[$index];

	buf.push("<img" + (jade.attr("src", carouselItem.url, true, true)) + (jade.attr("alt", carouselItem.alt, true, true)) + ">");
	    }

	  } else {
	    var $$l = 0;
	    for (var $index in $$obj) {
	      $$l++;      var carouselItem = $$obj[$index];

	buf.push("<img" + (jade.attr("src", carouselItem.url, true, true)) + (jade.attr("alt", carouselItem.alt, true, true)) + ">");
	    }

	  }
	}).call(this);

	buf.push("</carousel-component>");
	}
	if ( contentItem.image)
	{
	buf.push("<section class=\"image-component component row no-padding\"><div class=\"col-xs-12 no-padding\"><img" + (jade.attr("src", contentItem.imageUrl, true, true)) + (jade.attr("alt", contentItem.imageAlt, true, true)) + "></div></section>");
	}
	if ( contentItem.mainDescription)
	{
	// iterate contentItem.mainDescription
	;(function(){
	  var $$obj = contentItem.mainDescription;
	  if ('number' == typeof $$obj.length) {

	    for (var $index = 0, $$l = $$obj.length; $index < $$l; $index++) {
	      var par = $$obj[$index];

	buf.push("<p>" + (jade.escape(null == (jade_interp = par) ? "" : jade_interp)) + "</p>");
	    }

	  } else {
	    var $$l = 0;
	    for (var $index in $$obj) {
	      $$l++;      var par = $$obj[$index];

	buf.push("<p>" + (jade.escape(null == (jade_interp = par) ? "" : jade_interp)) + "</p>");
	    }

	  }
	}).call(this);

	}
	buf.push("</article>");
	    }

	  }
	}).call(this);

	buf.push("<!-- dynamically populate content from copy.json data-->");
	page = "moreCases"
	pageData = copy.content[page]
	buf.push("<section class=\"col-md-12 no-padding more-cases\"> <div class=\"more-case-wrapper cf\">");
	// iterate pageData
	;(function(){
	  var $$obj = pageData;
	  if ('number' == typeof $$obj.length) {

	    for (var $index = 0, $$l = $$obj.length; $index < $$l; $index++) {
	      var contentItem = $$obj[$index];

	buf.push("<article class=\"col-md-4\"> <img" + (jade.attr("src", __webpack_require__(103), true, true)) + "><p>" + (null == (jade_interp = contentItem.projectName) ? "" : jade_interp) + "<cite><span>" + (jade.escape(null == (jade_interp = contentItem.writerName) ? "" : jade_interp)) + "</span><span>" + (jade.escape(null == (jade_interp = contentItem.writerTitle) ? "" : jade_interp)) + "</span></cite></p><a href=\"#\" class=\"red\">read full article</a></article>");
	    }

	  } else {
	    var $$l = 0;
	    for (var $index in $$obj) {
	      $$l++;      var contentItem = $$obj[$index];

	buf.push("<article class=\"col-md-4\"> <img" + (jade.attr("src", __webpack_require__(103), true, true)) + "><p>" + (null == (jade_interp = contentItem.projectName) ? "" : jade_interp) + "<cite><span>" + (jade.escape(null == (jade_interp = contentItem.writerName) ? "" : jade_interp)) + "</span><span>" + (jade.escape(null == (jade_interp = contentItem.writerTitle) ? "" : jade_interp)) + "</span></cite></p><a href=\"#\" class=\"red\">read full article</a></article>");
	    }

	  }
	}).call(this);

	buf.push("</div></section></section>");}.call(this,"copy" in locals_for_with?locals_for_with.copy:typeof copy!=="undefined"?copy:undefined,"page" in locals_for_with?locals_for_with.page:typeof page!=="undefined"?page:undefined,"pageData" in locals_for_with?locals_for_with.pageData:typeof pageData!=="undefined"?pageData:undefined,"undefined" in locals_for_with?locals_for_with.undefined: false?undefined:undefined));;return buf.join("");
	}

/***/ },
/* 106 */
/***/ function(module, exports, __webpack_require__) {

	var jade = __webpack_require__(94);

	module.exports = function template(locals) {
	var buf = [];
	var jade_mixins = {};
	var jade_interp;
	;var locals_for_with = (locals || {});(function (copy, page, pageData, undefined) {
	buf.push("");
	copy = __webpack_require__(30)
	page = "xome"
	pageData = copy.content[page] 
	buf.push("<!-- dynamically populate content from copy.json data-->");
	copy = __webpack_require__(30)
	pageData = copy.content[page]
	buf.push("<section class=\"row no-padding work work-details\"><article class=\"col-md-12 no-padding top-main\"><h2> <blockquote>" + (null == (jade_interp = pageData.blockquote) ? "" : jade_interp) + "</blockquote></h2><cite><img src=\"assets/images/about/about-avatar.png\"><span>Mike Dowse</span><span>CEO, Wilson</span></cite></article><article class=\"col-md-12 no-padding\"><div class=\"col-md-7 top-description\">");
	if ( pageData.topDescription)
	{
	// iterate pageData.topDescription
	;(function(){
	  var $$obj = pageData.topDescription;
	  if ('number' == typeof $$obj.length) {

	    for (var $index = 0, $$l = $$obj.length; $index < $$l; $index++) {
	      var par = $$obj[$index];

	buf.push("<p>" + (null == (jade_interp = par) ? "" : jade_interp) + "</p>");
	    }

	  } else {
	    var $$l = 0;
	    for (var $index in $$obj) {
	      $$l++;      var par = $$obj[$index];

	buf.push("<p>" + (null == (jade_interp = par) ? "" : jade_interp) + "</p>");
	    }

	  }
	}).call(this);

	}
	buf.push("</div><div class=\"col-md-4 col-md-offset-1\"><aside><img" + (jade.attr("src", pageData.clientLogo, true, true)) + " class=\"clientlogo\"><fieldset> <legend>Client</legend><span>" + (jade.escape(null == (jade_interp = pageData.client) ? "" : jade_interp)) + "</span></fieldset><fieldset> <legend>Project</legend><span>" + (jade.escape(null == (jade_interp = pageData.project) ? "" : jade_interp)) + "</span></fieldset><fieldset> <legend>Media</legend><span>" + (jade.escape(null == (jade_interp = pageData.media) ? "" : jade_interp)) + "</span></fieldset><fieldset><legend class=\"share\">Share</legend></fieldset></aside></div></article>");
	// iterate pageData.detailcontent
	;(function(){
	  var $$obj = pageData.detailcontent;
	  if ('number' == typeof $$obj.length) {

	    for (var $index = 0, $$l = $$obj.length; $index < $$l; $index++) {
	      var contentItem = $$obj[$index];

	buf.push("<article class=\"col-md-12 no-padding\">");
	if ( contentItem.video)
	{
	buf.push("<video-component" + (jade.attr("thumb", contentItem.thumb, true, true)) + (jade.attr("alt", contentItem.thumbAlt, true, true)) + (jade.attr("title", contentItem.thumbTitle, true, true)) + (jade.attr("vimeo", contentItem.vimeo, true, true)) + "></video-component>");
	}
	if ( contentItem.carousel)
	{
	buf.push("<carousel-component class=\"carousel-component component section no-padding\">");
	// iterate contentItem.images
	;(function(){
	  var $$obj = contentItem.images;
	  if ('number' == typeof $$obj.length) {

	    for (var $index = 0, $$l = $$obj.length; $index < $$l; $index++) {
	      var carouselItem = $$obj[$index];

	buf.push("<img" + (jade.attr("src", carouselItem.url, true, true)) + (jade.attr("alt", carouselItem.alt, true, true)) + ">");
	    }

	  } else {
	    var $$l = 0;
	    for (var $index in $$obj) {
	      $$l++;      var carouselItem = $$obj[$index];

	buf.push("<img" + (jade.attr("src", carouselItem.url, true, true)) + (jade.attr("alt", carouselItem.alt, true, true)) + ">");
	    }

	  }
	}).call(this);

	buf.push("</carousel-component>");
	}
	if ( contentItem.image)
	{
	buf.push("<section class=\"image-component component row no-padding\"><div class=\"col-xs-12 no-padding\"><img" + (jade.attr("src", contentItem.imageUrl, true, true)) + (jade.attr("alt", contentItem.imageAlt, true, true)) + "></div></section>");
	}
	if ( contentItem.mainDescription)
	{
	// iterate contentItem.mainDescription
	;(function(){
	  var $$obj = contentItem.mainDescription;
	  if ('number' == typeof $$obj.length) {

	    for (var $index = 0, $$l = $$obj.length; $index < $$l; $index++) {
	      var par = $$obj[$index];

	buf.push("<p>" + (jade.escape(null == (jade_interp = par) ? "" : jade_interp)) + "</p>");
	    }

	  } else {
	    var $$l = 0;
	    for (var $index in $$obj) {
	      $$l++;      var par = $$obj[$index];

	buf.push("<p>" + (jade.escape(null == (jade_interp = par) ? "" : jade_interp)) + "</p>");
	    }

	  }
	}).call(this);

	}
	buf.push("</article>");
	    }

	  } else {
	    var $$l = 0;
	    for (var $index in $$obj) {
	      $$l++;      var contentItem = $$obj[$index];

	buf.push("<article class=\"col-md-12 no-padding\">");
	if ( contentItem.video)
	{
	buf.push("<video-component" + (jade.attr("thumb", contentItem.thumb, true, true)) + (jade.attr("alt", contentItem.thumbAlt, true, true)) + (jade.attr("title", contentItem.thumbTitle, true, true)) + (jade.attr("vimeo", contentItem.vimeo, true, true)) + "></video-component>");
	}
	if ( contentItem.carousel)
	{
	buf.push("<carousel-component class=\"carousel-component component section no-padding\">");
	// iterate contentItem.images
	;(function(){
	  var $$obj = contentItem.images;
	  if ('number' == typeof $$obj.length) {

	    for (var $index = 0, $$l = $$obj.length; $index < $$l; $index++) {
	      var carouselItem = $$obj[$index];

	buf.push("<img" + (jade.attr("src", carouselItem.url, true, true)) + (jade.attr("alt", carouselItem.alt, true, true)) + ">");
	    }

	  } else {
	    var $$l = 0;
	    for (var $index in $$obj) {
	      $$l++;      var carouselItem = $$obj[$index];

	buf.push("<img" + (jade.attr("src", carouselItem.url, true, true)) + (jade.attr("alt", carouselItem.alt, true, true)) + ">");
	    }

	  }
	}).call(this);

	buf.push("</carousel-component>");
	}
	if ( contentItem.image)
	{
	buf.push("<section class=\"image-component component row no-padding\"><div class=\"col-xs-12 no-padding\"><img" + (jade.attr("src", contentItem.imageUrl, true, true)) + (jade.attr("alt", contentItem.imageAlt, true, true)) + "></div></section>");
	}
	if ( contentItem.mainDescription)
	{
	// iterate contentItem.mainDescription
	;(function(){
	  var $$obj = contentItem.mainDescription;
	  if ('number' == typeof $$obj.length) {

	    for (var $index = 0, $$l = $$obj.length; $index < $$l; $index++) {
	      var par = $$obj[$index];

	buf.push("<p>" + (jade.escape(null == (jade_interp = par) ? "" : jade_interp)) + "</p>");
	    }

	  } else {
	    var $$l = 0;
	    for (var $index in $$obj) {
	      $$l++;      var par = $$obj[$index];

	buf.push("<p>" + (jade.escape(null == (jade_interp = par) ? "" : jade_interp)) + "</p>");
	    }

	  }
	}).call(this);

	}
	buf.push("</article>");
	    }

	  }
	}).call(this);

	buf.push("<!-- dynamically populate content from copy.json data-->");
	page = "moreCases"
	pageData = copy.content[page]
	buf.push("<section class=\"col-md-12 no-padding more-cases\"> <div class=\"more-case-wrapper cf\">");
	// iterate pageData
	;(function(){
	  var $$obj = pageData;
	  if ('number' == typeof $$obj.length) {

	    for (var $index = 0, $$l = $$obj.length; $index < $$l; $index++) {
	      var contentItem = $$obj[$index];

	buf.push("<article class=\"col-md-4\"> <img" + (jade.attr("src", __webpack_require__(103), true, true)) + "><p>" + (null == (jade_interp = contentItem.projectName) ? "" : jade_interp) + "<cite><span>" + (jade.escape(null == (jade_interp = contentItem.writerName) ? "" : jade_interp)) + "</span><span>" + (jade.escape(null == (jade_interp = contentItem.writerTitle) ? "" : jade_interp)) + "</span></cite></p><a href=\"#\" class=\"red\">read full article</a></article>");
	    }

	  } else {
	    var $$l = 0;
	    for (var $index in $$obj) {
	      $$l++;      var contentItem = $$obj[$index];

	buf.push("<article class=\"col-md-4\"> <img" + (jade.attr("src", __webpack_require__(103), true, true)) + "><p>" + (null == (jade_interp = contentItem.projectName) ? "" : jade_interp) + "<cite><span>" + (jade.escape(null == (jade_interp = contentItem.writerName) ? "" : jade_interp)) + "</span><span>" + (jade.escape(null == (jade_interp = contentItem.writerTitle) ? "" : jade_interp)) + "</span></cite></p><a href=\"#\" class=\"red\">read full article</a></article>");
	    }

	  }
	}).call(this);

	buf.push("</div></section></section>");}.call(this,"copy" in locals_for_with?locals_for_with.copy:typeof copy!=="undefined"?copy:undefined,"page" in locals_for_with?locals_for_with.page:typeof page!=="undefined"?page:undefined,"pageData" in locals_for_with?locals_for_with.pageData:typeof pageData!=="undefined"?pageData:undefined,"undefined" in locals_for_with?locals_for_with.undefined: false?undefined:undefined));;return buf.join("");
	}

/***/ },
/* 107 */
/***/ function(module, exports, __webpack_require__) {

	var jade = __webpack_require__(94);

	module.exports = function template(locals) {
	var buf = [];
	var jade_mixins = {};
	var jade_interp;
	;var locals_for_with = (locals || {});(function (copy, page, pageData, undefined) {
	buf.push("");
	copy = __webpack_require__(30)
	page = "think-thin"
	pageData = copy.content[page] 
	buf.push("<!-- dynamically populate content from copy.json data-->");
	copy = __webpack_require__(30)
	pageData = copy.content[page]
	buf.push("<section class=\"row no-padding work work-details\"><article class=\"col-md-12 no-padding top-main\"><h2> <blockquote>" + (null == (jade_interp = pageData.blockquote) ? "" : jade_interp) + "</blockquote></h2><cite><img src=\"assets/images/about/about-avatar.png\"><span>Mike Dowse</span><span>CEO, Wilson</span></cite></article><article class=\"col-md-12 no-padding\"><div class=\"col-md-7 top-description\">");
	if ( pageData.topDescription)
	{
	// iterate pageData.topDescription
	;(function(){
	  var $$obj = pageData.topDescription;
	  if ('number' == typeof $$obj.length) {

	    for (var $index = 0, $$l = $$obj.length; $index < $$l; $index++) {
	      var par = $$obj[$index];

	buf.push("<p>" + (null == (jade_interp = par) ? "" : jade_interp) + "</p>");
	    }

	  } else {
	    var $$l = 0;
	    for (var $index in $$obj) {
	      $$l++;      var par = $$obj[$index];

	buf.push("<p>" + (null == (jade_interp = par) ? "" : jade_interp) + "</p>");
	    }

	  }
	}).call(this);

	}
	buf.push("</div><div class=\"col-md-4 col-md-offset-1\"><aside><img" + (jade.attr("src", pageData.clientLogo, true, true)) + " class=\"clientlogo\"><fieldset> <legend>Client</legend><span>" + (jade.escape(null == (jade_interp = pageData.client) ? "" : jade_interp)) + "</span></fieldset><fieldset> <legend>Project</legend><span>" + (jade.escape(null == (jade_interp = pageData.project) ? "" : jade_interp)) + "</span></fieldset><fieldset> <legend>Media</legend><span>" + (jade.escape(null == (jade_interp = pageData.media) ? "" : jade_interp)) + "</span></fieldset><fieldset><legend class=\"share\">Share</legend></fieldset></aside></div></article>");
	// iterate pageData.detailcontent
	;(function(){
	  var $$obj = pageData.detailcontent;
	  if ('number' == typeof $$obj.length) {

	    for (var $index = 0, $$l = $$obj.length; $index < $$l; $index++) {
	      var contentItem = $$obj[$index];

	buf.push("<article class=\"col-md-12 no-padding\">");
	if ( contentItem.video)
	{
	buf.push("<video-component" + (jade.attr("thumb", contentItem.thumb, true, true)) + (jade.attr("alt", contentItem.thumbAlt, true, true)) + (jade.attr("title", contentItem.thumbTitle, true, true)) + (jade.attr("vimeo", contentItem.vimeo, true, true)) + "></video-component>");
	}
	if ( contentItem.carousel)
	{
	buf.push("<carousel-component class=\"carousel-component component section no-padding\">");
	// iterate contentItem.images
	;(function(){
	  var $$obj = contentItem.images;
	  if ('number' == typeof $$obj.length) {

	    for (var $index = 0, $$l = $$obj.length; $index < $$l; $index++) {
	      var carouselItem = $$obj[$index];

	buf.push("<img" + (jade.attr("src", carouselItem.url, true, true)) + (jade.attr("alt", carouselItem.alt, true, true)) + ">");
	    }

	  } else {
	    var $$l = 0;
	    for (var $index in $$obj) {
	      $$l++;      var carouselItem = $$obj[$index];

	buf.push("<img" + (jade.attr("src", carouselItem.url, true, true)) + (jade.attr("alt", carouselItem.alt, true, true)) + ">");
	    }

	  }
	}).call(this);

	buf.push("</carousel-component>");
	}
	if ( contentItem.image)
	{
	buf.push("<section class=\"image-component component row no-padding\"><div class=\"col-xs-12 no-padding\"><img" + (jade.attr("src", contentItem.imageUrl, true, true)) + (jade.attr("alt", contentItem.imageAlt, true, true)) + "></div></section>");
	}
	if ( contentItem.mainDescription)
	{
	// iterate contentItem.mainDescription
	;(function(){
	  var $$obj = contentItem.mainDescription;
	  if ('number' == typeof $$obj.length) {

	    for (var $index = 0, $$l = $$obj.length; $index < $$l; $index++) {
	      var par = $$obj[$index];

	buf.push("<p>" + (jade.escape(null == (jade_interp = par) ? "" : jade_interp)) + "</p>");
	    }

	  } else {
	    var $$l = 0;
	    for (var $index in $$obj) {
	      $$l++;      var par = $$obj[$index];

	buf.push("<p>" + (jade.escape(null == (jade_interp = par) ? "" : jade_interp)) + "</p>");
	    }

	  }
	}).call(this);

	}
	buf.push("</article>");
	    }

	  } else {
	    var $$l = 0;
	    for (var $index in $$obj) {
	      $$l++;      var contentItem = $$obj[$index];

	buf.push("<article class=\"col-md-12 no-padding\">");
	if ( contentItem.video)
	{
	buf.push("<video-component" + (jade.attr("thumb", contentItem.thumb, true, true)) + (jade.attr("alt", contentItem.thumbAlt, true, true)) + (jade.attr("title", contentItem.thumbTitle, true, true)) + (jade.attr("vimeo", contentItem.vimeo, true, true)) + "></video-component>");
	}
	if ( contentItem.carousel)
	{
	buf.push("<carousel-component class=\"carousel-component component section no-padding\">");
	// iterate contentItem.images
	;(function(){
	  var $$obj = contentItem.images;
	  if ('number' == typeof $$obj.length) {

	    for (var $index = 0, $$l = $$obj.length; $index < $$l; $index++) {
	      var carouselItem = $$obj[$index];

	buf.push("<img" + (jade.attr("src", carouselItem.url, true, true)) + (jade.attr("alt", carouselItem.alt, true, true)) + ">");
	    }

	  } else {
	    var $$l = 0;
	    for (var $index in $$obj) {
	      $$l++;      var carouselItem = $$obj[$index];

	buf.push("<img" + (jade.attr("src", carouselItem.url, true, true)) + (jade.attr("alt", carouselItem.alt, true, true)) + ">");
	    }

	  }
	}).call(this);

	buf.push("</carousel-component>");
	}
	if ( contentItem.image)
	{
	buf.push("<section class=\"image-component component row no-padding\"><div class=\"col-xs-12 no-padding\"><img" + (jade.attr("src", contentItem.imageUrl, true, true)) + (jade.attr("alt", contentItem.imageAlt, true, true)) + "></div></section>");
	}
	if ( contentItem.mainDescription)
	{
	// iterate contentItem.mainDescription
	;(function(){
	  var $$obj = contentItem.mainDescription;
	  if ('number' == typeof $$obj.length) {

	    for (var $index = 0, $$l = $$obj.length; $index < $$l; $index++) {
	      var par = $$obj[$index];

	buf.push("<p>" + (jade.escape(null == (jade_interp = par) ? "" : jade_interp)) + "</p>");
	    }

	  } else {
	    var $$l = 0;
	    for (var $index in $$obj) {
	      $$l++;      var par = $$obj[$index];

	buf.push("<p>" + (jade.escape(null == (jade_interp = par) ? "" : jade_interp)) + "</p>");
	    }

	  }
	}).call(this);

	}
	buf.push("</article>");
	    }

	  }
	}).call(this);

	buf.push("<!-- dynamically populate content from copy.json data-->");
	page = "moreCases"
	pageData = copy.content[page]
	buf.push("<section class=\"col-md-12 no-padding more-cases\"> <div class=\"more-case-wrapper cf\">");
	// iterate pageData
	;(function(){
	  var $$obj = pageData;
	  if ('number' == typeof $$obj.length) {

	    for (var $index = 0, $$l = $$obj.length; $index < $$l; $index++) {
	      var contentItem = $$obj[$index];

	buf.push("<article class=\"col-md-4\"> <img" + (jade.attr("src", __webpack_require__(103), true, true)) + "><p>" + (null == (jade_interp = contentItem.projectName) ? "" : jade_interp) + "<cite><span>" + (jade.escape(null == (jade_interp = contentItem.writerName) ? "" : jade_interp)) + "</span><span>" + (jade.escape(null == (jade_interp = contentItem.writerTitle) ? "" : jade_interp)) + "</span></cite></p><a href=\"#\" class=\"red\">read full article</a></article>");
	    }

	  } else {
	    var $$l = 0;
	    for (var $index in $$obj) {
	      $$l++;      var contentItem = $$obj[$index];

	buf.push("<article class=\"col-md-4\"> <img" + (jade.attr("src", __webpack_require__(103), true, true)) + "><p>" + (null == (jade_interp = contentItem.projectName) ? "" : jade_interp) + "<cite><span>" + (jade.escape(null == (jade_interp = contentItem.writerName) ? "" : jade_interp)) + "</span><span>" + (jade.escape(null == (jade_interp = contentItem.writerTitle) ? "" : jade_interp)) + "</span></cite></p><a href=\"#\" class=\"red\">read full article</a></article>");
	    }

	  }
	}).call(this);

	buf.push("</div></section></section>");}.call(this,"copy" in locals_for_with?locals_for_with.copy:typeof copy!=="undefined"?copy:undefined,"page" in locals_for_with?locals_for_with.page:typeof page!=="undefined"?page:undefined,"pageData" in locals_for_with?locals_for_with.pageData:typeof pageData!=="undefined"?pageData:undefined,"undefined" in locals_for_with?locals_for_with.undefined: false?undefined:undefined));;return buf.join("");
	}

/***/ },
/* 108 */
/***/ function(module, exports, __webpack_require__) {

	var jade = __webpack_require__(94);

	module.exports = function template(locals) {
	var buf = [];
	var jade_mixins = {};
	var jade_interp;
	;var locals_for_with = (locals || {});(function (copy, page, pageData, undefined) {
	buf.push("");
	copy = __webpack_require__(30)
	page = "mens-wearhouse"
	pageData = copy.content[page] 
	buf.push("<!-- dynamically populate content from copy.json data-->");
	copy = __webpack_require__(30)
	pageData = copy.content[page]
	buf.push("<section class=\"row no-padding work work-details\"><article class=\"col-md-12 no-padding top-main\"><h2> <blockquote>" + (null == (jade_interp = pageData.blockquote) ? "" : jade_interp) + "</blockquote></h2><cite><img src=\"assets/images/about/about-avatar.png\"><span>Mike Dowse</span><span>CEO, Wilson</span></cite></article><article class=\"col-md-12 no-padding\"><div class=\"col-md-7 top-description\">");
	if ( pageData.topDescription)
	{
	// iterate pageData.topDescription
	;(function(){
	  var $$obj = pageData.topDescription;
	  if ('number' == typeof $$obj.length) {

	    for (var $index = 0, $$l = $$obj.length; $index < $$l; $index++) {
	      var par = $$obj[$index];

	buf.push("<p>" + (null == (jade_interp = par) ? "" : jade_interp) + "</p>");
	    }

	  } else {
	    var $$l = 0;
	    for (var $index in $$obj) {
	      $$l++;      var par = $$obj[$index];

	buf.push("<p>" + (null == (jade_interp = par) ? "" : jade_interp) + "</p>");
	    }

	  }
	}).call(this);

	}
	buf.push("</div><div class=\"col-md-4 col-md-offset-1\"><aside><img" + (jade.attr("src", pageData.clientLogo, true, true)) + " class=\"clientlogo\"><fieldset> <legend>Client</legend><span>" + (jade.escape(null == (jade_interp = pageData.client) ? "" : jade_interp)) + "</span></fieldset><fieldset> <legend>Project</legend><span>" + (jade.escape(null == (jade_interp = pageData.project) ? "" : jade_interp)) + "</span></fieldset><fieldset> <legend>Media</legend><span>" + (jade.escape(null == (jade_interp = pageData.media) ? "" : jade_interp)) + "</span></fieldset><fieldset><legend class=\"share\">Share</legend></fieldset></aside></div></article>");
	// iterate pageData.detailcontent
	;(function(){
	  var $$obj = pageData.detailcontent;
	  if ('number' == typeof $$obj.length) {

	    for (var $index = 0, $$l = $$obj.length; $index < $$l; $index++) {
	      var contentItem = $$obj[$index];

	buf.push("<article class=\"col-md-12 no-padding\">");
	if ( contentItem.video)
	{
	buf.push("<video-component" + (jade.attr("thumb", contentItem.thumb, true, true)) + (jade.attr("alt", contentItem.thumbAlt, true, true)) + (jade.attr("title", contentItem.thumbTitle, true, true)) + (jade.attr("vimeo", contentItem.vimeo, true, true)) + "></video-component>");
	}
	if ( contentItem.carousel)
	{
	buf.push("<carousel-component class=\"carousel-component component section no-padding\">");
	// iterate contentItem.images
	;(function(){
	  var $$obj = contentItem.images;
	  if ('number' == typeof $$obj.length) {

	    for (var $index = 0, $$l = $$obj.length; $index < $$l; $index++) {
	      var carouselItem = $$obj[$index];

	buf.push("<img" + (jade.attr("src", carouselItem.url, true, true)) + (jade.attr("alt", carouselItem.alt, true, true)) + ">");
	    }

	  } else {
	    var $$l = 0;
	    for (var $index in $$obj) {
	      $$l++;      var carouselItem = $$obj[$index];

	buf.push("<img" + (jade.attr("src", carouselItem.url, true, true)) + (jade.attr("alt", carouselItem.alt, true, true)) + ">");
	    }

	  }
	}).call(this);

	buf.push("</carousel-component>");
	}
	if ( contentItem.image)
	{
	buf.push("<section class=\"image-component component row no-padding\"><div class=\"col-xs-12 no-padding\"><img" + (jade.attr("src", contentItem.imageUrl, true, true)) + (jade.attr("alt", contentItem.imageAlt, true, true)) + "></div></section>");
	}
	if ( contentItem.mainDescription)
	{
	// iterate contentItem.mainDescription
	;(function(){
	  var $$obj = contentItem.mainDescription;
	  if ('number' == typeof $$obj.length) {

	    for (var $index = 0, $$l = $$obj.length; $index < $$l; $index++) {
	      var par = $$obj[$index];

	buf.push("<p>" + (jade.escape(null == (jade_interp = par) ? "" : jade_interp)) + "</p>");
	    }

	  } else {
	    var $$l = 0;
	    for (var $index in $$obj) {
	      $$l++;      var par = $$obj[$index];

	buf.push("<p>" + (jade.escape(null == (jade_interp = par) ? "" : jade_interp)) + "</p>");
	    }

	  }
	}).call(this);

	}
	buf.push("</article>");
	    }

	  } else {
	    var $$l = 0;
	    for (var $index in $$obj) {
	      $$l++;      var contentItem = $$obj[$index];

	buf.push("<article class=\"col-md-12 no-padding\">");
	if ( contentItem.video)
	{
	buf.push("<video-component" + (jade.attr("thumb", contentItem.thumb, true, true)) + (jade.attr("alt", contentItem.thumbAlt, true, true)) + (jade.attr("title", contentItem.thumbTitle, true, true)) + (jade.attr("vimeo", contentItem.vimeo, true, true)) + "></video-component>");
	}
	if ( contentItem.carousel)
	{
	buf.push("<carousel-component class=\"carousel-component component section no-padding\">");
	// iterate contentItem.images
	;(function(){
	  var $$obj = contentItem.images;
	  if ('number' == typeof $$obj.length) {

	    for (var $index = 0, $$l = $$obj.length; $index < $$l; $index++) {
	      var carouselItem = $$obj[$index];

	buf.push("<img" + (jade.attr("src", carouselItem.url, true, true)) + (jade.attr("alt", carouselItem.alt, true, true)) + ">");
	    }

	  } else {
	    var $$l = 0;
	    for (var $index in $$obj) {
	      $$l++;      var carouselItem = $$obj[$index];

	buf.push("<img" + (jade.attr("src", carouselItem.url, true, true)) + (jade.attr("alt", carouselItem.alt, true, true)) + ">");
	    }

	  }
	}).call(this);

	buf.push("</carousel-component>");
	}
	if ( contentItem.image)
	{
	buf.push("<section class=\"image-component component row no-padding\"><div class=\"col-xs-12 no-padding\"><img" + (jade.attr("src", contentItem.imageUrl, true, true)) + (jade.attr("alt", contentItem.imageAlt, true, true)) + "></div></section>");
	}
	if ( contentItem.mainDescription)
	{
	// iterate contentItem.mainDescription
	;(function(){
	  var $$obj = contentItem.mainDescription;
	  if ('number' == typeof $$obj.length) {

	    for (var $index = 0, $$l = $$obj.length; $index < $$l; $index++) {
	      var par = $$obj[$index];

	buf.push("<p>" + (jade.escape(null == (jade_interp = par) ? "" : jade_interp)) + "</p>");
	    }

	  } else {
	    var $$l = 0;
	    for (var $index in $$obj) {
	      $$l++;      var par = $$obj[$index];

	buf.push("<p>" + (jade.escape(null == (jade_interp = par) ? "" : jade_interp)) + "</p>");
	    }

	  }
	}).call(this);

	}
	buf.push("</article>");
	    }

	  }
	}).call(this);

	buf.push("<!-- dynamically populate content from copy.json data-->");
	page = "moreCases"
	pageData = copy.content[page]
	buf.push("<section class=\"col-md-12 no-padding more-cases\"> <div class=\"more-case-wrapper cf\">");
	// iterate pageData
	;(function(){
	  var $$obj = pageData;
	  if ('number' == typeof $$obj.length) {

	    for (var $index = 0, $$l = $$obj.length; $index < $$l; $index++) {
	      var contentItem = $$obj[$index];

	buf.push("<article class=\"col-md-4\"> <img" + (jade.attr("src", __webpack_require__(103), true, true)) + "><p>" + (null == (jade_interp = contentItem.projectName) ? "" : jade_interp) + "<cite><span>" + (jade.escape(null == (jade_interp = contentItem.writerName) ? "" : jade_interp)) + "</span><span>" + (jade.escape(null == (jade_interp = contentItem.writerTitle) ? "" : jade_interp)) + "</span></cite></p><a href=\"#\" class=\"red\">read full article</a></article>");
	    }

	  } else {
	    var $$l = 0;
	    for (var $index in $$obj) {
	      $$l++;      var contentItem = $$obj[$index];

	buf.push("<article class=\"col-md-4\"> <img" + (jade.attr("src", __webpack_require__(103), true, true)) + "><p>" + (null == (jade_interp = contentItem.projectName) ? "" : jade_interp) + "<cite><span>" + (jade.escape(null == (jade_interp = contentItem.writerName) ? "" : jade_interp)) + "</span><span>" + (jade.escape(null == (jade_interp = contentItem.writerTitle) ? "" : jade_interp)) + "</span></cite></p><a href=\"#\" class=\"red\">read full article</a></article>");
	    }

	  }
	}).call(this);

	buf.push("</div></section></section>");}.call(this,"copy" in locals_for_with?locals_for_with.copy:typeof copy!=="undefined"?copy:undefined,"page" in locals_for_with?locals_for_with.page:typeof page!=="undefined"?page:undefined,"pageData" in locals_for_with?locals_for_with.pageData:typeof pageData!=="undefined"?pageData:undefined,"undefined" in locals_for_with?locals_for_with.undefined: false?undefined:undefined));;return buf.join("");
	}

/***/ },
/* 109 */
/***/ function(module, exports, __webpack_require__) {

	var jade = __webpack_require__(94);

	module.exports = function template(locals) {
	var buf = [];
	var jade_mixins = {};
	var jade_interp;
	;var locals_for_with = (locals || {});(function (copy, page, pageData, undefined) {
	buf.push("");
	copy = __webpack_require__(30)
	page = "sunny"
	pageData = copy.content[page] 
	buf.push("<!-- dynamically populate content from copy.json data-->");
	copy = __webpack_require__(30)
	pageData = copy.content[page]
	buf.push("<section class=\"row no-padding work work-details\"><article class=\"col-md-12 no-padding top-main\"><h2> <blockquote>" + (null == (jade_interp = pageData.blockquote) ? "" : jade_interp) + "</blockquote></h2><cite><img src=\"assets/images/about/about-avatar.png\"><span>Mike Dowse</span><span>CEO, Wilson</span></cite></article><article class=\"col-md-12 no-padding\"><div class=\"col-md-7 top-description\">");
	if ( pageData.topDescription)
	{
	// iterate pageData.topDescription
	;(function(){
	  var $$obj = pageData.topDescription;
	  if ('number' == typeof $$obj.length) {

	    for (var $index = 0, $$l = $$obj.length; $index < $$l; $index++) {
	      var par = $$obj[$index];

	buf.push("<p>" + (null == (jade_interp = par) ? "" : jade_interp) + "</p>");
	    }

	  } else {
	    var $$l = 0;
	    for (var $index in $$obj) {
	      $$l++;      var par = $$obj[$index];

	buf.push("<p>" + (null == (jade_interp = par) ? "" : jade_interp) + "</p>");
	    }

	  }
	}).call(this);

	}
	buf.push("</div><div class=\"col-md-4 col-md-offset-1\"><aside><img" + (jade.attr("src", pageData.clientLogo, true, true)) + " class=\"clientlogo\"><fieldset> <legend>Client</legend><span>" + (jade.escape(null == (jade_interp = pageData.client) ? "" : jade_interp)) + "</span></fieldset><fieldset> <legend>Project</legend><span>" + (jade.escape(null == (jade_interp = pageData.project) ? "" : jade_interp)) + "</span></fieldset><fieldset> <legend>Media</legend><span>" + (jade.escape(null == (jade_interp = pageData.media) ? "" : jade_interp)) + "</span></fieldset><fieldset><legend class=\"share\">Share</legend></fieldset></aside></div></article>");
	// iterate pageData.detailcontent
	;(function(){
	  var $$obj = pageData.detailcontent;
	  if ('number' == typeof $$obj.length) {

	    for (var $index = 0, $$l = $$obj.length; $index < $$l; $index++) {
	      var contentItem = $$obj[$index];

	buf.push("<article class=\"col-md-12 no-padding\">");
	if ( contentItem.video)
	{
	buf.push("<video-component" + (jade.attr("thumb", contentItem.thumb, true, true)) + (jade.attr("alt", contentItem.thumbAlt, true, true)) + (jade.attr("title", contentItem.thumbTitle, true, true)) + (jade.attr("vimeo", contentItem.vimeo, true, true)) + "></video-component>");
	}
	if ( contentItem.carousel)
	{
	buf.push("<carousel-component class=\"carousel-component component section no-padding\">");
	// iterate contentItem.images
	;(function(){
	  var $$obj = contentItem.images;
	  if ('number' == typeof $$obj.length) {

	    for (var $index = 0, $$l = $$obj.length; $index < $$l; $index++) {
	      var carouselItem = $$obj[$index];

	buf.push("<img" + (jade.attr("src", carouselItem.url, true, true)) + (jade.attr("alt", carouselItem.alt, true, true)) + ">");
	    }

	  } else {
	    var $$l = 0;
	    for (var $index in $$obj) {
	      $$l++;      var carouselItem = $$obj[$index];

	buf.push("<img" + (jade.attr("src", carouselItem.url, true, true)) + (jade.attr("alt", carouselItem.alt, true, true)) + ">");
	    }

	  }
	}).call(this);

	buf.push("</carousel-component>");
	}
	if ( contentItem.image)
	{
	buf.push("<section class=\"image-component component row no-padding\"><div class=\"col-xs-12 no-padding\"><img" + (jade.attr("src", contentItem.imageUrl, true, true)) + (jade.attr("alt", contentItem.imageAlt, true, true)) + "></div></section>");
	}
	if ( contentItem.mainDescription)
	{
	// iterate contentItem.mainDescription
	;(function(){
	  var $$obj = contentItem.mainDescription;
	  if ('number' == typeof $$obj.length) {

	    for (var $index = 0, $$l = $$obj.length; $index < $$l; $index++) {
	      var par = $$obj[$index];

	buf.push("<p>" + (jade.escape(null == (jade_interp = par) ? "" : jade_interp)) + "</p>");
	    }

	  } else {
	    var $$l = 0;
	    for (var $index in $$obj) {
	      $$l++;      var par = $$obj[$index];

	buf.push("<p>" + (jade.escape(null == (jade_interp = par) ? "" : jade_interp)) + "</p>");
	    }

	  }
	}).call(this);

	}
	buf.push("</article>");
	    }

	  } else {
	    var $$l = 0;
	    for (var $index in $$obj) {
	      $$l++;      var contentItem = $$obj[$index];

	buf.push("<article class=\"col-md-12 no-padding\">");
	if ( contentItem.video)
	{
	buf.push("<video-component" + (jade.attr("thumb", contentItem.thumb, true, true)) + (jade.attr("alt", contentItem.thumbAlt, true, true)) + (jade.attr("title", contentItem.thumbTitle, true, true)) + (jade.attr("vimeo", contentItem.vimeo, true, true)) + "></video-component>");
	}
	if ( contentItem.carousel)
	{
	buf.push("<carousel-component class=\"carousel-component component section no-padding\">");
	// iterate contentItem.images
	;(function(){
	  var $$obj = contentItem.images;
	  if ('number' == typeof $$obj.length) {

	    for (var $index = 0, $$l = $$obj.length; $index < $$l; $index++) {
	      var carouselItem = $$obj[$index];

	buf.push("<img" + (jade.attr("src", carouselItem.url, true, true)) + (jade.attr("alt", carouselItem.alt, true, true)) + ">");
	    }

	  } else {
	    var $$l = 0;
	    for (var $index in $$obj) {
	      $$l++;      var carouselItem = $$obj[$index];

	buf.push("<img" + (jade.attr("src", carouselItem.url, true, true)) + (jade.attr("alt", carouselItem.alt, true, true)) + ">");
	    }

	  }
	}).call(this);

	buf.push("</carousel-component>");
	}
	if ( contentItem.image)
	{
	buf.push("<section class=\"image-component component row no-padding\"><div class=\"col-xs-12 no-padding\"><img" + (jade.attr("src", contentItem.imageUrl, true, true)) + (jade.attr("alt", contentItem.imageAlt, true, true)) + "></div></section>");
	}
	if ( contentItem.mainDescription)
	{
	// iterate contentItem.mainDescription
	;(function(){
	  var $$obj = contentItem.mainDescription;
	  if ('number' == typeof $$obj.length) {

	    for (var $index = 0, $$l = $$obj.length; $index < $$l; $index++) {
	      var par = $$obj[$index];

	buf.push("<p>" + (jade.escape(null == (jade_interp = par) ? "" : jade_interp)) + "</p>");
	    }

	  } else {
	    var $$l = 0;
	    for (var $index in $$obj) {
	      $$l++;      var par = $$obj[$index];

	buf.push("<p>" + (jade.escape(null == (jade_interp = par) ? "" : jade_interp)) + "</p>");
	    }

	  }
	}).call(this);

	}
	buf.push("</article>");
	    }

	  }
	}).call(this);

	buf.push("<!-- dynamically populate content from copy.json data-->");
	page = "moreCases"
	pageData = copy.content[page]
	buf.push("<section class=\"col-md-12 no-padding more-cases\"> <div class=\"more-case-wrapper cf\">");
	// iterate pageData
	;(function(){
	  var $$obj = pageData;
	  if ('number' == typeof $$obj.length) {

	    for (var $index = 0, $$l = $$obj.length; $index < $$l; $index++) {
	      var contentItem = $$obj[$index];

	buf.push("<article class=\"col-md-4\"> <img" + (jade.attr("src", __webpack_require__(103), true, true)) + "><p>" + (null == (jade_interp = contentItem.projectName) ? "" : jade_interp) + "<cite><span>" + (jade.escape(null == (jade_interp = contentItem.writerName) ? "" : jade_interp)) + "</span><span>" + (jade.escape(null == (jade_interp = contentItem.writerTitle) ? "" : jade_interp)) + "</span></cite></p><a href=\"#\" class=\"red\">read full article</a></article>");
	    }

	  } else {
	    var $$l = 0;
	    for (var $index in $$obj) {
	      $$l++;      var contentItem = $$obj[$index];

	buf.push("<article class=\"col-md-4\"> <img" + (jade.attr("src", __webpack_require__(103), true, true)) + "><p>" + (null == (jade_interp = contentItem.projectName) ? "" : jade_interp) + "<cite><span>" + (jade.escape(null == (jade_interp = contentItem.writerName) ? "" : jade_interp)) + "</span><span>" + (jade.escape(null == (jade_interp = contentItem.writerTitle) ? "" : jade_interp)) + "</span></cite></p><a href=\"#\" class=\"red\">read full article</a></article>");
	    }

	  }
	}).call(this);

	buf.push("</div></section></section>");}.call(this,"copy" in locals_for_with?locals_for_with.copy:typeof copy!=="undefined"?copy:undefined,"page" in locals_for_with?locals_for_with.page:typeof page!=="undefined"?page:undefined,"pageData" in locals_for_with?locals_for_with.pageData:typeof pageData!=="undefined"?pageData:undefined,"undefined" in locals_for_with?locals_for_with.undefined: false?undefined:undefined));;return buf.join("");
	}

/***/ },
/* 110 */
/***/ function(module, exports, __webpack_require__) {

	var jade = __webpack_require__(94);

	module.exports = function template(locals) {
	var buf = [];
	var jade_mixins = {};
	var jade_interp;
	;var locals_for_with = (locals || {});(function (copy, page, pageData, undefined) {
	buf.push("");
	copy = __webpack_require__(30)
	page = "cooper"
	pageData = copy.content[page] 
	buf.push("<!-- dynamically populate content from copy.json data-->");
	copy = __webpack_require__(30)
	pageData = copy.content[page]
	buf.push("<section class=\"row no-padding work work-details\"><article class=\"col-md-12 no-padding top-main\"><h2> <blockquote>" + (null == (jade_interp = pageData.blockquote) ? "" : jade_interp) + "</blockquote></h2><cite><img src=\"assets/images/about/about-avatar.png\"><span>Mike Dowse</span><span>CEO, Wilson</span></cite></article><article class=\"col-md-12 no-padding\"><div class=\"col-md-7 top-description\">");
	if ( pageData.topDescription)
	{
	// iterate pageData.topDescription
	;(function(){
	  var $$obj = pageData.topDescription;
	  if ('number' == typeof $$obj.length) {

	    for (var $index = 0, $$l = $$obj.length; $index < $$l; $index++) {
	      var par = $$obj[$index];

	buf.push("<p>" + (null == (jade_interp = par) ? "" : jade_interp) + "</p>");
	    }

	  } else {
	    var $$l = 0;
	    for (var $index in $$obj) {
	      $$l++;      var par = $$obj[$index];

	buf.push("<p>" + (null == (jade_interp = par) ? "" : jade_interp) + "</p>");
	    }

	  }
	}).call(this);

	}
	buf.push("</div><div class=\"col-md-4 col-md-offset-1\"><aside><img" + (jade.attr("src", pageData.clientLogo, true, true)) + " class=\"clientlogo\"><fieldset> <legend>Client</legend><span>" + (jade.escape(null == (jade_interp = pageData.client) ? "" : jade_interp)) + "</span></fieldset><fieldset> <legend>Project</legend><span>" + (jade.escape(null == (jade_interp = pageData.project) ? "" : jade_interp)) + "</span></fieldset><fieldset> <legend>Media</legend><span>" + (jade.escape(null == (jade_interp = pageData.media) ? "" : jade_interp)) + "</span></fieldset><fieldset><legend class=\"share\">Share</legend></fieldset></aside></div></article>");
	// iterate pageData.detailcontent
	;(function(){
	  var $$obj = pageData.detailcontent;
	  if ('number' == typeof $$obj.length) {

	    for (var $index = 0, $$l = $$obj.length; $index < $$l; $index++) {
	      var contentItem = $$obj[$index];

	buf.push("<article class=\"col-md-12 no-padding\">");
	if ( contentItem.video)
	{
	buf.push("<video-component" + (jade.attr("thumb", contentItem.thumb, true, true)) + (jade.attr("alt", contentItem.thumbAlt, true, true)) + (jade.attr("title", contentItem.thumbTitle, true, true)) + (jade.attr("vimeo", contentItem.vimeo, true, true)) + "></video-component>");
	}
	if ( contentItem.carousel)
	{
	buf.push("<carousel-component class=\"carousel-component component section no-padding\">");
	// iterate contentItem.images
	;(function(){
	  var $$obj = contentItem.images;
	  if ('number' == typeof $$obj.length) {

	    for (var $index = 0, $$l = $$obj.length; $index < $$l; $index++) {
	      var carouselItem = $$obj[$index];

	buf.push("<img" + (jade.attr("src", carouselItem.url, true, true)) + (jade.attr("alt", carouselItem.alt, true, true)) + ">");
	    }

	  } else {
	    var $$l = 0;
	    for (var $index in $$obj) {
	      $$l++;      var carouselItem = $$obj[$index];

	buf.push("<img" + (jade.attr("src", carouselItem.url, true, true)) + (jade.attr("alt", carouselItem.alt, true, true)) + ">");
	    }

	  }
	}).call(this);

	buf.push("</carousel-component>");
	}
	if ( contentItem.image)
	{
	buf.push("<section class=\"image-component component row no-padding\"><div class=\"col-xs-12 no-padding\"><img" + (jade.attr("src", contentItem.imageUrl, true, true)) + (jade.attr("alt", contentItem.imageAlt, true, true)) + "></div></section>");
	}
	if ( contentItem.mainDescription)
	{
	// iterate contentItem.mainDescription
	;(function(){
	  var $$obj = contentItem.mainDescription;
	  if ('number' == typeof $$obj.length) {

	    for (var $index = 0, $$l = $$obj.length; $index < $$l; $index++) {
	      var par = $$obj[$index];

	buf.push("<p>" + (jade.escape(null == (jade_interp = par) ? "" : jade_interp)) + "</p>");
	    }

	  } else {
	    var $$l = 0;
	    for (var $index in $$obj) {
	      $$l++;      var par = $$obj[$index];

	buf.push("<p>" + (jade.escape(null == (jade_interp = par) ? "" : jade_interp)) + "</p>");
	    }

	  }
	}).call(this);

	}
	buf.push("</article>");
	    }

	  } else {
	    var $$l = 0;
	    for (var $index in $$obj) {
	      $$l++;      var contentItem = $$obj[$index];

	buf.push("<article class=\"col-md-12 no-padding\">");
	if ( contentItem.video)
	{
	buf.push("<video-component" + (jade.attr("thumb", contentItem.thumb, true, true)) + (jade.attr("alt", contentItem.thumbAlt, true, true)) + (jade.attr("title", contentItem.thumbTitle, true, true)) + (jade.attr("vimeo", contentItem.vimeo, true, true)) + "></video-component>");
	}
	if ( contentItem.carousel)
	{
	buf.push("<carousel-component class=\"carousel-component component section no-padding\">");
	// iterate contentItem.images
	;(function(){
	  var $$obj = contentItem.images;
	  if ('number' == typeof $$obj.length) {

	    for (var $index = 0, $$l = $$obj.length; $index < $$l; $index++) {
	      var carouselItem = $$obj[$index];

	buf.push("<img" + (jade.attr("src", carouselItem.url, true, true)) + (jade.attr("alt", carouselItem.alt, true, true)) + ">");
	    }

	  } else {
	    var $$l = 0;
	    for (var $index in $$obj) {
	      $$l++;      var carouselItem = $$obj[$index];

	buf.push("<img" + (jade.attr("src", carouselItem.url, true, true)) + (jade.attr("alt", carouselItem.alt, true, true)) + ">");
	    }

	  }
	}).call(this);

	buf.push("</carousel-component>");
	}
	if ( contentItem.image)
	{
	buf.push("<section class=\"image-component component row no-padding\"><div class=\"col-xs-12 no-padding\"><img" + (jade.attr("src", contentItem.imageUrl, true, true)) + (jade.attr("alt", contentItem.imageAlt, true, true)) + "></div></section>");
	}
	if ( contentItem.mainDescription)
	{
	// iterate contentItem.mainDescription
	;(function(){
	  var $$obj = contentItem.mainDescription;
	  if ('number' == typeof $$obj.length) {

	    for (var $index = 0, $$l = $$obj.length; $index < $$l; $index++) {
	      var par = $$obj[$index];

	buf.push("<p>" + (jade.escape(null == (jade_interp = par) ? "" : jade_interp)) + "</p>");
	    }

	  } else {
	    var $$l = 0;
	    for (var $index in $$obj) {
	      $$l++;      var par = $$obj[$index];

	buf.push("<p>" + (jade.escape(null == (jade_interp = par) ? "" : jade_interp)) + "</p>");
	    }

	  }
	}).call(this);

	}
	buf.push("</article>");
	    }

	  }
	}).call(this);

	buf.push("<!-- dynamically populate content from copy.json data-->");
	page = "moreCases"
	pageData = copy.content[page]
	buf.push("<section class=\"col-md-12 no-padding more-cases\"> <div class=\"more-case-wrapper cf\">");
	// iterate pageData
	;(function(){
	  var $$obj = pageData;
	  if ('number' == typeof $$obj.length) {

	    for (var $index = 0, $$l = $$obj.length; $index < $$l; $index++) {
	      var contentItem = $$obj[$index];

	buf.push("<article class=\"col-md-4\"> <img" + (jade.attr("src", __webpack_require__(103), true, true)) + "><p>" + (null == (jade_interp = contentItem.projectName) ? "" : jade_interp) + "<cite><span>" + (jade.escape(null == (jade_interp = contentItem.writerName) ? "" : jade_interp)) + "</span><span>" + (jade.escape(null == (jade_interp = contentItem.writerTitle) ? "" : jade_interp)) + "</span></cite></p><a href=\"#\" class=\"red\">read full article</a></article>");
	    }

	  } else {
	    var $$l = 0;
	    for (var $index in $$obj) {
	      $$l++;      var contentItem = $$obj[$index];

	buf.push("<article class=\"col-md-4\"> <img" + (jade.attr("src", __webpack_require__(103), true, true)) + "><p>" + (null == (jade_interp = contentItem.projectName) ? "" : jade_interp) + "<cite><span>" + (jade.escape(null == (jade_interp = contentItem.writerName) ? "" : jade_interp)) + "</span><span>" + (jade.escape(null == (jade_interp = contentItem.writerTitle) ? "" : jade_interp)) + "</span></cite></p><a href=\"#\" class=\"red\">read full article</a></article>");
	    }

	  }
	}).call(this);

	buf.push("</div></section></section>");}.call(this,"copy" in locals_for_with?locals_for_with.copy:typeof copy!=="undefined"?copy:undefined,"page" in locals_for_with?locals_for_with.page:typeof page!=="undefined"?page:undefined,"pageData" in locals_for_with?locals_for_with.pageData:typeof pageData!=="undefined"?pageData:undefined,"undefined" in locals_for_with?locals_for_with.undefined: false?undefined:undefined));;return buf.join("");
	}

/***/ },
/* 111 */
/***/ function(module, exports, __webpack_require__) {

	var jade = __webpack_require__(94);

	module.exports = function template(locals) {
	var buf = [];
	var jade_mixins = {};
	var jade_interp;
	;var locals_for_with = (locals || {});(function (copy, page, pageData, undefined) {
	page = "entertainment"
	buf.push("<!-- dynamically populate content from copy.json data-->");
	page = "entertainment"
	copy = __webpack_require__(30)
	pageData = copy.content[page]
	buf.push("<section class=\"row no-padding work work-details\"><article class=\"col-md-12 no-padding top-main\"><h2> <blockquote>" + (null == (jade_interp = pageData.blockquote) ? "" : jade_interp) + "</blockquote></h2><cite><img src=\"assets/images/about/about-avatar.png\"><span>Mike Dowse</span><span>CEO, Wilson</span></cite></article><article class=\"col-md-12 no-padding\"><div class=\"col-md-7 top-description\">");
	if ( pageData.topDescription)
	{
	// iterate pageData.topDescription
	;(function(){
	  var $$obj = pageData.topDescription;
	  if ('number' == typeof $$obj.length) {

	    for (var $index = 0, $$l = $$obj.length; $index < $$l; $index++) {
	      var par = $$obj[$index];

	buf.push("<p>" + (null == (jade_interp = par) ? "" : jade_interp) + "</p>");
	    }

	  } else {
	    var $$l = 0;
	    for (var $index in $$obj) {
	      $$l++;      var par = $$obj[$index];

	buf.push("<p>" + (null == (jade_interp = par) ? "" : jade_interp) + "</p>");
	    }

	  }
	}).call(this);

	}
	buf.push("</div><div class=\"col-md-4 col-md-offset-1\"><aside><img" + (jade.attr("src", pageData.clientLogo, true, true)) + " class=\"clientlogo\"><fieldset> <legend>Client</legend><span>" + (jade.escape(null == (jade_interp = pageData.client) ? "" : jade_interp)) + "</span></fieldset><fieldset> <legend>Project</legend><span>" + (jade.escape(null == (jade_interp = pageData.project) ? "" : jade_interp)) + "</span></fieldset><fieldset> <legend>Media</legend><span>" + (jade.escape(null == (jade_interp = pageData.media) ? "" : jade_interp)) + "</span></fieldset><fieldset><legend class=\"share\">Share</legend></fieldset></aside></div></article>");
	// iterate pageData.detailcontent
	;(function(){
	  var $$obj = pageData.detailcontent;
	  if ('number' == typeof $$obj.length) {

	    for (var $index = 0, $$l = $$obj.length; $index < $$l; $index++) {
	      var contentItem = $$obj[$index];

	buf.push("<article class=\"col-md-12 no-padding\">");
	if ( contentItem.video)
	{
	buf.push("<video-component" + (jade.attr("thumb", contentItem.thumb, true, true)) + (jade.attr("alt", contentItem.thumbAlt, true, true)) + (jade.attr("title", contentItem.thumbTitle, true, true)) + (jade.attr("vimeo", contentItem.vimeo, true, true)) + "></video-component>");
	}
	if ( contentItem.carousel)
	{
	buf.push("<carousel-component class=\"carousel-component component section no-padding\">");
	// iterate contentItem.images
	;(function(){
	  var $$obj = contentItem.images;
	  if ('number' == typeof $$obj.length) {

	    for (var $index = 0, $$l = $$obj.length; $index < $$l; $index++) {
	      var carouselItem = $$obj[$index];

	buf.push("<img" + (jade.attr("src", carouselItem.url, true, true)) + (jade.attr("alt", carouselItem.alt, true, true)) + ">");
	    }

	  } else {
	    var $$l = 0;
	    for (var $index in $$obj) {
	      $$l++;      var carouselItem = $$obj[$index];

	buf.push("<img" + (jade.attr("src", carouselItem.url, true, true)) + (jade.attr("alt", carouselItem.alt, true, true)) + ">");
	    }

	  }
	}).call(this);

	buf.push("</carousel-component>");
	}
	if ( contentItem.image)
	{
	buf.push("<section class=\"image-component component row no-padding\"><div class=\"col-xs-12 no-padding\"><img" + (jade.attr("src", contentItem.imageUrl, true, true)) + (jade.attr("alt", contentItem.imageAlt, true, true)) + "></div></section>");
	}
	if ( contentItem.mainDescription)
	{
	// iterate contentItem.mainDescription
	;(function(){
	  var $$obj = contentItem.mainDescription;
	  if ('number' == typeof $$obj.length) {

	    for (var $index = 0, $$l = $$obj.length; $index < $$l; $index++) {
	      var par = $$obj[$index];

	buf.push("<p>" + (jade.escape(null == (jade_interp = par) ? "" : jade_interp)) + "</p>");
	    }

	  } else {
	    var $$l = 0;
	    for (var $index in $$obj) {
	      $$l++;      var par = $$obj[$index];

	buf.push("<p>" + (jade.escape(null == (jade_interp = par) ? "" : jade_interp)) + "</p>");
	    }

	  }
	}).call(this);

	}
	buf.push("</article>");
	    }

	  } else {
	    var $$l = 0;
	    for (var $index in $$obj) {
	      $$l++;      var contentItem = $$obj[$index];

	buf.push("<article class=\"col-md-12 no-padding\">");
	if ( contentItem.video)
	{
	buf.push("<video-component" + (jade.attr("thumb", contentItem.thumb, true, true)) + (jade.attr("alt", contentItem.thumbAlt, true, true)) + (jade.attr("title", contentItem.thumbTitle, true, true)) + (jade.attr("vimeo", contentItem.vimeo, true, true)) + "></video-component>");
	}
	if ( contentItem.carousel)
	{
	buf.push("<carousel-component class=\"carousel-component component section no-padding\">");
	// iterate contentItem.images
	;(function(){
	  var $$obj = contentItem.images;
	  if ('number' == typeof $$obj.length) {

	    for (var $index = 0, $$l = $$obj.length; $index < $$l; $index++) {
	      var carouselItem = $$obj[$index];

	buf.push("<img" + (jade.attr("src", carouselItem.url, true, true)) + (jade.attr("alt", carouselItem.alt, true, true)) + ">");
	    }

	  } else {
	    var $$l = 0;
	    for (var $index in $$obj) {
	      $$l++;      var carouselItem = $$obj[$index];

	buf.push("<img" + (jade.attr("src", carouselItem.url, true, true)) + (jade.attr("alt", carouselItem.alt, true, true)) + ">");
	    }

	  }
	}).call(this);

	buf.push("</carousel-component>");
	}
	if ( contentItem.image)
	{
	buf.push("<section class=\"image-component component row no-padding\"><div class=\"col-xs-12 no-padding\"><img" + (jade.attr("src", contentItem.imageUrl, true, true)) + (jade.attr("alt", contentItem.imageAlt, true, true)) + "></div></section>");
	}
	if ( contentItem.mainDescription)
	{
	// iterate contentItem.mainDescription
	;(function(){
	  var $$obj = contentItem.mainDescription;
	  if ('number' == typeof $$obj.length) {

	    for (var $index = 0, $$l = $$obj.length; $index < $$l; $index++) {
	      var par = $$obj[$index];

	buf.push("<p>" + (jade.escape(null == (jade_interp = par) ? "" : jade_interp)) + "</p>");
	    }

	  } else {
	    var $$l = 0;
	    for (var $index in $$obj) {
	      $$l++;      var par = $$obj[$index];

	buf.push("<p>" + (jade.escape(null == (jade_interp = par) ? "" : jade_interp)) + "</p>");
	    }

	  }
	}).call(this);

	}
	buf.push("</article>");
	    }

	  }
	}).call(this);

	buf.push("<!-- dynamically populate content from copy.json data-->");
	page = "entertainment"
	page = "moreCases"
	pageData = copy.content[page]
	buf.push("<section class=\"col-md-12 no-padding more-cases\"> <div class=\"more-case-wrapper cf\">");
	// iterate pageData
	;(function(){
	  var $$obj = pageData;
	  if ('number' == typeof $$obj.length) {

	    for (var $index = 0, $$l = $$obj.length; $index < $$l; $index++) {
	      var contentItem = $$obj[$index];

	buf.push("<article class=\"col-md-4\"> <img" + (jade.attr("src", __webpack_require__(103), true, true)) + "><p>" + (null == (jade_interp = contentItem.projectName) ? "" : jade_interp) + "<cite><span>" + (jade.escape(null == (jade_interp = contentItem.writerName) ? "" : jade_interp)) + "</span><span>" + (jade.escape(null == (jade_interp = contentItem.writerTitle) ? "" : jade_interp)) + "</span></cite></p><a href=\"#\" class=\"red\">read full article</a></article>");
	    }

	  } else {
	    var $$l = 0;
	    for (var $index in $$obj) {
	      $$l++;      var contentItem = $$obj[$index];

	buf.push("<article class=\"col-md-4\"> <img" + (jade.attr("src", __webpack_require__(103), true, true)) + "><p>" + (null == (jade_interp = contentItem.projectName) ? "" : jade_interp) + "<cite><span>" + (jade.escape(null == (jade_interp = contentItem.writerName) ? "" : jade_interp)) + "</span><span>" + (jade.escape(null == (jade_interp = contentItem.writerTitle) ? "" : jade_interp)) + "</span></cite></p><a href=\"#\" class=\"red\">read full article</a></article>");
	    }

	  }
	}).call(this);

	buf.push("</div></section></section>");}.call(this,"copy" in locals_for_with?locals_for_with.copy:typeof copy!=="undefined"?copy:undefined,"page" in locals_for_with?locals_for_with.page:typeof page!=="undefined"?page:undefined,"pageData" in locals_for_with?locals_for_with.pageData:typeof pageData!=="undefined"?pageData:undefined,"undefined" in locals_for_with?locals_for_with.undefined: false?undefined:undefined));;return buf.join("");
	}

/***/ },
/* 112 */
/***/ function(module, exports, __webpack_require__) {

	var jade = __webpack_require__(94);

	module.exports = function template(locals) {
	var buf = [];
	var jade_mixins = {};
	var jade_interp;
	;var locals_for_with = (locals || {});(function (copy, page, pageData) {
	buf.push("");
	copy = __webpack_require__(30)
	page = "culture"
	pageData = copy.content[page]
	buf.push("<!-- title and body copy--><section class=\"row no-padding culture\"> <article class=\"col-md-4 no-padding\"><img" + (jade.attr("src", __webpack_require__(113), true, true)) + "></article><article class=\"col-md-8 no-padding top-main\"><h2> <blockquote> \nTheir office on the 28th floor provides great views of all the amazing places in LA that I&#8217;ve wanted to see but didn&#8217;t have time \u2028to sit in  traffic for two hours to visit.</blockquote></h2><cite><img" + (jade.attr("src", __webpack_require__(97), true, true)) + "><span>Lindsay Phillips </span><span>Men's Wearhouse</span></cite></article><article class=\"col-md-12 no-padding\"><img" + (jade.attr("src", __webpack_require__(114), true, true)) + "></article><article class=\"col-md-8 no-padding table\"><div class=\"col-md-4 col-md-offset-2 no-padding\"><img" + (jade.attr("src", __webpack_require__(115), true, true)) + "></div><div class=\"col-md-6\"><h3><blockquote>I know I'm at Phenomenon when I walk past the La Brea tar pits and see the baby mammoth scream in anguish as its mother is sucked into a bubbling pit of tar. </blockquote></h3><cite><span>Lindsay Phillips</span><span>Men's Wearhouse</span></cite></div></article><article class=\"col-md-12 no-padding table\"><div class=\"col-md-4 col-md-offset-1\"><h3><blockquote> \nEvery day there's a slew of food trucks in front of their building. \u2028I gain 5 lbs. every time we have meetings there.</blockquote></h3><cite><span>Matt Stringer</span><span>Men's Wearhouse</span></cite></div><div class=\"col-md-7\"><img" + (jade.attr("src", __webpack_require__(116), true, true)) + "></div></article><article class=\"headshots col-xs-12 col-md-12 no-padding\"> <div class=\"col-md-15\"><ul><li></li><li></li><li></li></ul></div><div class=\"col-md-15\"><ul><li></li><li></li><li></li></ul></div><div class=\"col-md-15\"><ul><li></li><li></li><li></li></ul></div><div class=\"col-md-15\"><ul><li></li><li></li><li></li></ul></div><div class=\"col-md-15\"><ul><li></li><li></li><li></li></ul></div></article><article class=\"col-xs-12 col-md-10 no-padding\"><div class=\"col-xs-12 col-md-5 col-md-offset-1\"> <img" + (jade.attr("src", __webpack_require__(117), true, true)) + "></div><div class=\"col-xs-12 col-md-6\"><img" + (jade.attr("src", __webpack_require__(118), true, true)) + "><img" + (jade.attr("src", __webpack_require__(119), true, true)) + "></div></article><article class=\"col-md-12 no-padding\"><img" + (jade.attr("src", __webpack_require__(120), true, true)) + "></article></section>");}.call(this,"copy" in locals_for_with?locals_for_with.copy:typeof copy!=="undefined"?copy:undefined,"page" in locals_for_with?locals_for_with.page:typeof page!=="undefined"?page:undefined,"pageData" in locals_for_with?locals_for_with.pageData:typeof pageData!=="undefined"?pageData:undefined));;return buf.join("");
	}

/***/ },
/* 113 */
/***/ function(module, exports, __webpack_require__) {

	module.exports = __webpack_require__.p + "3102cf8850ffa8ea277e295dbf4189ee.gif";

/***/ },
/* 114 */
/***/ function(module, exports, __webpack_require__) {

	module.exports = __webpack_require__.p + "4183cb66f54621a8b116db55d7304358.png";

/***/ },
/* 115 */
/***/ function(module, exports, __webpack_require__) {

	module.exports = __webpack_require__.p + "d260080c37587f87a34fc717c2850154.png";

/***/ },
/* 116 */
/***/ function(module, exports, __webpack_require__) {

	module.exports = __webpack_require__.p + "39443628d15994fa2aa8212806ba67b9.png";

/***/ },
/* 117 */
/***/ function(module, exports, __webpack_require__) {

	module.exports = __webpack_require__.p + "2ac5efbdc76d9015dfbc00924cff8e15.png";

/***/ },
/* 118 */
/***/ function(module, exports, __webpack_require__) {

	module.exports = __webpack_require__.p + "78d208b2c1b9bdb928284d7b01843a8f.png";

/***/ },
/* 119 */
/***/ function(module, exports, __webpack_require__) {

	module.exports = __webpack_require__.p + "2af5dc10a99444a862a78614e5791d72.png";

/***/ },
/* 120 */
/***/ function(module, exports, __webpack_require__) {

	module.exports = __webpack_require__.p + "ef81018d676c09978c5776c39224d3b1.png";

/***/ },
/* 121 */
/***/ function(module, exports, __webpack_require__) {

	var jade = __webpack_require__(94);

	module.exports = function template(locals) {
	var buf = [];
	var jade_mixins = {};
	var jade_interp;
	;var locals_for_with = (locals || {});(function (copy, page, pageData) {
	buf.push("");
	copy = __webpack_require__(30)
	page = "contact"
	pageData = copy.content[page]
	buf.push("<section class=\"row no-padding contact\"><article class=\"col-md-12 no-padding top-main\"><h2> <blockquote> \nDon't call them. They're my ninjas.</blockquote></h2><cite><img" + (jade.attr("src", __webpack_require__(97), true, true)) + "><span>Douglas Ewert</span><span>CEO Men's Wearhouse & Joseph A. Bank</span></cite></article><div class=\"col-xs-12 col-sm-6 col-md-6\"><figure><img" + (jade.attr("src", __webpack_require__(122), true, true)) + "><figcaption><h3>Los Angeles</h3><ul><li>+313-800-800</li><li>5900 Wilshire Blvd, Floor 28, <br>Los Angeles, CA 90036</li></ul></figcaption></figure></div><div class=\"col-xs-12 col-sm-6 col-md-6\"><figure><img" + (jade.attr("src", __webpack_require__(123), true, true)) + "><figcaption><h3>Chicago</h3><ul> <li>+1 323 648 4000</li><li>118 N Peoria Street, Suite 5N <br>Chicago, IL 60607</li></ul></figcaption></figure></div><div class=\"clear\"></div><section class=\"contactbiz clearfix\"><div class=\"col-xs-12 col-sm-4 col-md-4 no-padding\"><h4>Jobs</h4><span>We'd love to hear from you. <br> Tell us some things LinkedIn can't</span><hr><span> <a href=\"#\">jobs@phenomenon.com</a></span></div><div class=\"col-xs-12 col-sm-4 col-md-4 no-padding\"><h4>New Business</h4><span>Pheno works mostly by referral. <br> Mostly. Not exclusively.</span><hr><span> <a href=\"#\">jobs@phenomenon.com</a></span></div><div class=\"col-xs-12 col-sm-4 col-md-4 no-padding\"><h4>PR</h4><span> We're gernerally not the ones talk about<br> ourselves. But you can ask.</span><hr><span> <a href=\"#\">jobs@phenomenon.com</a></span></div></section></section><!--include components/contact-form-->");}.call(this,"copy" in locals_for_with?locals_for_with.copy:typeof copy!=="undefined"?copy:undefined,"page" in locals_for_with?locals_for_with.page:typeof page!=="undefined"?page:undefined,"pageData" in locals_for_with?locals_for_with.pageData:typeof pageData!=="undefined"?pageData:undefined));;return buf.join("");
	}

/***/ },
/* 122 */
/***/ function(module, exports, __webpack_require__) {

	module.exports = __webpack_require__.p + "45df892f3faf37638d65c76367dbdd32.png";

/***/ },
/* 123 */
/***/ function(module, exports, __webpack_require__) {

	module.exports = __webpack_require__.p + "f5ede919c8436d9289c20706957d270f.png";

/***/ },
/* 124 */
/***/ function(module, exports, __webpack_require__) {

	var jade = __webpack_require__(94);

	module.exports = function template(locals) {
	var buf = [];
	var jade_mixins = {};
	var jade_interp;
	;var locals_for_with = (locals || {});(function (copy, page, pageData) {
	buf.push("");
	copy = __webpack_require__(30)
	page = "jobs"
	pageData = copy.content[page]
	buf.push("<!-- title and body copy--><section class=\"row no-padding jobs\"><article class=\"col-md-5 no-padding\"><img" + (jade.attr("src", __webpack_require__(125), true, true)) + "></article><article class=\"col-xs-12 col-sm-12 col-md-7 top-main\"><h2> <blockquote>After a meeting, I wasn't sure who was from what department. Every person seemed to be involved in every aspect of what they were presenting.</blockquote></h2><cite><img" + (jade.attr("src", __webpack_require__(97), true, true)) + "><span>Lindsay Phillips</span><span>Men's Wearhouse</span></cite><ul><span>Open Positions</span><li> <a href=\"#\">Digital Design Director</a></li><li><a href=\"#\">Senior Brand Strategist</a></li><li><a href=\"#\">Strategy Director</a></li><li><a href=\"#\">Digital Brand Director</a></li><li><a href=\"#\">Studio Manager\t\t\t\t\t\t\t\t\t\t\t\t</a></li></ul></article></section>");}.call(this,"copy" in locals_for_with?locals_for_with.copy:typeof copy!=="undefined"?copy:undefined,"page" in locals_for_with?locals_for_with.page:typeof page!=="undefined"?page:undefined,"pageData" in locals_for_with?locals_for_with.pageData:typeof pageData!=="undefined"?pageData:undefined));;return buf.join("");
	}

/***/ },
/* 125 */
/***/ function(module, exports, __webpack_require__) {

	module.exports = __webpack_require__.p + "e27d28b10125f390888c5a526633f1db.png";

/***/ },
/* 126 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function($) {'use strict';

	/**
	 * Created by rdollete on 4/1/16.
	 */

	angular.module('phenoCom').run(function ($rootScope, $window, $location) {
	    var $main = $('main');

	    // detect state change
	    $rootScope.$on('$stateChangeSuccess', function () {

	        // scroll to the top
	        $main.animate({ scrollTop: 0 }, 400);

	        // close snap drawer
	        $main.trigger('routeChange');

	        // fire Google Analytics tracking
	        $window.ga('send', 'pageview', { page: $location.url() });
	    });
	});
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(5)))

/***/ },
/* 127 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function($) {'use strict';

	var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol ? "symbol" : typeof obj; };

	var angular = __webpack_require__(17);

	angular.module('phenoCom').controller('phenoController', function ($state, $scope, $cookies) {
	    // temporary onload solution to hide unstyle content for now
	    // to forgot to remove display: none in layout.jade
	    window.onload = function () {
	        $('body').show();
	    };

	    // denote that user has been here, hold data for 15 days
	    var expireDate = new Date();
	    expireDate.setDate(expireDate.getDate() + 30);
	    $cookies.put('visited', 1, { 'expires': expireDate, 'path': '/' });

	    // detect state and store in scope
	    $scope.$state = $state;

	    // use current state to determine which menu item is selected
	    $scope.isSelected = function (sref) {
	        if (sref == $state.$current.name) {
	            return true;
	        }

	        return false;
	    };
	});

	angular.module('phenoCom').controller('contactController', function ($scope, $state, $http) {

	    $scope.data = {
	        fields: {
	            resume: 'Resume',
	            coverletter: 'Cover Letter'
	        },
	        labels: {
	            resume: 'Choose a File',
	            coverletter: 'Choose a File'
	        },
	        ga: {
	            resume: 'resume',
	            coverletter: 'cover_letter'
	        }
	    };

	    $scope.setAttempted = function (element) {
	        element.attempted = true;
	        return;
	    };

	    $scope.sendData = function () {

	        // fire GA event tracker
	        ga('send', 'event', 'button', 'click', 'contact_submit');

	        $scope.contactForm.attempted = true;

	        if ($scope.contactForm.$valid) {

	            var message = "Incoming Application\n\n" + "First Name: " + $scope.data.firstName + "\n" + "Last Name: " + $scope.data.lastName + "\n" + "Email: " + $scope.data.email + "\n" + "Phone Number: " + $scope.data.phone + "\n\n" + "Portfolio URL: " + $scope.data.portfolioUrl + "\n" + "LinkedIn: " + $scope.data.linkedin;

	            var url = '/sendMail';

	            // prep data for API
	            var data = {
	                'message': message,
	                'type': 'Pheno VCU',
	                'subject': 'Application from ' + $scope.data.firstName + ' ' + $scope.data.lastName
	            };

	            // create multipart/form-data format
	            fd = new FormData();
	            fd.append('data', JSON.stringify(data));
	            fd.append('resume', $scope.resume);
	            fd.append('coverletter', $scope.coverletter);

	            // middleware API call
	            $http({
	                method: 'POST',
	                url: url,
	                data: fd,
	                headers: { 'Content-Type': undefined },
	                transformRequest: angular.identity
	            }).then(function (response) {

	                $state.go('thanks');
	            }, function (data, status, headers, config) {
	                errorCallback(data);
	                console.log("Error------" + JSON.stringify(data) + " " + status);
	            });
	        } else {

	            angular.forEach($scope.contactForm, function (value, key) {
	                if ((typeof value === 'undefined' ? 'undefined' : _typeof(value)) === 'object') {
	                    var el = $scope.contactForm[key];
	                    if (el.$invalid) {
	                        el.attempted = true;
	                    }
	                }
	            });

	            $scope.contactForm.$setPristine();
	            $scope.contactForm.$setUntouched();
	        }
	    };
	});
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(5)))

/***/ },
/* 128 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function($, jQuery) {'use strict';

	/**
	 * Created by rdollete on 4/1/16.
	 */

	angular.module('phenoCom').directive('carouselComponent', function () {

	    return {
	        restrict: 'E',
	        link: function link(scope, element, attrs) {
	            var animationSpeed = 150;

	            $(element).owlCarousel({
	                singleItem: true,
	                navigation: true,
	                navigationText: ["<button class='icon-left-arrow'></button>", "<button class='icon-right-arrow'></button>"],
	                slideSpeed: animationSpeed,
	                paginationSpeed: animationSpeed,
	                rewindSpeed: animationSpeed,
	                touchDrag: true

	            });
	        }
	    };
	});

	var videoComponentTemplate = __webpack_require__(129);
	var scrolltopTemplate = __webpack_require__(130);

	// embedded vimeo player
	angular.module('phenoCom').directive('videoComponent', function () {
	    return {
	        scope: {
	            thumb: '@', alt: '@', title: '@', vimeo: '@'
	        },
	        template: videoComponentTemplate,
	        link: function link(scope, element, attrs) {
	            scope.vimeoUrl = 'https://player.vimeo.com/video/' + scope.vimeo;
	        }
	    };
	});

	angular.module('phenoCom').directive('scrolltotop', function () {
	    return {
	        template: scrolltopTemplate,
	        link: function link(scope, element, attrs) {

	            element.bind('click', function () {
	                $('html, body').animate({
	                    scrollTop: 0
	                }, 500, function () {});
	            });
	        }
	    };
	});

	// currently not in use: embedded scrollable website
	angular.module('phenoCom').directive('scrollableComponent', function ($window) {

	    return {
	        restrict: 'E',
	        link: function link(scope, element, attrs) {
	            var $element = $(element),
	                scrollFlag = false,
	                scrollClass = 'scroll-active';

	            angular.element($window).bind("scroll", function () {
	                if (this.pageYOffset >= $element.offset().top && this.pageYOffset <= $element.offset().top + 20) {
	                    if (!scrollFlag) {
	                        $element.toggleClass(scrollClass);
	                        scrollFlag = true;
	                    }
	                } else {
	                    if (scrollFlag) {
	                        $element.toggleClass(scrollClass);
	                        scrollFlag = false;
	                    }
	                }
	            });
	        }
	    };
	});

	// use this directive to bring file data into controller scope
	angular.module('phenoCom').directive('fileModel', ['$parse', function ($parse) {
	    return {
	        restrict: 'A',
	        link: function link(scope, element, attr) {
	            var model = $parse(attr.fileModel);
	            var modelSetter = model.assign;

	            element.bind('change', function () {
	                scope.$apply(function () {

	                    // make file available in scope
	                    modelSetter(scope, element[0].files[0]);

	                    // update the H4 (pseudo-field)
	                    var fileName = jQuery('#' + attr.id).val().split('\\').pop();
	                    scope.data.labels[attr.id] = scope.data.fields[attr.id] + ' Attached: ' + fileName;

	                    // fire off GA event tracker
	                    ga('send', 'event', 'upload', 'attach', scope.data.ga[attr.id]);
	                });
	            });
	        }
	    };
	}]);

	// handle page title changes on state change
	angular.module('phenoCom').directive('updateTitle', ['$rootScope', '$timeout', function ($rootScope, $timeout) {
	    return {
	        link: function link(scope, element) {

	            var listener = function listener(event, toState) {

	                var title = 'Default Title';
	                if (toState.data && toState.data.pageTitle) title = toState.data.pageTitle;

	                $timeout(function () {
	                    element.text(title);
	                }, 0, false);
	            };

	            $rootScope.$on('$stateChangeSuccess', listener);
	        }
	    };
	}]);
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(5), __webpack_require__(5)))

/***/ },
/* 129 */
/***/ function(module, exports, __webpack_require__) {

	var jade = __webpack_require__(94);

	module.exports = function template(locals) {
	var buf = [];
	var jade_mixins = {};
	var jade_interp;

	buf.push("<div class=\"component row no-padding\"><div class=\"col-xs-12 no-padding js-video vimeo widescreen\"><!--.video-thumbimg(src=\"{{thumb}}\", alt=\"{{alt}}\", title=\"{{title}}\")\n--><iframe src=\"{{vimeoUrl}}\" frameborder=\"0\" webkitallowfullscreen mozallowfullscreen allowfullscreen class=\"embed-player\"></iframe></div></div>");;return buf.join("");
	}

/***/ },
/* 130 */
/***/ function(module, exports, __webpack_require__) {

	var jade = __webpack_require__(94);

	module.exports = function template(locals) {
	var buf = [];
	var jade_mixins = {};
	var jade_interp;

	buf.push("<div class=\"backtotop\"><span class=\"icon-right-arrow\"></span><span>back to top</span></div>");;return buf.join("");
	}

/***/ }
])
});
;